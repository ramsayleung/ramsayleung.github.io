<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algorithm on In Pursuit of Simplicity</title>
    <link>https://ramsayleung.github.io/en/categories/algorithm/</link>
    <description>Recent content in algorithm on In Pursuit of Simplicity</description>
    <image>
      <title>In Pursuit of Simplicity</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.120.4</generator>
    <language>en</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 Â·</copyright>
    <lastBuildDate>Sun, 22 May 2022 16:22:34 +0800</lastBuildDate>
    <atom:link href="https://ramsayleung.github.io/en/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Topological Sort</title>
      <link>https://ramsayleung.github.io/en/post/2022/topological_sorting/</link>
      <pubDate>Sun, 22 May 2022 10:34:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/en/post/2022/topological_sorting/</guid>
      <description>1 Definition In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertx v, u comes before v in the ordering.
It sounds pretty academic, but I am sure you are using topological sort unconsciously every single day.
2 Application Many real world situations can be modeled as a graph with directed edges where some events must occur before others.</description>
      <content:encoded><![CDATA[<h2 id="definition"><span class="section-num">1</span> Definition</h2>
<p>In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <code>uv</code> from vertex <code>u</code> to vertx <code>v</code>, <code>u</code> comes before <code>v</code> in the ordering.</p>
<p>It sounds pretty academic, but I am sure you are using topological sort unconsciously every single day.</p>
<h2 id="application"><span class="section-num">2</span> Application</h2>
<p>Many real world situations can be modeled as a graph with directed edges where some events must occur before others. Then a topological sort gives an order in which to perform these events, for instance:</p>
<h3 id="college-class-prerequisites"><span class="section-num">2.1</span> College class prerequisites</h3>
<p>You must take course <code>b</code> first if you want to take course <code>a</code>. For example, in your alma mater, the student must complete <code>PHYS:1511(College Physics)</code> or <code>PHYS:1611(Introductory Physics I)</code> before taking <code>College Physics II</code>.</p>
<p>The courses can be represented by vertices, and there is an edge from <code>College Physics</code> to <code>College Physics II</code> since <code>PHYS:1511</code> must be finished before <code>College Physics II</code> can be enrolled.</p>

<figure><a href="/ox-hugo/course_prerequsites.png">
    
    
    <input type="checkbox" id="zoomCheck-1c4f5" hidden>
    <label for="zoomCheck-1c4f5">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/course_prerequsites.png"/> 
    
    
    </label></a>
</figure>

<h3 id="job-scheduling"><span class="section-num">2.2</span> Job scheduling</h3>
<p>scheduling a sequence of jobs or tasks based on their dependencies. The jobs are represented by vertices, and there is an edge from <code>x</code> to <code>y</code> if job <code>x</code> must be completed before job <code>y</code> can be started.</p>

<figure><a href="/ox-hugo/job_scheduling.png">
    
    
    <input type="checkbox" id="zoomCheck-0797d" hidden>
    <label for="zoomCheck-0797d">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/job_scheduling.png"/> 
    
    
    </label></a>
</figure>

<p>In the context of a CI/CD pipeline, the relationships between jobs can be represented by directed graph(specifically speaking, by directed acyclic graph). For example, in a CI pipeline, <code>build</code> job should be finished before start <code>test</code> job and <code>lint</code> job.</p>
<h3 id="program-build-dependencies"><span class="section-num">2.3</span> Program build dependencies</h3>
<p>You want to figure out in which order you should compile all the program&rsquo;s dependencies so that you will never try and compile a dependency for which you haven&rsquo;t first built all of its dependencies.</p>
<p>A typical example is <code>GNU Make</code>: you specific your targets in a <code>makefile</code>, <code>Make</code> will parse <code>makefile</code>, and figure out which target should be built firstly. Supposing you have a <code>makefile</code> like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># Makefile for analysis report
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="nf">output/figure_1.png</span><span class="o">:</span> <span class="n">data</span>/<span class="n">input_file_</span>1.<span class="n">csv</span> <span class="n">scripts</span>/<span class="n">generate_histogram</span>.<span class="n">py</span>
</span></span><span class="line"><span class="cl"><span class="err">python</span> <span class="err">scripts/generate_histogram.py</span> <span class="err">-i</span> <span class="err">data/input_file_1.csv</span> <span class="err">-o</span> <span class="err">output/figure_1.png</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">output/figure_2.png</span><span class="o">:</span> <span class="n">data</span>/<span class="n">input_file_</span>2.<span class="n">csv</span> <span class="n">scripts</span>/<span class="n">generate_histogram</span>.<span class="n">py</span>
</span></span><span class="line"><span class="cl"><span class="err">python</span> <span class="err">scripts/generate_histogram.py</span> <span class="err">-i</span> <span class="err">data/input_file_2.csv</span> <span class="err">-o</span> <span class="err">output/figure_2.png</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">output/report.pdf</span><span class="o">:</span> <span class="n">report</span>/<span class="n">report</span>.<span class="n">tex</span> <span class="n">output</span>/<span class="n">figure_</span>1.<span class="n">png</span> <span class="n">output</span>/<span class="n">figure_</span>2.<span class="n">png</span>
</span></span><span class="line"><span class="cl"><span class="err">cd</span> <span class="err">report/</span> <span class="err">&amp;&amp;</span> <span class="err">pdflatex</span> <span class="err">report.tex</span> <span class="err">&amp;&amp;</span> <span class="err">mv</span> <span class="err">report.pdf</span> <span class="err">../output/report.pdf</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Make</code> will generate a DAG internally to figure out which target should be executed firstly with typological sort:</p>

<figure><a href="/ox-hugo/build_dependencies.png">
    
    
    <input type="checkbox" id="zoomCheck-9b93b" hidden>
    <label for="zoomCheck-9b93b">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/build_dependencies.png"/> 
    
    
    </label></a>
</figure>

<h2 id="directed-acyclic-graph"><span class="section-num">3</span> Directed Acyclic Graph</h2>
<p>Back to the definition, we say that a topological ordering of a directed graph is a linear ordering of its vertices, but not all directed graphs have a topological ordering.</p>
<p>A topological ordering is possible if and only if the graph has no directed cycles, that is, if it&rsquo;s a directed acyclic graph(DAG).</p>
<p>Let us see some examples:</p>

<figure><a href="/ox-hugo/directed_acyclic_graph.png">
    
    
    <input type="checkbox" id="zoomCheck-3b058" hidden>
    <label for="zoomCheck-3b058">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/directed_acyclic_graph.png"/> 
    
    
    </label></a>
</figure>

<p>The definition requires that only the directed acyclic graph has a topological ordering, but why? What happens if we are trying to find a topological ordering of a directed graph? Let&rsquo;s take the <code>figure 3</code> for an example.</p>

<figure><a href="/ox-hugo/dag_issue.png">
    
    
    <input type="checkbox" id="zoomCheck-a4346" hidden>
    <label for="zoomCheck-a4346">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/dag_issue.png"/> 
    
    
    </label></a>
</figure>

<p>The directed graph problem has no solution, this is the reason why directed cycle is forbidden</p>
<h2 id="kahn-s-algorithm"><span class="section-num">4</span> Kahn&rsquo;s Algorithm</h2>
<p>There are several <a href="https://en.wikipedia.org/wiki/Topological_sorting#Algorithms">algorithms</a> for topological sorting, Kahn&rsquo;s algorithm is one of them, based on breadth first search.</p>
<p>The intuition behind Kahn&rsquo;s algorithm is pretty straightforward:</p>
<p><strong><strong>To repeatedly remove nodes without any dependencies from the graph and add them to the topological ordering</strong></strong></p>
<p>As nodes without dependencies are removed from the graph, the original nodes depend on the removed node should be free now.</p>
<p>We keep removing nodes without dependencies from the graph until all nodes are processed, or a cycle is detected.</p>
<p>The dependencies of one node are represented as in-degree of this node.</p>
<p>Let&rsquo;s take a quick example of how to find out a topological ordering of a given graph with Kahn&rsquo;s algorithm.</p>

<figure><a href="/ox-hugo/kahn%27s_algorithm_1.png">
    
    
    <input type="checkbox" id="zoomCheck-c84fa" hidden>
    <label for="zoomCheck-c84fa">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/kahn%27s_algorithm_1.png"/> 
    
    
    </label></a>
</figure>


<figure><a href="/ox-hugo/kahn%27s_algorithm_2.png">
    
    
    <input type="checkbox" id="zoomCheck-6a74a" hidden>
    <label for="zoomCheck-6a74a">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/kahn%27s_algorithm_2.png"/> 
    
    
    </label></a>
</figure>


<figure><a href="/ox-hugo/kahn%27s_algorithm_3.png">
    
    
    <input type="checkbox" id="zoomCheck-a6975" hidden>
    <label for="zoomCheck-a6975">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/kahn%27s_algorithm_3.png"/> 
    
    
    </label></a>
</figure>


<figure><a href="/ox-hugo/kahn%27s_algorithm_4.png">
    
    
    <input type="checkbox" id="zoomCheck-020a2" hidden>
    <label for="zoomCheck-020a2">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/kahn%27s_algorithm_4.png"/> 
    
    
    </label></a>
</figure>

<p>Now we should understand how Kahn&rsquo;s algorithm works. Let&rsquo;s have a look at a C++ implementation of Kahn&rsquo;s algorithm:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// Kahn&#39;s algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1">// `adj` is a directed acyclic graph represented as an adjacency list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">findTopologicalOrder</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">adj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_degree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">to_vertex</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">in_degree</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// queue contains nodes with no incoming edges
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">in_degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">order</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">order</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">next</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">in_degree</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// there is no cycle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">order</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// return an empty list if there is a cycle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="bonus"><span class="section-num">5</span> Bonus</h2>
<p>When a pregnant woman takes calcium pills, she must make sure also that her diet is rich in vitamin D, since this vitamin makes the absorption of calcium possible.</p>
<p>After reading the demonstration of topological ordering, you (and I) too should take a certain vitamin, metaphorically speaking, to help you absorb. The vitamin D I pick for you (and myself) is two leetcode problems, which involve with the most typical use case of topological ordering &ndash; college class prerequisites:</p>
<ul>
<li><a href="https://leetcode.com/problems/course-schedule/">Course Schedule</a></li>
<li><a href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a></li>
</ul>
<h2 id="reference"><span class="section-num">6</span> Reference</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=cIBFEhD77b4">Topological Sort | Kahn&rsquo;s Algorithm | Graph Theory</a></li>
<li><a href="https://docs.gitlab.com/ee/ci/directed_acyclic_graph/">Directed Acyclic Graph</a></li>
<li><a href="https://gertjanvandenburg.com/files/talk/make.html">Hands-on Tutorial on Make</a></li>
<li><a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological sorting</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
