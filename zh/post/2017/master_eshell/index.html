<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>(翻译)Mastering Eshell | 菠萝油与天光墟</title>
<meta name=keywords content="eshell,"><meta name=description content="An complete instroduction about Eshell"><meta name=author content="Ramsay Leung"><link rel=canonical href=https://ramsayleung.github.io/zh/post/2017/master_eshell/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.756d16b9d1a19b0d7274ca93e0428bf24ca10b144104611c6875be78291ca07b.css integrity="sha256-dW0WudGhmw1ydMqT4EKL8kyhCxRBBGEcaHW+eCkcoHs=" rel="preload stylesheet" as=style><link rel=icon href=https://ramsayleung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ramsayleung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ramsayleung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ramsayleung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ramsayleung.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://ramsayleung.github.io/zh/post/2017/master_eshell/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css integrity=sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js integrity=sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MG65HQHEL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MG65HQHEL")}</script><meta property="og:url" content="https://ramsayleung.github.io/zh/post/2017/master_eshell/"><meta property="og:site_name" content="菠萝油与天光墟"><meta property="og:title" content="(翻译)Mastering Eshell"><meta property="og:description" content="An complete instroduction about Eshell"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-02-28T00:00:00-08:00"><meta property="article:modified_time" content="2025-01-09T19:20:26-08:00"><meta property="article:tag" content="Eshell"><meta property="article:tag" content="Emacs"><meta property="og:image" content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="(翻译)Mastering Eshell"><meta name=twitter:description content="An complete instroduction about Eshell"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ramsayleung.github.io/zh/post/"},{"@type":"ListItem","position":2,"name":"(翻译)Mastering Eshell","item":"https://ramsayleung.github.io/zh/post/2017/master_eshell/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"(翻译)Mastering Eshell","name":"(翻译)Mastering Eshell","description":"An complete instroduction about Eshell","keywords":["eshell",""],"articleBody":"Emacs 支持若干种shell,但是就功能丰富度，以及与Emacs 的集成程度而言， 无一能望Eshell项背。\nEshell 是一个完全由Emacs Lisp 编写的shell,但是不要以为这样Eshell在功能上就会先天不足，它能代替绝大部分GNU核心功能集和Bourne shell家族的命令以及相关特性。\n此外，通过用Emacs Lisp 重写了类似 ls 和 cp 等常用命令，使Eshell 可以成为真正的跨平台Shell.\n但是，Eshell 有一个很大的不足，那就是Eshell 严重缺乏文档与之形成鲜明对比的是，Emacs 及其生态都拥有丰富的文档\nOverview 与Emacs 中的其他shell 不一样的是，Eshell 不是继承默认与的子进程进行交互的 comint-mode 因为Eshell 不是一个子进程，所以它就没有必要使用 comint-mode 了；不过似乎这是件 好事，因为这意味着 comint-mode 的例程和钩子是不会作用于Eshell 的。\n此外，几乎所有 comint-mode 的常用命令，都在Eshell 中重新实现了，并且使用相同的按键绑定.\n当然，也有为数不多的按键绑定没有迁移到Eshell,例如在Eshll 中搜索历史命令的=comint-history-isearch-backward-regexp= 是绑定到了 M-r, 而原来shell中相同功能的命令的按键就是 C-r Eshell 可以在所有的平台都正常工作.\n其实和Eshell 真正进行交互的是一个通用的中间件(即 Emacs Lisp/C 的一个库),而该中间件又会跟你的操作系统进行通信，处理例如复制文件 等相关操作。\n此外，这个中间件甚至支持在Eshell 中使用 Tramp 的特性, 由于Emacs 是血统纯正的Unix 产物，Eshell 是可以重现例如bash 等传统Unix shell 以及 其他GNU 工具链的同样功能的。\n此外，如果你使用的是Windows,你应该感到庆幸，因为你再也不用折腾 cygwin ,也不需要为跨平台移植Emacs 而担忧依赖问题。\n事实上，对比=cygwin= 的bash,在很多方面，Eshell 对Windows 的支持是做得更好滴。\n例如，你不再需要 /cygdrive/c 来扩展相应的功能，因为Eshell 自身就支持Windows/MS-DOS 的路径 (所以 cd D: 或者 D: 同样都可以进入D 盘)\n虽然Eshell 有很多好处，但是我还是要列出那些让人们很困惑的观点(或者说是误解):\nEshell 不是一个终端模拟器，它不是跟shell 进行通信，事实上，它就是一个shell. 它做的所有工作，无论是在屏幕展示数据，还是获取目录里面的信息，它都是通过Emacs 实现的，然后Emacs会再跟你的操作系统进行通信 由于Eshell 跟其他进程通信的方式 (特别是异步通信),所以可能导致它的缓冲区(Buffers) 和其他中断操作出现问题 Eshell 无法直接支持交互命令 (按照Eshell 的说法，叫做“可视化命令”),例如top ,所以你一定要告诉Eshll应在单独的 ansi-term 实例运行此类命令 它不是 bash 或者 zsh,更不是 csh,所以不要像操作它们那样操作Eshell 即使Eshell 跟它们真的很像。因此，如果你想更加高效地使用Eshell,你最好把它当作一个不一样的shell Commands Eshell 是可以调用几乎所有的已加载的elisp 函数的；这种灵活性是其它shell 无法想象的也是它们力所不能及的。\n事实上，这种在shell 里面跟elisp 函数结合的玩法理应得到更多人的支持和推崇，因为它真的很酷(当然也很有用).假如你想在Emacs 里面打开 foobar.txt ,你只需调用 find-file foobar.txt,Eshell 就会调用对应的 (find-file \"foobar.txt\") ,并为你打开文件\nTechnical Details 所有被Eshell 执行的命令都有一个执行的顺序，这是必需传递给Emacs 的有序列表， 因为这个列表决定了Eshell 的哪一部分应该处理该命令的。\n如果该列表中没有找到可以执行你的操作的函数或者对应命令，你会被告知，你输入的是无效命令\n假设 你想调用 cp 命令，调用顺序如下：\n完整的路径 (即 /bin/cp),在 /bin 目录下执行 cp 寻找命令的前缀， eshell-explict-command-char (默认值是 “=”),如果有前缀的话,那么，在搜索路径寻找对应的命令 寻找shell 命令的别名 (alias 命令) 在搜索路径寻找 cp ,即 $PATH (或者 eshell-path-env) 定义的路径 寻找叫做 cp 的Lisp 函数 或者 叫 eshell/cp 的elisp 函数 变量 eshell-prefer-lisp-functions 让内部的elisp 函数调用要先于外部调用，这意味着，当该变量值为 t 的时候，Eshell 会 最先 调用elisp 函数，而不是 =最后=才调用；\n但是，当命令前缀(即 eshll-explicit-command-char)被指定，该变量会被忽略\nBuilt-in Commands Eshell 有很多很好用的通过Emacs-Lisp 重写的命令，这些命令实现了绝大部分GNU 核心工具集 或者你所钟爱的shell 的特性，所以这些命令被称为\"Alias functions\"(别名函数).\n但是Eshell 并不是全盘模拟其他Shell 的功能特性，如果你传递了一些参数，试图调用Eshell未实现的功能时，Eshell 会自动调用外部的对应的命令来实现你想要的功能 (当然前提是你已经安装该命令) 下面列出Eshell 已经重新实现的命令： cat , cp , ls , cd , export , dirs , du , echo , env , kill ln , mkdir , mv , alias , popd , pushd , pwd , rm , rmdir time , umask. Eshell 注重跟原有的GNU工具功能同步，所以你不用担心因Eshell 命令跟其他原生Shell 命令不一致而导致的问题\nCommand Interception Eshell 有一个很cool 的特性，那就是某些命令会被拦截并且传递给Emacs.\n这种机制允许你调用一个命令例如 man ls,但是真正调用处理的是Emacs 内置的 man.\n此外，对于之前提及的交互式命令而言，这种特性是很重要的，因为Eshell 是没有能力处理该命令的。\n但真正展现该特性威力的还是那么复杂的命令，例如 grep diff,因为Emacs 本身就内置了更加强大的 grep 和 diff 工具。\n这种特性真真实实展示了Eshell 对比其他shell 的强大之处\n下列的命令都会被重定向到Emacs内置的功能去： agrep , diff , egrep , fgrep , glimpse , grep , info , jobs locate , man , occur , su , sudo , whoami su sudo whoami 是与 TRAMP 相关的命令，所以如果你是连接到远程shell 的 这些命令也是可以正常工作的\nSubshells 你可以使用 $() 来调用命令，并且把命令对应的输出当作接下来命令的参数，就好像你在bash 那样使用。\n但是你要谨记的一样事情就是你是无法使用反引号 =``=来生成一个subshell的。\n虽然你也可以使用像调用subshell 的语法来调用标准的elisp form: (form ....) 注意没有了 $,不过我并不推荐这种用法，因为很多情况，这种用法都是不行的\nUseful Elisp Commands Eshell 有一套可以让你每天的生活变得更美好的帮助函数(helper function), 此外你可以在Eshell调用几乎所有的elisp 函数，这就意味着，你拥有无上的能力来控制你的shell.\n接下来，我会列举那些为Eshell 专门编写的命令和一些我觉得很有用的命令。\n我也编写了挺多的elisp 函数了 (部分是专门写给Eshell,其他的就不是了)\nlistify ARGS 将字符串参数解析成 elisp 列表符号，然后打印到屏幕。\n该函数不仅可以解析 POSIX 类型的参数，也可以解析 MS-DOS/Windows 类型参数\naddpath PATH 将参数 (必须是文件路径) 添加到环境变量 $PATH,如果没有参数被指定的话，那么将原有的变量值输出到屏幕\nunset ENV-VAR 移除已有的环境变量\nfind-file FILE 搜索文件FILE,然后在Emacs 中打开该文件。这个函数与 TRAMP 相关，所以也可以远程工作\ndired DIRECTORY 在目录 DIRECTORY 下打开一个 dired 缓冲区\ncalc-eval EXPR 在Emacs calculator 执行该表达式 EXPR\nupcase STR /downcase STR 字符串 STR 大小写转换\nvc-dir DIRECTORY 展示在版本控制下的目录 DIRECTORY 的状态，跟大多数版本控制工具的 status 命令相同\nediff-files FILE1 FILE2 使用Emacs 的比较引擎 (diff engine) ediff,对文件 FILE1 FILE2 进行比较\nAliasing 你可以像在其它主流的shell 那样给Eshell命令赋予别名，操作是一样滴，此外，你甚至可以混合使用elisp 函数和Eshell 命令。\nalias 命令的格式是 alias alias-name definition definition 必须由一对单引号 '' 包围。\n你也可以使用其它shell 的参数引用形式：\n例如 $1 指第一个参数， $2 指第二个参数，依此类推，或者 $= 指所有的参数。 当参数没有在 definition 被引用，Eshell 会自动把参数添加到命令的末尾，并把参数忽略\n如果想移除一条命令的别名，只需不对变量 definition 赋值 (即 alias alias-name) 别名就会被自动移除，如果想列出所有的别名，只需输入 alias\nEshell 会把命令的别名及其定义写入到变量 eshell-aliases-file 然后统一被变量 Eshell-directory-name 管理；然后别名默认会被统一写入到 ~/.Eshell/alias.\n每次你更改一个命令别名，都会重复上面的流程, 另外一个很有用的特性就是别名自动修正 (auto-correcting aliasing), 如果你输入 一个无效的命令太多次 (变量 eshll-bad-command-tolerance 表示触发自动更正的最低 次数，默认值为3),Eshell会为你真正想执行的命令提供别名.\n例如你想输入的是 cp 但是输入了太多次的 co,所以下次你输入 co 的时候，Eshell 就会自动执行 cp.\n当然，如果你不喜欢这种特性的话，你可以把最低次数设得很大\nUseful Examples 让我们把长长的 find-file 命令映射到更顺手的别名 ff:\n1 alias ff 'find-file $1' 把 dired 映射到 d:\n1 alias d 'dired $1' Visual Commands 有一些对Eshell 而言是太复杂的命令，Eshell 是无法直接显示的，所以需要特殊的处理\n例如 top ,是无法与一些哑终端(dumb terminal)一起正常工作的。\n为了使这些命令正常工作，Eshell 会运行一个终端模拟器 term 来执行这些的命令 (即被称为可视化的命令)\n如果你想修改可视化命令的列表，你可以修改变量 eshell-visual-commands\nCommand History Eshell 有功能丰富的命令行历史机制，但是因为Eshell 不是继承 comint-mode 的\n所以 comint-mode 与历史相关的功能，Eshell 是没法用的，不过它绝大部份的功能都已经在Eshell 重新实现了\nM-r /M-s 向前或者向后搜索命令，支持正则表达式\nM-p/M-n 在历史命令列表中前进或者后退\nC-p/C-n Eshell上一条命令或者下一条命令\nC-c M-r /C-c M-s 回到上一条/下一条历史命令，历史命令必须与现在的命令输入一致。\n例如现在的输入是： ls ,那么回到的上一条 /下一条历史命令必须是 ls,或者以 ls 开头的命令，如 lsmod\n不足的是，新的经过修改的命令 comint-history-isearch-backward-regexp (在 comint 键绑定是 M-r)在Eshll 是无法使用的，因为Eshell 不是继承于 comint (所以在升级中被忽略了)\nHistory Interaction 像bash 和其它shell 那样，Eshell 也支持历史的修改和交互。\n如果想要知道历史交互是怎么操作的，你就需要回去翻一下 bash 的手册了。接下来我会总结一下Eshell 大部份的历史交互用法\n!! 重复上一条命令\n!ls 重复上一条以 ls 开头的命令\n!?ls 重复上一条包含 ls 的命令\n!ls:n 从上一条以 ls 开头的命令截取第n个参数\n!ls 使用命令补全，显示补全结果中包含 ls 的命令\n^old^new 快速替换，对于上一条命令，使用 old 来代替命令中的 new (备注：似乎有Bug)\n$_ 返回上一条执行的命令的最后一个参数\nEshll 也支持bash 历史修改(例如 !!:s/old/new/),如果你想了解更多的信息， the bash reference on history interaction 可以告诉你你想知道的东西\nCommandline Interaction The Eshell Prompt 你可以通过修改变量 eshell-prompt-function 来自定义Eshell 的提示符；该变量 有一个函数定义了Eshell 命令行提示符应该包含的内容。\n通过用elisp 来管理Eshell 命令行提示符的配置，你就可以实现你想要的任何特性。\n你需要注意的事情就是：你需要告诉Eshell,命令行提示符长什么样子，所以你必须修改变量 eshell-prompt-regexp ,那样 Eshell 就会知道你想要的提示符长什么样子了\nThe Commandline Eshell 可以使用反斜杠 \\ 来转义新行，以及基本的多行输入。\n另外一个输入多行的文学字符串 (literal string)的方法就是使用单引号：输入一个单引号，然后回车， 接着你就可以输入你想输入的内容，最后用另外一个单引号结束输入。\n如果你使用双引号的话，Eshell 会自动展开 subshell 命令并且展开相应的变量得益于Eshell 的调用机制，你甚至可以回去继续修改引号里面的文本。\n当你想回去修改你不喜欢的内容，让Eshell像你预期那样工作的时候，你就会觉得这种特性真的相当 有用\nUseful Keybindings Eshell 做了很多与Eamcs 进行交互的功能的改进，而且，这些改进足以影响你的生活 质量，让我为你一一道来：\nC-c M-b 将已经某个缓冲区的名字插入到当前光标\nC-c M-i 将已经某个进程的名字插入到当前光标\nC-c M-v 将一个环境变量的名字插入到当前光标\nC-c M-d 在直接输入和延迟输入(回车确认)之间切换 (对不能与来源于其他缓冲区的输入正常工作 的命令来说就很有用了)\nArgument Predicates 参数谓词是一个很擅长过滤文件，甚至elisp列表的工具。\nEshell的谓词语法是参照zsh 的，所以如果你熟悉zsh的参数谓词，你也可以以同样的方式来使用Eshell.\n与Eshell 绝大部分迥异的是，参数谓词是有详细的文档的。你可以通过输入 eshell-display-predicate-help\n或者 eshell-display-modifier-help 来查看帮助文档参数谓词用来过滤有相同模式的文件是很有用，你不需再花费额外的时间来使用诸如 find ls 此类命令。\n虽然有帮助手册，但是手册还是很简单，不尽人意，所以我自己总结了一些用法来帮助读者了解相关特性。\n但是最好的学习方法还是多尝试，多出错，多总结\nSyntax Reference 我就不把那么多的谓词和修饰符一一列出来了，因为Eshell 的手册已经作了很详细的解释了，你需要做的就是自己查看\nGlobbing Eshell 的匹配模式和其他常用shell 的是基本一致滴：shell 会扩展文件和路径的匹配 模式，然后将匹配后的列表当作参数传递给相应的命令，例如 ls.\n这就是为什么你一起使用 find 和 xargs 命令的时候，最好要把 -print0 传递给 find 并且把 -0 传递给 xargs.\n因为如果你不这样做的话，文件名或者路径名中的特殊字符或者空格就会 让 xargs 不知道如何正确地处理。通过使用 NUL 字符作为分隔符，保证字符可以被正确地标记，并且文件中紧跟着 / 的 NUL 字符会被标记为无效字符\nElisp Lists 如果你把Eshell 的列表理解成输出的 form 的elisp列表，你会发现理解起来变得容易因为事实上Eshell 是可以通过Elisp 来处理列表的，而处理列表恰恰是Lisp 擅长的东西最简单的模式扩展就是 echo *,该命令会把当前文件夹下所有匹配的文件以列表的形式 打印出来。\n因为，正如我先前提及的那样，通配符扩展是同步一致进行的，所以我可以在 在使用 * 的同时再使用另外一个修饰符。\n例如: 我们把当前文件夹下的所有文件名变成大写的形式，并以列表的形式打印出来：\n1 2 / $ echo *(:U) (\"BAR\" \"BIN/\" \"DEV/\" \"ETC/\" \"FOO\" \"HOME/\" \"LIB/\" \"TMP/\" \"USR/\" \"VAR/\") 请注意，我是怎样在使用模式扩展的同时使用 ().这对括号可以让你使用参数修饰符或者 是谓词。\n修饰符是可以修饰你的结果列表的(很惊讶吧).\n修饰符总是以冒号 : 开头滴， 而谓词却不一样。\n我会展示另外一个例子，这次这个例子我会使用谓词来过滤目录：\n1 2 / $ echo *(^/) (\"bar\" \"foo\") 这个 ^ 在上面的命令的作用，是跟在正则表达式中一样，用作取反，而斜杠的作用 / 是只代表目录，所以上面的作用就是打印所有文件\n对于修饰符和谓词，我也可以不使用模式扩展\n1 2 / $ echo (\"foo\" \"bar\" \"baz\" \"foo\")(:gs/foo/blarg) (\"blarg\" \"bar\" \"baz\" \"blarg\") 这次我是把所有的 foo 代替为 blarg.\n你可以发现语法是相同的，只是这次我不是使用模式匹配来获取文件列表，而是直接输入文件的列表.\n使用参数谓词和修饰符的好处是你大大减少了输入的命令行数量，因为用谓词可以处理权限 ，属主，文件属性，甚至更多方面的问题\nAdding New Modifiers and Predicates 你也可以添加自己的谓词 (eshell-predicate-alist)或者修饰符 (eshell-modifier-alist):\n1 (add-to-list 'eshell-modifier-alist '(?X . '(lambda(lst)(mapcar 'rot13 lst)))) 我已经将 rot13 绑定到 X 了，替换结果如下：\n1 2 / $ echo (\"foo\" \"bar\" \"baz\")(:X) (\"sbb\" \"one\" \"onm\") Plan 9 Smart Shell Eshell 有一个 Plan 9 终端的弱化版，叫做 the Eshell smart display.\nEshell 的智能展示(smart display)意味着它改进了所有黑客所习惯的 输入－运行－修改 工作流程。\n智能展示特别之处在于，Eshell 的光标不会像普通的shell那样，落在你运行 的命令的输出后面；\n相反，光标的位置会保持在你输入命令的位置，让你可以通过 M-p M-n 或者其他修改历史的命令更容易地修改你输入的命令.\n如果你启用了 smart display 模式，你还可以使用 SPC 向下翻页，或者使用 BACKSPACE 向上翻页来查看那些长时间运行的命令的输出。\n如果你按下了任何其它的按键，光标会直接跳到你缓冲区的结尾，就好像你没有启用 smart display 运行命令时那样\n值得注意的是，如果Eshell 检测到你想回顾最后一条执行的命令时，Eshell 会很贴心地帮你回顾的，但是，如果你没有这样的行为，Eshell 的光标会直接跳转到缓冲区的结尾.\n这么看来，Eshell真的很智能，而且它也有一些设置可以让你微调相关的行为。\n你会发现智能显示 (smart display)真的非常有用，特别是你可以通过移动按键就能修改\n刚刚执行过的命令；例如修改拼写错误的命令或者是给相应的命令添加参数, 智能显示还可以被设置成当命令成功执行时，不使用扩展的 edit mode;并且隐藏命令输出, 就好像你执行 chown 那样。\n这也是我喜欢的玩法，如果你也想试试这种玩法，你可以把下面的elisp 代码添加到你的 .emacs 文件：\n1 2 3 4 5 (require 'eshell) (require 'em-smart) (setq eshell-where-to-jump 'begin) (setq eshell-review-quick-commands nil) (setq eshell-smart-space-goes-to-end t) 如果Eshell 已经被初始化(即你已经在Emacs运行了一个Eshell实例),那样的话，运行 上面的代码是不会起作用的。\n你必须在Eshell 里面按下 M-: 然后输入 (shell-smart-initialize) ,或者直接重启Emacs 智能显示真的是非常有用的特性，但是你一时半刻是很难完全领会其全部的精妙之处滴。\n你直接输入一个命令，Eshell的光标就会跳转到缓冲区的结尾，所以你会觉得光标似乎本来就在那里\nRedirection Eshell 的重定向跟其它shell 的工作方式基本是一样的，但是，有一项非常重要的差异就是Eshell 必须模拟可能不存在的伪设备，例如Windows 平台上的 /dev/null 其实是 NUL\n另外一个值得注意的地方就是：虽然Eshell 支持重定向，但是只是支持输出重定向，是 不支持输入重定向的。\n为了避免跳进输入重定向这个坑，你最好使用管道。\n重定向到标准输入 标准输出，标准错误都是可以正常工作的，此外，你也可以重定向到多个目标，很不错的特性吧\nTo Emacs 因为Eshell 在内部用Elisp重新实现了各种伪设备，所以也就无需跟Unix 的设备文件打交道了，甚至，可以用Elisp实现自己的伪设备。\n一个很好的例子就是，你可以把重定向到一个你选择的缓冲区，用下面的命令就能实现：\n1 / $ cat mylog.log \u003e\u003e # 我之前提到的快捷键 C-c M-b 就是可以把一个选定的缓冲区的名字插入到光标前\n此外，你也可以把输出直接重定向到Elisp 的符号(不过注意，不要执行错误的设置)\n1 2 3 / $ echo foo bar baz \u003e #'myvar / $ echo $(cadr myvar) bar 如果你将变量 eshell-buffer-shorthand 设置为 t 的话。\n你就可以使用缓冲区的速记名, 例如 #'*scratch*',但是你就不能直接重定向到Elisp 的符号了\nTo Pseudo-Devices Eshell 重新实现了以下的伪设备：\n/dev/eshell 以交互的方式，把结果输出到Eshell\n/dev/null 把结果输出到 NULL 设备\n/dev/clip 把结果输出到剪切板\n/dev/kill 把结果输出到 kill ring\n跟通用的shell 一样，使用 \u003e 代表覆盖(或者新建);使用 \u003e\u003e 代表追加\nTo custom virtual target 你通过修改变量 eshell-virtual-targets 创建自己的可视化目标(即存储你想创建的 伪设备的名字的一个列表),以及修改代表重定向行为(即覆盖或追加或插入)的函数 mode\nTRAMP Eshell 可以很好地支持TRAMP,这意味着如果Eshell 所在的目录是在远程服务器的话， 像 su sudo whoami 这样的命令会自动作用在远程服务器\n想直接使用TRAMP,你可以像使用 C-x C-f 寻找文件那样输入TRAMP的命令符，然后你就可以使用TRAMP 了。\n虽然你会觉得Eshell里面使用TRAMP有点奇怪，但是你的确得到了 一个TRAMP的远程shell,不是么？\n此外，你不应把TRAMP局限在使用远程shell, 你可以在本地 使用 sudo 和 su 命令的\n有关TRAMP 的更详细的用法，我总结在了另外一篇文章，不过如果你迫不及待想了解更多 有关TRAMP的用法，官方手册 是一个很好的选择\nStartup Scripts 跟其它的shell 一样，Eshell 也支持 login 和 profile 的配置文件。\nlogin 和 profile 配置文件的绝对路径分别保存在变量 eshell-login-script 和 eshell-rc-script 不过默认情况下，上述两个配置文件都保存在 ~/.eshell/.\n顺便说一下，Eshell的配置文件也是使用 # 来注释变量和语句的\nMore Customization 如果你想折腾的话，Eshell 有成百上千的选项供你选择。\n如果你想配置Eshell 的话，按下 M-x 然后输入 customize-group 回车，然后输入 eshell 回车确认\nConclusion 额，我觉得我已经总结了Eshell 的大部份用法了，希望你可以在其中发现乐趣。\n因为与Emacs 的紧密结合，Eshell 有了各种各样突出好用的特性，但是你需要理解的是，Eshell 的诞生不是 为了全盘取代bash 或者其它你喜欢的终端模拟器，它只是希望在Emacs 里面就可以完成我们 日常必需的命令行操作。\n如果你要运行很多交互式的命令，Eshell 就可能不是很有用了 因为为了运行你输入的每一条可视化命令，Eshell 都会在Emacs 里面启动一个新的终端模拟器。\nEshell 有TRAMP支持，自定义伪设备，袖珍的elisp REPL和很多非常有用的命令，例如对你打开的文件或者目录，调用 find-file 或者 dired.正是这种种有用的特性， 让Eshell 成为我工具箱里面一个非常可靠的工具。\n原文地址 Mastering Eshell ,在下翻译水平有限，如有错误，还望指出\n公号同步更新，欢迎关注👻 ","wordCount":"8088","inLanguage":"zh","image":"https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2017-02-28T00:00:00-08:00","dateModified":"2025-01-09T19:20:26-08:00","author":{"@type":"Person","name":"Ramsay Leung"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ramsayleung.github.io/zh/post/2017/master_eshell/"},"publisher":{"@type":"Organization","name":"菠萝油与天光墟","logo":{"@type":"ImageObject","url":"https://ramsayleung.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ramsayleung.github.io/zh/ accesskey=h title="Home (Alt + H)"><img src=https://ramsayleung.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://ramsayleung.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li class=dropdown><a href=https://ramsayleung.github.io/zh/categories/ title="系列 "><span>系列 ▾</span></a><div class="menu-more-content dropdown-content"><a href=https://ramsayleung.github.io/zh/categories/%E5%BE%97%E5%A4%B1%E6%84%9F%E6%82%9F/ title=得失感悟><span>得失感悟
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E6%97%85%E5%8A%A0%E7%BB%8F%E5%8E%86 title=旅加经历><span>旅加经历
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/ title=我的工作流><span>我的工作流
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6/ title=测试技能进阶><span>测试技能进阶
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BD%AF%E6%8A%80%E8%83%BD%E6%8C%87%E5%8C%97/ title=软件工程师的软技能指北><span>软件工程师的软技能指北
</span></a><a href=https://ramsayleung.github.io/zh/categories/reinvent-%E9%87%8D%E6%96%B0%E9%80%A0%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97 title=Reinvent-重新造轮子系列><span>Reinvent-重新造轮子系列</span></a></div></li><li><a href=https://ramsayleung.github.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://ramsayleung.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://ramsayleung.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://ramsayleung.github.io/zh/about_me_zh/ title=关于><span>关于</span></a></li><li><a href=https://ramsayleung.github.io/zh/index.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ramsayleung.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://ramsayleung.github.io/zh/post/>Posts</a></div><h1 class="post-title entry-hint-parent">(翻译)Mastering Eshell</h1><div class=post-description>An complete instroduction about Eshell</div><div class=post-quote><blockquote><p>人生最大的一种痛, 不是失败, 而是没有经历自己想要经历的一切。</p></blockquote></div><hr class=post-separator><div class=post-meta><span title='2017-02-28 00:00:00 -0800 -0800'>二月 28, 2017</span>&nbsp;·&nbsp;17 分钟&nbsp;·&nbsp;8088 字&nbsp;|&nbsp;<a href=https://github.com/ramsayleung/ramsayleung.github.io/blob/master/content/post/2017/master_eshell.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#overview>Overview</a></li><li><a href=#commands>Commands</a></li><li><a href=#technical-details>Technical Details</a></li><li><a href=#built-in-commands>Built-in Commands</a></li><li><a href=#command-interception>Command Interception</a></li><li><a href=#subshells>Subshells</a></li><li><a href=#useful-elisp-commands>Useful Elisp Commands</a><ul><li><a href=#listify-args>listify ARGS</a></li><li><a href=#addpath-path>addpath PATH</a></li><li><a href=#unset-env-var>unset ENV-VAR</a></li><li><a href=#find-file-file>find-file FILE</a></li><li><a href=#dired-directory>dired DIRECTORY</a></li><li><a href=#calc-eval-expr>calc-eval EXPR</a></li><li><a href=#upcase-str-downcase-str>upcase STR /downcase STR</a></li><li><a href=#vc-dir-directory>vc-dir DIRECTORY</a></li><li><a href=#ediff-files-file1-file2>ediff-files FILE1 FILE2</a></li></ul></li><li><a href=#aliasing>Aliasing</a><ul><li><a href=#useful-examples>Useful Examples</a></li></ul></li><li><a href=#visual-commands>Visual Commands</a></li><li><a href=#command-history>Command History</a><ul><li><a href=#m-r-m-s>M-r /M-s</a></li><li><a href=#m-p-m-n>M-p/M-n</a></li><li><a href=#c-p-c-n>C-p/C-n</a></li><li><a href=#c-c-m-r-c-c-m-s>C-c M-r /C-c M-s</a></li></ul></li><li><a href=#history-interaction>History Interaction</a><ul><li><a href=#ef9fcd>!!</a></li><li><a href=#ls>!ls</a></li><li><a href=#ls>!?ls</a></li><li><a href=#ls-n>!ls:n</a></li><li><a href=#ls-tab>!ls&lt;tab></a></li><li><a href=#old-new>^old^new</a></li><li><a href=#792e5b>$_</a></li></ul></li><li><a href=#commandline-interaction>Commandline Interaction</a></li><li><a href=#the-eshell-prompt>The Eshell Prompt</a></li><li><a href=#the-commandline>The Commandline</a></li><li><a href=#useful-keybindings>Useful Keybindings</a><ul><li><a href=#c-c-m-b>C-c M-b</a></li><li><a href=#c-c-m-i>C-c M-i</a></li><li><a href=#c-c-m-v>C-c M-v</a></li><li><a href=#c-c-m-d>C-c M-d</a></li></ul></li><li><a href=#argument-predicates>Argument Predicates</a><ul><li><a href=#syntax-reference>Syntax Reference</a></li><li><a href=#globbing>Globbing</a></li><li><a href=#elisp-lists>Elisp Lists</a></li><li><a href=#adding-new-modifiers-and-predicates>Adding New Modifiers and Predicates</a></li></ul></li><li><a href=#plan-9-smart-shell>Plan 9 Smart Shell</a></li><li><a href=#redirection>Redirection</a></li><li><a href=#to-emacs>To Emacs</a></li><li><a href=#to-pseudo-devices>To Pseudo-Devices</a><ul><li><a href=#dev-eshell>/dev/eshell</a></li><li><a href=#dev-null>/dev/null</a></li><li><a href=#dev-clip>/dev/clip</a></li><li><a href=#dev-kill>/dev/kill</a></li><li><a href=#to-custom-virtual-target>To custom virtual target</a></li></ul></li><li><a href=#tramp>TRAMP</a></li><li><a href=#startup-scripts>Startup Scripts</a></li><li><a href=#more-customization>More Customization</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>Emacs 支持若干种shell,但是就功能丰富度，以及与Emacs 的集成程度而言，
无一能望Eshell项背。</p><p>Eshell 是一个完全由Emacs Lisp 编写的shell,但是不要以为这样Eshell在功能上就会先天不足，它能代替绝大部分GNU核心功能集和Bourne shell家族的命令以及相关特性。</p><p>此外，通过用Emacs Lisp 重写了类似 <code>ls</code> 和 <code>cp</code> 等常用命令，使Eshell 可以成为真正的跨平台Shell.</p><p>但是，Eshell 有一个很大的不足，那就是Eshell 严重缺乏文档与之形成鲜明对比的是，Emacs 及其生态都拥有丰富的文档</p><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>与Emacs 中的其他shell 不一样的是，Eshell 不是继承默认与的子进程进行交互的 <code>comint-mode</code>
因为Eshell 不是一个子进程，所以它就没有必要使用 <code>comint-mode</code> 了；不过似乎这是件
好事，因为这意味着 <code>comint-mode</code> 的例程和钩子是不会作用于Eshell 的。</p><p>此外，几乎所有 <code>comint-mode</code> 的常用命令，都在Eshell 中重新实现了，并且使用相同的按键绑定.</p><p>当然，也有为数不多的按键绑定没有迁移到Eshell,例如在Eshll 中搜索历史命令的=comint-history-isearch-backward-regexp= 是绑定到了 <code>M-r</code>,
而原来shell中相同功能的命令的按键就是 <code>C-r</code> Eshell 可以在所有的平台都正常工作.</p><p>其实和Eshell 真正进行交互的是一个通用的中间件(即 Emacs Lisp/C 的一个库),而该中间件又会跟你的操作系统进行通信，处理例如复制文件 等相关操作。</p><p>此外，这个中间件甚至支持在Eshell 中使用 <code>Tramp</code> 的特性, 由于Emacs 是血统纯正的Unix 产物，Eshell 是可以重现例如bash 等传统Unix shell 以及 其他GNU 工具链的同样功能的。</p><p>此外，如果你使用的是Windows,你应该感到庆幸，因为你再也不用折腾 <code>cygwin</code> ,也不需要为跨平台移植Emacs 而担忧依赖问题。</p><p>事实上，对比=cygwin= 的bash,在很多方面，Eshell 对Windows 的支持是做得更好滴。</p><p>例如，你不再需要 <code>/cygdrive/c</code> 来扩展相应的功能，因为Eshell 自身就支持Windows/MS-DOS 的路径
(所以 <code>cd D:</code> 或者 <code>D:</code> 同样都可以进入D 盘)</p><p>虽然Eshell 有很多好处，但是我还是要列出那些让人们很困惑的观点(或者说是误解):</p><ul><li>Eshell 不是一个终端模拟器，它不是跟shell 进行通信，事实上，它就是一个shell. 它做的所有工作，无论是在屏幕展示数据，还是获取目录里面的信息，它都是通过Emacs 实现的，然后Emacs会再跟你的操作系统进行通信</li><li>由于Eshell 跟其他进程通信的方式 (特别是异步通信),所以可能导致它的缓冲区(Buffers) 和其他中断操作出现问题</li><li>Eshell 无法直接支持交互命令 (按照Eshell 的说法，叫做“可视化命令”),例如top ,所以你一定要告诉Eshll应在单独的 <code>ansi-term</code> 实例运行此类命令</li><li>它不是 <code>bash</code> 或者 <code>zsh</code>,更不是 <code>csh</code>,所以不要像操作它们那样操作Eshell 即使Eshell 跟它们真的很像。因此，如果你想更加高效地使用Eshell,你最好把它当作一个不一样的shell</li></ul><h2 id=commands>Commands<a hidden class=anchor aria-hidden=true href=#commands>#</a></h2><p>Eshell 是可以调用几乎所有的已加载的elisp 函数的；这种灵活性是其它shell 无法想象的也是它们力所不能及的。</p><p>事实上，这种在shell 里面跟elisp 函数结合的玩法理应得到更多人的支持和推崇，因为它真的很酷(当然也很有用).假如你想在Emacs 里面打开 <code>foobar.txt</code> ,你只需调用 <code>find-file foobar.txt</code>,Eshell 就会调用对应的 <code>(find-file "foobar.txt")</code> ,并为你打开文件</p><h2 id=technical-details>Technical Details<a hidden class=anchor aria-hidden=true href=#technical-details>#</a></h2><p>所有被Eshell 执行的命令都有一个执行的顺序，这是必需传递给Emacs 的有序列表，
因为这个列表决定了Eshell 的哪一部分应该处理该命令的。</p><p>如果该列表中没有找到可以执行你的操作的函数或者对应命令，你会被告知，你输入的是无效命令</p><p>假设 你想调用 <code>cp</code> 命令，调用顺序如下：</p><ol><li>完整的路径 (即 <code>/bin/cp</code>),在 <code>/bin</code> 目录下执行 <code>cp</code></li><li>寻找命令的前缀， <em>eshell-explict-command-char</em> (默认值是 &ldquo;=&rdquo;),如果有前缀的话,那么，在搜索路径寻找对应的命令</li><li>寻找shell 命令的别名 (<code>alias</code> 命令)</li><li>在搜索路径寻找 <code>cp</code> ,即 <code>$PATH</code> (或者 <code>eshell-path-env</code>) 定义的路径</li><li>寻找叫做 <code>cp</code> 的Lisp 函数 或者 叫 <code>eshell/cp</code> 的elisp 函数</li></ol><p>变量 <code>eshell-prefer-lisp-functions</code> 让内部的elisp 函数调用要先于外部调用，这意味着，当该变量值为 <code>t</code> 的时候，Eshell 会 <code>最先</code> 调用elisp 函数，而不是 =最后=才调用；</p><p>但是，当命令前缀(即 <em>eshll-explicit-command-char</em>)被指定，该变量会被忽略</p><h2 id=built-in-commands>Built-in Commands<a hidden class=anchor aria-hidden=true href=#built-in-commands>#</a></h2><p>Eshell 有很多很好用的通过Emacs-Lisp 重写的命令，这些命令实现了绝大部分GNU 核心工具集
或者你所钟爱的shell 的特性，所以这些命令被称为"Alias functions"(别名函数).</p><p>但是Eshell 并不是全盘模拟其他Shell 的功能特性，如果你传递了一些参数，试图调用Eshell未实现的功能时，Eshell 会自动调用外部的对应的命令来实现你想要的功能 (当然前提是你已经安装该命令)
下面列出Eshell 已经重新实现的命令：
<code>cat</code> , <code>cp</code> , <code>ls</code> , <code>cd</code> , <code>export</code> , <code>dirs</code> , <code>du</code> , <code>echo</code> , <code>env</code> , <code>kill</code>
<code>ln</code> , <code>mkdir</code> , <code>mv</code> , <code>alias</code> , <code>popd</code> , <code>pushd</code> , <code>pwd</code> , <code>rm</code> , <code>rmdir</code>
<code>time</code> , <code>umask</code>.
Eshell 注重跟原有的GNU工具功能同步，所以你不用担心因Eshell 命令跟其他原生Shell 命令不一致而导致的问题</p><h2 id=command-interception>Command Interception<a hidden class=anchor aria-hidden=true href=#command-interception>#</a></h2><p>Eshell 有一个很cool 的特性，那就是某些命令会被拦截并且传递给Emacs.</p><p>这种机制允许你调用一个命令例如 <code>man ls</code>,但是真正调用处理的是Emacs 内置的 <code>man</code>.</p><p>此外，对于之前提及的交互式命令而言，这种特性是很重要的，因为Eshell 是没有能力处理该命令的。</p><p>但真正展现该特性威力的还是那么复杂的命令，例如 <code>grep</code> <code>diff</code>,因为Emacs 本身就内置了更加强大的 <em>grep</em> 和 <em>diff</em> 工具。</p><p>这种特性真真实实展示了Eshell 对比其他shell 的强大之处</p><p>下列的命令都会被重定向到Emacs内置的功能去：
<code>agrep</code> , <code>diff</code> , <code>egrep</code> , <code>fgrep</code> , <code>glimpse</code> , <code>grep</code> , <code>info</code> , <code>jobs</code>
<code>locate</code> , <code>man</code> , <code>occur</code> , <code>su</code> , <code>sudo</code> , <code>whoami</code>
<code>su</code> <code>sudo</code> <code>whoami</code> 是与 <code>TRAMP</code> 相关的命令，所以如果你是连接到远程shell 的
这些命令也是可以正常工作的</p><h2 id=subshells>Subshells<a hidden class=anchor aria-hidden=true href=#subshells>#</a></h2><p>你可以使用 <code>$()</code> 来调用命令，并且把命令对应的输出当作接下来命令的参数，就好像你在bash 那样使用。</p><p>但是你要谨记的一样事情就是你是无法使用反引号 =``=来生成一个subshell的。</p><p>虽然你也可以使用像调用subshell 的语法来调用标准的elisp form: <code>(form ....)</code> 注意没有了 <code>$</code>,不过我并不推荐这种用法，因为很多情况，这种用法都是不行的</p><h2 id=useful-elisp-commands>Useful Elisp Commands<a hidden class=anchor aria-hidden=true href=#useful-elisp-commands>#</a></h2><p>Eshell 有一套可以让你每天的生活变得更美好的帮助函数(helper function), 此外你可以在Eshell调用几乎所有的elisp 函数，这就意味着，你拥有无上的能力来控制你的shell.</p><p>接下来，我会列举那些为Eshell 专门编写的命令和一些我觉得很有用的命令。</p><p>我也编写了挺多的elisp 函数了 (部分是专门写给Eshell,其他的就不是了)</p><h3 id=listify-args>listify ARGS<a hidden class=anchor aria-hidden=true href=#listify-args>#</a></h3><p>将字符串参数解析成 elisp 列表符号，然后打印到屏幕。</p><p>该函数不仅可以解析 POSIX 类型的参数，也可以解析 MS-DOS/Windows 类型参数</p><h3 id=addpath-path>addpath PATH<a hidden class=anchor aria-hidden=true href=#addpath-path>#</a></h3><p>将参数 (必须是文件路径) 添加到环境变量 <code>$PATH</code>,如果没有参数被指定的话，那么将原有的变量值输出到屏幕</p><h3 id=unset-env-var>unset ENV-VAR<a hidden class=anchor aria-hidden=true href=#unset-env-var>#</a></h3><p>移除已有的环境变量</p><h3 id=find-file-file>find-file FILE<a hidden class=anchor aria-hidden=true href=#find-file-file>#</a></h3><p>搜索文件FILE,然后在Emacs 中打开该文件。这个函数与 <code>TRAMP</code> 相关，所以也可以远程工作</p><h3 id=dired-directory>dired DIRECTORY<a hidden class=anchor aria-hidden=true href=#dired-directory>#</a></h3><p>在目录 <code>DIRECTORY</code> 下打开一个 dired 缓冲区</p><h3 id=calc-eval-expr>calc-eval EXPR<a hidden class=anchor aria-hidden=true href=#calc-eval-expr>#</a></h3><p>在Emacs calculator 执行该表达式 <code>EXPR</code></p><h3 id=upcase-str-downcase-str>upcase STR /downcase STR<a hidden class=anchor aria-hidden=true href=#upcase-str-downcase-str>#</a></h3><p>字符串 STR 大小写转换</p><h3 id=vc-dir-directory>vc-dir DIRECTORY<a hidden class=anchor aria-hidden=true href=#vc-dir-directory>#</a></h3><p>展示在版本控制下的目录 <code>DIRECTORY</code> 的状态，跟大多数版本控制工具的 <code>status</code> 命令相同</p><h3 id=ediff-files-file1-file2>ediff-files FILE1 FILE2<a hidden class=anchor aria-hidden=true href=#ediff-files-file1-file2>#</a></h3><p>使用Emacs 的比较引擎 (diff engine) ediff,对文件 <code>FILE1</code> <code>FILE2</code> 进行比较</p><h2 id=aliasing>Aliasing<a hidden class=anchor aria-hidden=true href=#aliasing>#</a></h2><p>你可以像在其它主流的shell 那样给Eshell命令赋予别名，操作是一样滴，此外，你甚至可以混合使用elisp 函数和Eshell 命令。</p><p><code>alias</code> 命令的格式是 <code>alias alias-name definition</code> <code>definition</code> 必须由一对单引号 <code>''</code> 包围。</p><p>你也可以使用其它shell 的参数引用形式：</p><p>例如 <code>$1</code> 指第一个参数， <code>$2</code> 指第二个参数，依此类推，或者 <code>$=</code> 指所有的参数。
当参数没有在 <code>definition</code> 被引用，Eshell 会自动把参数添加到命令的末尾，并把参数忽略</p><p>如果想移除一条命令的别名，只需不对变量 <code>definition</code> 赋值 (即 <code>alias alias-name</code>) 别名就会被自动移除，如果想列出所有的别名，只需输入 <code>alias</code></p><p>Eshell 会把命令的别名及其定义写入到变量 <code>eshell-aliases-file</code> 然后统一被变量 <code>Eshell-directory-name</code> 管理；然后别名默认会被统一写入到 <code>~/.Eshell/alias</code>.</p><p>每次你更改一个命令别名，都会重复上面的流程, 另外一个很有用的特性就是别名自动修正 (<em>auto-correcting aliasing</em>),
如果你输入 一个无效的命令太多次 (变量 <code>eshll-bad-command-tolerance</code> 表示触发自动更正的最低 次数，默认值为3),Eshell会为你真正想执行的命令提供别名.</p><p>例如你想输入的是 <code>cp</code> 但是输入了太多次的 <code>co</code>,所以下次你输入 <code>co</code> 的时候，Eshell 就会自动执行 <code>cp</code>.</p><p>当然，如果你不喜欢这种特性的话，你可以把最低次数设得很大</p><h3 id=useful-examples>Useful Examples<a hidden class=anchor aria-hidden=true href=#useful-examples>#</a></h3><p>让我们把长长的 <code>find-file</code> 命令映射到更顺手的别名 <code>ff</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>alias</span> ff <span class=s1>&#39;find-file $1&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>把 <code>dired</code> 映射到 <code>d</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>alias</span> d <span class=s1>&#39;dired $1&#39;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=visual-commands>Visual Commands<a hidden class=anchor aria-hidden=true href=#visual-commands>#</a></h2><p>有一些对Eshell 而言是太复杂的命令，Eshell 是无法直接显示的，所以需要特殊的处理</p><p>例如 <code>top</code> ,是无法与一些哑终端(dumb terminal)一起正常工作的。</p><p>为了使这些命令正常工作，Eshell 会运行一个终端模拟器 <code>term</code> 来执行这些的命令 (即被称为可视化的命令)</p><p>如果你想修改可视化命令的列表，你可以修改变量 <code>eshell-visual-commands</code></p><h2 id=command-history>Command History<a hidden class=anchor aria-hidden=true href=#command-history>#</a></h2><p>Eshell 有功能丰富的命令行历史机制，但是因为Eshell 不是继承 <code>comint-mode</code> 的</p><p>所以 <code>comint-mode</code> 与历史相关的功能，Eshell 是没法用的，不过它绝大部份的功能都已经在Eshell 重新实现了</p><h3 id=m-r-m-s>M-r /M-s<a hidden class=anchor aria-hidden=true href=#m-r-m-s>#</a></h3><p>向前或者向后搜索命令，支持正则表达式</p><h3 id=m-p-m-n>M-p/M-n<a hidden class=anchor aria-hidden=true href=#m-p-m-n>#</a></h3><p>在历史命令列表中前进或者后退</p><h3 id=c-p-c-n>C-p/C-n<a hidden class=anchor aria-hidden=true href=#c-p-c-n>#</a></h3><p>Eshell上一条命令或者下一条命令</p><h3 id=c-c-m-r-c-c-m-s>C-c M-r /C-c M-s<a hidden class=anchor aria-hidden=true href=#c-c-m-r-c-c-m-s>#</a></h3><p>回到上一条/下一条历史命令，历史命令必须与现在的命令输入一致。</p><p>例如现在的输入是：
<code>ls</code> ,那么回到的上一条 /下一条历史命令必须是 <code>ls</code>,或者以 <code>ls</code> 开头的命令，如 <code>lsmod</code></p><p>不足的是，新的经过修改的命令 <code>comint-history-isearch-backward-regexp</code> (在 <code>comint</code> 键绑定是 <code>M-r</code>)在Eshll 是无法使用的，因为Eshell 不是继承于 <code>comint</code> (所以在升级中被忽略了)</p><h2 id=history-interaction>History Interaction<a hidden class=anchor aria-hidden=true href=#history-interaction>#</a></h2><p>像bash 和其它shell 那样，Eshell 也支持历史的修改和交互。</p><p>如果想要知道历史交互是怎么操作的，你就需要回去翻一下 bash 的手册了。接下来我会总结一下Eshell 大部份的历史交互用法</p><h3 id=ef9fcd>!!<a hidden class=anchor aria-hidden=true href=#ef9fcd>#</a></h3><p>重复上一条命令</p><h3 id=ls>!ls<a hidden class=anchor aria-hidden=true href=#ls>#</a></h3><p>重复上一条以 <code>ls</code> 开头的命令</p><h3 id=ls>!?ls<a hidden class=anchor aria-hidden=true href=#ls>#</a></h3><p>重复上一条包含 <code>ls</code> 的命令</p><h3 id=ls-n>!ls:n<a hidden class=anchor aria-hidden=true href=#ls-n>#</a></h3><p>从上一条以 <code>ls</code> 开头的命令截取第n个参数</p><h3 id=ls-tab>!ls&lt;tab><a hidden class=anchor aria-hidden=true href=#ls-tab>#</a></h3><p>使用命令补全，显示补全结果中包含 <code>ls</code> 的命令</p><h3 id=old-new>^old^new<a hidden class=anchor aria-hidden=true href=#old-new>#</a></h3><p>快速替换，对于上一条命令，使用 <code>old</code> 来代替命令中的 <code>new</code> (备注：似乎有Bug)</p><h3 id=792e5b>$_<a hidden class=anchor aria-hidden=true href=#792e5b>#</a></h3><p>返回上一条执行的命令的最后一个参数</p><p>Eshll 也支持bash 历史修改(例如 !!:s/old/new/),如果你想了解更多的信息，
<a href=https://www.gnu.org/software/bash/manual/bash.html#History-Interaction>the bash reference on history interaction</a> 可以告诉你你想知道的东西</p><h2 id=commandline-interaction>Commandline Interaction<a hidden class=anchor aria-hidden=true href=#commandline-interaction>#</a></h2><h2 id=the-eshell-prompt>The Eshell Prompt<a hidden class=anchor aria-hidden=true href=#the-eshell-prompt>#</a></h2><p>你可以通过修改变量 <code>eshell-prompt-function</code> 来自定义Eshell 的提示符；该变量
有一个函数定义了Eshell 命令行提示符应该包含的内容。</p><p>通过用elisp 来管理Eshell 命令行提示符的配置，你就可以实现你想要的任何特性。</p><p>你需要注意的事情就是：你需要告诉Eshell,命令行提示符长什么样子，所以你必须修改变量 <code>eshell-prompt-regexp</code>
,那样 Eshell 就会知道你想要的提示符长什么样子了</p><h2 id=the-commandline>The Commandline<a hidden class=anchor aria-hidden=true href=#the-commandline>#</a></h2><p>Eshell 可以使用反斜杠 <code>\</code> 来转义新行，以及基本的多行输入。</p><p>另外一个输入多行的文学字符串 (literal string)的方法就是使用单引号：输入一个单引号，然后回车，
接着你就可以输入你想输入的内容，最后用另外一个单引号结束输入。</p><p>如果你使用双引号的话，Eshell 会自动展开 subshell 命令并且展开相应的变量得益于Eshell 的调用机制，你甚至可以回去继续修改引号里面的文本。</p><p>当你想回去修改你不喜欢的内容，让Eshell像你预期那样工作的时候，你就会觉得这种特性真的相当
有用</p><h2 id=useful-keybindings>Useful Keybindings<a hidden class=anchor aria-hidden=true href=#useful-keybindings>#</a></h2><p>Eshell 做了很多与Eamcs 进行交互的功能的改进，而且，这些改进足以影响你的生活
质量，让我为你一一道来：</p><h3 id=c-c-m-b>C-c M-b<a hidden class=anchor aria-hidden=true href=#c-c-m-b>#</a></h3><p>将已经某个缓冲区的名字插入到当前光标</p><h3 id=c-c-m-i>C-c M-i<a hidden class=anchor aria-hidden=true href=#c-c-m-i>#</a></h3><p>将已经某个进程的名字插入到当前光标</p><h3 id=c-c-m-v>C-c M-v<a hidden class=anchor aria-hidden=true href=#c-c-m-v>#</a></h3><p>将一个环境变量的名字插入到当前光标</p><h3 id=c-c-m-d>C-c M-d<a hidden class=anchor aria-hidden=true href=#c-c-m-d>#</a></h3><p>在直接输入和延迟输入(回车确认)之间切换 (对不能与来源于其他缓冲区的输入正常工作
的命令来说就很有用了)</p><h2 id=argument-predicates>Argument Predicates<a hidden class=anchor aria-hidden=true href=#argument-predicates>#</a></h2><p>参数谓词是一个很擅长过滤文件，甚至elisp列表的工具。</p><p>Eshell的谓词语法是参照zsh 的，所以如果你熟悉zsh的参数谓词，你也可以以同样的方式来使用Eshell.</p><p>与Eshell 绝大部分迥异的是，参数谓词是有详细的文档的。你可以通过输入 <code>eshell-display-predicate-help</code></p><p>或者 <code>eshell-display-modifier-help</code> 来查看帮助文档参数谓词用来过滤有相同模式的文件是很有用，你不需再花费额外的时间来使用诸如 <code>find</code> <code>ls</code> 此类命令。</p><p>虽然有帮助手册，但是手册还是很简单，不尽人意，所以我自己总结了一些用法来帮助读者了解相关特性。</p><p>但是最好的学习方法还是多尝试，多出错，多总结</p><h3 id=syntax-reference>Syntax Reference<a hidden class=anchor aria-hidden=true href=#syntax-reference>#</a></h3><p>我就不把那么多的谓词和修饰符一一列出来了，因为Eshell 的手册已经作了很详细的解释了，你需要做的就是自己查看</p><h3 id=globbing>Globbing<a hidden class=anchor aria-hidden=true href=#globbing>#</a></h3><p>Eshell 的匹配模式和其他常用shell 的是基本一致滴：shell 会扩展文件和路径的匹配 模式，然后将匹配后的列表当作参数传递给相应的命令，例如 <code>ls</code>.</p><p>这就是为什么你一起使用 <code>find</code> 和 <code>xargs</code> 命令的时候，最好要把 <code>-print0</code> 传递给 <code>find</code> 并且把 <code>-0</code>
传递给 <code>xargs</code>.</p><p>因为如果你不这样做的话，文件名或者路径名中的特殊字符或者空格就会 让 <code>xargs</code> 不知道如何正确地处理。通过使用 <code>NUL</code> 字符作为分隔符，保证字符可以被正确地标记，并且文件中紧跟着 <code>/</code> 的 <code>NUL</code> 字符会被标记为无效字符</p><h3 id=elisp-lists>Elisp Lists<a hidden class=anchor aria-hidden=true href=#elisp-lists>#</a></h3><p>如果你把Eshell 的列表理解成输出的 <code>form</code> 的elisp列表，你会发现理解起来变得容易因为事实上Eshell 是可以通过Elisp 来处理列表的，而处理列表恰恰是Lisp 擅长的东西最简单的模式扩展就是 <code>echo *</code>,该命令会把当前文件夹下所有匹配的文件以列表的形式 打印出来。</p><p>因为，正如我先前提及的那样，通配符扩展是同步一致进行的，所以我可以在 在使用 <code>*</code> 的同时再使用另外一个修饰符。</p><p>例如: 我们把当前文件夹下的所有文件名变成大写的形式，并以列表的形式打印出来：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ $ <span class=nb>echo</span> *<span class=o>(</span>:U<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s2>&#34;BAR&#34;</span> <span class=s2>&#34;BIN/&#34;</span> <span class=s2>&#34;DEV/&#34;</span> <span class=s2>&#34;ETC/&#34;</span> <span class=s2>&#34;FOO&#34;</span> <span class=s2>&#34;HOME/&#34;</span> <span class=s2>&#34;LIB/&#34;</span> <span class=s2>&#34;TMP/&#34;</span> <span class=s2>&#34;USR/&#34;</span> <span class=s2>&#34;VAR/&#34;</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>请注意，我是怎样在使用模式扩展的同时使用 <code>()</code>.这对括号可以让你使用参数修饰符或者 是谓词。</p><p>修饰符是可以修饰你的结果列表的(很惊讶吧).</p><p>修饰符总是以冒号 <code>:</code> 开头滴， 而谓词却不一样。</p><p>我会展示另外一个例子，这次这个例子我会使用谓词来过滤目录：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ $ <span class=nb>echo</span> *<span class=o>(</span>^/<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s2>&#34;bar&#34;</span> <span class=s2>&#34;foo&#34;</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这个 <code>^</code> 在上面的命令的作用，是跟在正则表达式中一样，用作取反，而斜杠的作用 <code>/</code>
是只代表目录，所以上面的作用就是打印所有文件</p><p>对于修饰符和谓词，我也可以不使用模式扩展</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ $ <span class=nb>echo</span> <span class=o>(</span><span class=s2>&#34;foo&#34;</span> <span class=s2>&#34;bar&#34;</span> <span class=s2>&#34;baz&#34;</span> <span class=s2>&#34;foo&#34;</span><span class=o>)(</span>:gs/foo/blarg<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s2>&#34;blarg&#34;</span> <span class=s2>&#34;bar&#34;</span> <span class=s2>&#34;baz&#34;</span> <span class=s2>&#34;blarg&#34;</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这次我是把所有的 <code>foo</code> 代替为 <code>blarg</code>.</p><p>你可以发现语法是相同的，只是这次我不是使用模式匹配来获取文件列表，而是直接输入文件的列表.</p><p>使用参数谓词和修饰符的好处是你大大减少了输入的命令行数量，因为用谓词可以处理权限 ，属主，文件属性，甚至更多方面的问题</p><h3 id=adding-new-modifiers-and-predicates>Adding New Modifiers and Predicates<a hidden class=anchor aria-hidden=true href=#adding-new-modifiers-and-predicates>#</a></h3><p>你也可以添加自己的谓词 (<code>eshell-predicate-alist</code>)或者修饰符 (<code>eshell-modifier-alist</code>):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl><span class=p>(</span><span class=nv>add-to-list</span> <span class=ss>&#39;eshell-modifier-alist</span> <span class=o>&#39;</span><span class=p>(</span><span class=sc>?X</span> <span class=o>.</span> <span class=o>&#39;</span><span class=p>(</span><span class=nb>lambda</span><span class=p>(</span><span class=nv>lst</span><span class=p>)(</span><span class=nf>mapcar</span> <span class=ss>&#39;rot13</span> <span class=nv>lst</span><span class=p>))))</span>
</span></span></code></pre></td></tr></table></div></div><p>我已经将 <code>rot13</code> 绑定到 <code>X</code> 了，替换结果如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ $ <span class=nb>echo</span> <span class=o>(</span><span class=s2>&#34;foo&#34;</span> <span class=s2>&#34;bar&#34;</span> <span class=s2>&#34;baz&#34;</span><span class=o>)(</span>:X<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=s2>&#34;sbb&#34;</span> <span class=s2>&#34;one&#34;</span> <span class=s2>&#34;onm&#34;</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=plan-9-smart-shell>Plan 9 Smart Shell<a hidden class=anchor aria-hidden=true href=#plan-9-smart-shell>#</a></h2><p>Eshell 有一个 <code>Plan 9</code> 终端的弱化版，叫做 <strong>the Eshell smart display</strong>.</p><p>Eshell 的智能展示(smart display)意味着它改进了所有黑客所习惯的 <strong>输入－运行－修改</strong> 工作流程。</p><p>智能展示特别之处在于，Eshell 的光标不会像普通的shell那样，落在你运行
的命令的输出后面；</p><p>相反，光标的位置会保持在你输入命令的位置，让你可以通过 <code>M-p</code> <code>M-n</code> 或者其他修改历史的命令更容易地修改你输入的命令.</p><p>如果你启用了 <code>smart display</code> 模式，你还可以使用 <code>SPC</code> 向下翻页，或者使用 <code>BACKSPACE</code>
向上翻页来查看那些长时间运行的命令的输出。</p><p>如果你按下了任何其它的按键，光标会直接跳到你缓冲区的结尾，就好像你没有启用 <code>smart display</code> 运行命令时那样</p><p>值得注意的是，如果Eshell 检测到你想回顾最后一条执行的命令时，Eshell 会很贴心地帮你回顾的，但是，如果你没有这样的行为，Eshell 的光标会直接跳转到缓冲区的结尾.</p><p>这么看来，Eshell真的很智能，而且它也有一些设置可以让你微调相关的行为。</p><p>你会发现智能显示 (smart display)真的非常有用，特别是你可以通过移动按键就能修改</p><p>刚刚执行过的命令；例如修改拼写错误的命令或者是给相应的命令添加参数, 智能显示还可以被设置成当命令成功执行时，不使用扩展的 <code>edit mode</code>;并且隐藏命令输出, 就好像你执行 <code>chown</code> 那样。</p><p>这也是我喜欢的玩法，如果你也想试试这种玩法，你可以把下面的elisp 代码添加到你的 <code>.emacs</code> 文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-emacs-lisp data-lang=emacs-lisp><span class=line><span class=cl><span class=p>(</span><span class=nb>require</span> <span class=ss>&#39;eshell</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>require</span> <span class=ss>&#39;em-smart</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>setq</span> <span class=nv>eshell-where-to-jump</span> <span class=ss>&#39;begin</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>setq</span> <span class=nv>eshell-review-quick-commands</span> <span class=no>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nb>setq</span> <span class=nv>eshell-smart-space-goes-to-end</span> <span class=no>t</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>如果Eshell 已经被初始化(即你已经在Emacs运行了一个Eshell实例),那样的话，运行
上面的代码是不会起作用的。</p><p>你必须在Eshell 里面按下 <code>M-:</code> 然后输入 <code>(shell-smart-initialize)</code> ,或者直接重启Emacs
智能显示真的是非常有用的特性，但是你一时半刻是很难完全领会其全部的精妙之处滴。</p><p>你直接输入一个命令，Eshell的光标就会跳转到缓冲区的结尾，所以你会觉得光标似乎本来就在那里</p><h2 id=redirection>Redirection<a hidden class=anchor aria-hidden=true href=#redirection>#</a></h2><p>Eshell 的重定向跟其它shell 的工作方式基本是一样的，但是，有一项非常重要的差异就是Eshell 必须模拟可能不存在的伪设备，例如Windows 平台上的 <code>/dev/null</code> 其实是 <code>NUL</code></p><p>另外一个值得注意的地方就是：虽然Eshell 支持重定向，但是只是支持输出重定向，是 不支持输入重定向的。</p><p>为了避免跳进输入重定向这个坑，你最好使用管道。</p><p>重定向到标准输入 标准输出，标准错误都是可以正常工作的，此外，你也可以重定向到多个目标，很不错的特性吧</p><h2 id=to-emacs>To Emacs<a hidden class=anchor aria-hidden=true href=#to-emacs>#</a></h2><p>因为Eshell 在内部用Elisp重新实现了各种伪设备，所以也就无需跟Unix 的设备文件打交道了，甚至，可以用Elisp实现自己的伪设备。</p><p>一个很好的例子就是，你可以把重定向到一个你选择的缓冲区，用下面的命令就能实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ $ cat mylog.log &gt;&gt; <span class=c1>#&lt;buffer *scratch*&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>我之前提到的快捷键 <code>C-c M-b</code> 就是可以把一个选定的缓冲区的名字插入到光标前</p><p>此外，你也可以把输出直接重定向到Elisp 的符号(不过注意，不要执行错误的设置)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ $ <span class=nb>echo</span> foo bar baz &gt; <span class=c1>#&#39;myvar</span>
</span></span><span class=line><span class=cl>/ $ <span class=nb>echo</span> <span class=k>$(</span>cadr myvar<span class=k>)</span>
</span></span><span class=line><span class=cl>bar
</span></span></code></pre></td></tr></table></div></div><p>如果你将变量 <code>eshell-buffer-shorthand</code> 设置为 <code>t</code> 的话。</p><p>你就可以使用缓冲区的速记名, 例如 <code>#'*scratch*'</code>,但是你就不能直接重定向到Elisp 的符号了</p><h2 id=to-pseudo-devices>To Pseudo-Devices<a hidden class=anchor aria-hidden=true href=#to-pseudo-devices>#</a></h2><p>Eshell 重新实现了以下的伪设备：</p><h3 id=dev-eshell>/dev/eshell<a hidden class=anchor aria-hidden=true href=#dev-eshell>#</a></h3><p>以交互的方式，把结果输出到Eshell</p><h3 id=dev-null>/dev/null<a hidden class=anchor aria-hidden=true href=#dev-null>#</a></h3><p>把结果输出到 <code>NULL</code> 设备</p><h3 id=dev-clip>/dev/clip<a hidden class=anchor aria-hidden=true href=#dev-clip>#</a></h3><p>把结果输出到剪切板</p><h3 id=dev-kill>/dev/kill<a hidden class=anchor aria-hidden=true href=#dev-kill>#</a></h3><p>把结果输出到 <code>kill ring</code></p><p>跟通用的shell 一样，使用 <code>></code> 代表覆盖(或者新建);使用 <code>>></code> 代表追加</p><h3 id=to-custom-virtual-target>To custom virtual target<a hidden class=anchor aria-hidden=true href=#to-custom-virtual-target>#</a></h3><p>你通过修改变量 <code>eshell-virtual-targets</code> 创建自己的可视化目标(即存储你想创建的 伪设备的名字的一个列表),以及修改代表重定向行为(即覆盖或追加或插入)的函数 <code>mode</code></p><h2 id=tramp>TRAMP<a hidden class=anchor aria-hidden=true href=#tramp>#</a></h2><p>Eshell 可以很好地支持TRAMP,这意味着如果Eshell 所在的目录是在远程服务器的话， 像 <code>su</code> <code>sudo</code> <code>whoami</code> 这样的命令会自动作用在远程服务器</p><p>想直接使用TRAMP,你可以像使用 <code>C-x C-f</code> 寻找文件那样输入TRAMP的命令符，然后你就可以使用TRAMP 了。</p><p>虽然你会觉得Eshell里面使用TRAMP有点奇怪，但是你的确得到了 一个TRAMP的远程shell,不是么？</p><p>此外，你不应把TRAMP局限在使用远程shell, 你可以在本地 使用 <code>sudo</code> 和 <code>su</code> 命令的</p><p>有关TRAMP 的更详细的用法，我总结在了另外一篇文章，不过如果你迫不及待想了解更多
有关TRAMP的用法，<a href=http://www.gnu.org/software/tramp/>官方手册</a> 是一个很好的选择</p><h2 id=startup-scripts>Startup Scripts<a hidden class=anchor aria-hidden=true href=#startup-scripts>#</a></h2><p>跟其它的shell 一样，Eshell 也支持 <code>login</code> 和 <code>profile</code> 的配置文件。</p><p><code>login</code> 和 <code>profile</code> 配置文件的绝对路径分别保存在变量 <code>eshell-login-script</code> 和 <code>eshell-rc-script</code>
不过默认情况下，上述两个配置文件都保存在 <code>~/.eshell/</code>.</p><p>顺便说一下，Eshell的配置文件也是使用 <code>#</code> 来注释变量和语句的</p><h2 id=more-customization>More Customization<a hidden class=anchor aria-hidden=true href=#more-customization>#</a></h2><p>如果你想折腾的话，Eshell 有成百上千的选项供你选择。</p><p>如果你想配置Eshell 的话，按下 <code>M-x</code> 然后输入 <code>customize-group</code> 回车，然后输入 <code>eshell</code> 回车确认</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>额，我觉得我已经总结了Eshell 的大部份用法了，希望你可以在其中发现乐趣。</p><p>因为与Emacs 的紧密结合，Eshell 有了各种各样突出好用的特性，但是你需要理解的是，Eshell 的诞生不是
为了全盘取代bash 或者其它你喜欢的终端模拟器，它只是希望在Emacs 里面就可以完成我们
日常必需的命令行操作。</p><p>如果你要运行很多交互式的命令，Eshell 就可能不是很有用了 因为为了运行你输入的每一条可视化命令，Eshell 都会在Emacs 里面启动一个新的终端模拟器。</p><p>Eshell 有TRAMP支持，自定义伪设备，袖珍的elisp REPL和很多非常有用的命令，例如对你打开的文件或者目录，调用 <code>find-file</code> 或者 <code>dired</code>.正是这种种有用的特性， 让Eshell 成为我工具箱里面一个非常可靠的工具。</p><p>原文地址 <a href=https://www.masteringemacs.org/article/complete-guide-mastering-eshell>Mastering Eshell</a> ,在下翻译水平有限，如有错误，还望指出</p><div center class=qr-container><img src=/ox-hugo/qrcode_gh_e06d750e626f_1.jpg alt=qrcode_gh_e06d750e626f_1.jpg width=160px height=160px center=t class=qr-container>
公号同步更新，欢迎关注👻</div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ramsayleung.github.io/zh/tags/eshell/>Eshell</a></li><li><a href=https://ramsayleung.github.io/zh/tags/emacs/>Emacs</a></li></ul><nav class=paginav><a class=prev href=https://ramsayleung.github.io/zh/post/2017/merge-sort-improvment/><span class=title>« 上一页</span><br><span>归并排序算法改进</span>
</a><a class=next href=https://ramsayleung.github.io/zh/post/2017/diff/><span class=title>下一页 »</span><br><span>Linux/Unix Shell 二三事之过滤器diff</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on x" href="https://x.com/intent/tweet/?text=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f&amp;hashtags=eshell%2cemacs"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f&amp;title=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell&amp;summary=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell&amp;source=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on reddit" href="https://reddit.com/submit?url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f&title=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on whatsapp" href="https://api.whatsapp.com/send?text=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell%20-%20https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on telegram" href="https://telegram.me/share/url?text=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share (翻译)Mastering Eshell on ycombinator" href="https://news.ycombinator.com/submitlink?t=%28%e7%bf%bb%e8%af%91%29Mastering%20Eshell&u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2017%2fmaster_eshell%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><section><h2>Comments</h2><div id=comments-giscus></div></section><script type=text/javascript>function getCurrentTheme(){return document.documentElement.getAttribute("data-theme")||document.body.classList.contains("dark")?"dark":"light"}function setGiscusTheme(e=!1){const s=e?"dark":"light";var n,t=document.querySelector(".giscus-frame");t&&(n=new URL(t.src),n.searchParams.set("theme",s),t.src=n.toString())}function loadComment(e=!1){const n="zh"=="zh",t=document.getElementById("comments-giscus");if(t!==null&&!t.hasAttribute("data-giscus-loaded")){console.log("Initial giscus load");const s=document.createElement("script");s.setAttribute("src","https://giscus.app/client.js"),s.setAttribute("data-repo","ramsayleung/comment"),s.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkzMDk2NjQ1NDk="),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOEnUbJc4Cltnz"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",e?"dark":"light"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("data-lang",n?"zh-CN":"en"),s.setAttribute("async","true"),t.appendChild(s),t.setAttribute("data-giscus-loaded","true")}}let currentTheme=getCurrentTheme();loadComment(currentTheme==="dark");const themeObserver=new MutationObserver(e=>{e.forEach(e=>{if(e.type==="attributes"&&e.attributeName==="class"){const e=getCurrentTheme();e!==currentTheme&&(currentTheme=e,setGiscusTheme(currentTheme==="dark"))}})});themeObserver.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script></article></main><footer class=footer><span>See this site&rsquo;s source code <a href=https://github.com/ramsayleung/ramsayleung.github.io>here</a>, licensed under GPLv3 ·</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>