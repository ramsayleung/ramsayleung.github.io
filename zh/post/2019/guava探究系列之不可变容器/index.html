<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>guava探究系列之四：不可变容器 | 花生地</title><meta name=keywords content="java,guava"><meta name=description content="1 前言 先此声明, 个人倾向于将Collection翻译成容器, 将Set翻译成集合. 已经许久没有更新Guava研读系列的文章, 今天要介绍的是Gu"><meta name=author content="Ramsay Leung"><link rel=canonical href=https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ramsayleung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ramsayleung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ramsayleung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ramsayleung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ramsayleung.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MG65HQHEL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MG65HQHEL",{anonymize_ip:!1})}</script><meta property="og:title" content="guava探究系列之四：不可变容器"><meta property="og:description" content="1 前言 先此声明, 个人倾向于将Collection翻译成容器, 将Set翻译成集合. 已经许久没有更新Guava研读系列的文章, 今天要介绍的是Gu"><meta property="og:type" content="article"><meta property="og:url" content="https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/"><meta property="og:image" content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-09-05T15:36:00+08:00"><meta property="article:modified_time" content="2022-02-25T19:54:52+08:00"><meta property="og:site_name" content="花生地"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="guava探究系列之四：不可变容器"><meta name=twitter:description content="1 前言 先此声明, 个人倾向于将Collection翻译成容器, 将Set翻译成集合. 已经许久没有更新Guava研读系列的文章, 今天要介绍的是Gu"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"guava探究系列之四：不可变容器","item":"https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"guava探究系列之四：不可变容器","name":"guava探究系列之四：不可变容器","description":"1 前言 先此声明, 个人倾向于将Collection翻译成容器, 将Set翻译成集合. 已经许久没有更新Guava研读系列的文章, 今天要介绍的是Gu","keywords":["java","guava"],"articleBody":"1 前言 先此声明, 个人倾向于将Collection翻译成容器, 将Set翻译成集合.\n已经许久没有更新Guava研读系列的文章, 今天要介绍的是Guava的不可变容器.\n2 关于不可变对象 不可变的对象有许多的优点, 如下:\n线程安全, 可以在多线程之间使用也不用担心有竞争条件的风险 可以放心地用于不被信任的第三方类库 不用考虑支持可变性, 无需额外的空间和时间消耗. 可用作常量使用 使用对象的不可变拷贝是一项良好的编程防御策略, 为此, Guava提供了许多简单易用的, 实现了标准库Collection接口的不可变容器, 当然也包括实现了他们自家Collection接口的不可变容器.\n虽然通过JDK的静态方法Collection.unmodifiableXXX可以使用内置不可变容器, 但是在Guava团队的同学看来, 它们有若干的不足(又到了喜闻乐见的黑JDK的环节):\n笨重; 使用起来很笨重, 不够赏心悦目和优雅. 不安全; 上述静态方法返回的容器只有在没有对象持有原来容器的情况下才是真正不可变的. 例如, 当想要通过可变Map=ids=来生成一个不可变Map的时候,=Collections.unmodifiableMap(ids)=, 如果有多个对象持有ids时, 静态方法返回的对象就不是真正的不可变. 具体的分析可以参考StackOverFlow关于unmodifiableMap和ImmutableMap的讨论 低效; 静态方法生成的不可变容器和可变容器有着同样的性能开销, 包括并发修改, 动态扩容等(对于真正的不可变容器而言, 这些都是不会出现的操作) 综上所述, 如果你不想修改某个容器, 或者你想把某个容器当作不可变常量, 把这个容器变成一个不可变容器是一个很好的手段(使用Guava的不可变容器).\n此外, 在之前的文章中, 我阐述过Guava对于空指针的态度是尽量不要使用空指针, Guava的类库对于空指针都是快速失败的, Guava的不可变容器也是不例外的, 是拒绝接受空指针的.\n3 代码实例 前面详细介绍了不可变容器, 现在是时候来看一下Guava不可变容器的代码例子:\npublic static final ImmutableSet\u003cString\u003e COLOR_NAMES = ImmutableSet.of( \"red\", \"orange\", \"purple\"); class Foo { final ImmutableSet\u003cBar\u003e bars; Foo(Set\u003cBar\u003e bars) { this.bars = ImmutableSet.copyOf(bars); // defensive copy! } } 前文提到的, Collections.unmodifiableXXX(mutableXXX), Collections方法不能提供真正的不可变容器, 除非没有对象持有可变对象mutableXXX的引用\n那么Guava的不可变容器又是否是真正的不可变呢? 以ImmutableSet为例, 发现所有可以修改ImmutableSet对象的操作函数, 包括add, remove, addAll, removeAll等函数都被重载, 然后标注成@Deprecated, 重载函数的内容就是抛出UnsupportedOperationException异常, 所以不可能修改ImmutableSet对象的内容:\n/** * Guaranteed to throw an exception and leave the collection unmodified. * * @throws UnsupportedOperationException always * @deprecated Unsupported operation. */ @Deprecated @Override public final boolean add(E e) { throw new UnsupportedOperationException(); } 至于持有mutableXXX对象引用, 修改mutableXXX对象内容导致不可变内容发生改变的情况也不会发生:\n@Test public void testImmutable() { Set\u003cString\u003e colors = Sets.newHashSet(); colors.add(\"blue\"); Set\u003cString\u003e modifiableSet = Collections.unmodifiableSet(colors); Set\u003cString\u003e unmodifiableSet = Collections.unmodifiableSet(new HashSet\u003c\u003e(colors)); final ImmutableSet\u003cString\u003e COLOR_NAMES = ImmutableSet.copyOf(colors); colors.add(\"yellow\"); // 不会修改不可变集合的值 Assert.assertFalse(COLOR_NAMES.contains(\"yellow\")); // 修改引用导致集合值发生修改 Assert.assertTrue(modifiableSet.contains(\"yellow\")); // 因为没有对象持有new HashSet\u003c\u003e(colors)的引用, 所以unmodifiableSet是不可变集合, 不能修改 Assert.assertFalse(unmodifiableSet.contains(\"yellow\")); Assert.assertTrue(colors.contains(\"yellow\")); } 查看ImmutableSet.copyOf(Set)函数的源码, 发现不可变集合的实现逻辑和在构造函数新建对象实现对象引用拷贝的逻辑一致, 即和Collections.unmodifiableSet(new HashSet\u003c\u003e(colors))的逻辑一样的:\npublic static \u003cE\u003e ImmutableSet\u003cE\u003e copyOf(Collection\u003c? extends E\u003e elements) { /* * TODO(lowasser): consider checking for ImmutableAsList here * TODO(lowasser): consider checking for Multiset here */ if (elements instanceof ImmutableSet \u0026\u0026 !(elements instanceof ImmutableSortedSet)) { @SuppressWarnings(\"unchecked\") // all supported methods are covariant // 新建对象, 拷贝对象引用 ImmutableSet\u003cE\u003e set = (ImmutableSet\u003cE\u003e) elements; if (!set.isPartialView()) { return set; } } else if (elements instanceof EnumSet) { return copyOfEnumSet((EnumSet) elements); } Object[] array = elements.toArray(); return construct(array.length, array); } 4 具体细节 下面我们来讨论一下各种不可变容器的具体使用细节.\n4.1 构造不可变容器 关于如何构造一个不可变容器, Guava提供的手段是多种多样的:\n使用copyOf静态方法, 例如ImmutableSet.copyOf(set), 这种构造方法与JDK不可变容器的构造方式类似Collections.unmodifiableXXX(mutableXXX) 使用of静态方法, 例如ImmutableSet.of(\"a\", \"b\", \"c\")或者ImmutableMap.of(\"a\", 1, \"b\", 2), 前文已经介绍过, 在此就不赘言 使用Builder构造不可变容器, 例如: public static final ImmutableSet\u003cColor\u003e GOOGLE_COLORS = ImmutableSet.\u003cColor\u003ebuilder() .addAll(WEBSAFE_COLORS) .add(new Color(0, 191, 255)) .build(); 不过某些不可变容器的builder方法废弃了, 如ImmutableSortedSet的builder方法就被替换成了naturalOrder.\n此外, 对于有序容器(sorted collections)而言, 容器内的元素的顺序是按照构造时元素的插入顺序排列的, 例如如下代码\nfinal ImmutableSet\u003cString\u003e alphaTable = ImmutableSet.of(\"a\", \"b\", \"c\", \"a\", \"d\", \"b\"); alphaTable.forEach(System.out::println); // 结果为 a b c d 4.2 asList函数 所有的不可变容器都提供了一个asList方法来返回一个不可变列表ImmutableList, 所以即使你把数据存在一个不可变有序集合ImmutableSortedSet, 你也可以通过下标索引获取最小的元素或者第n小的元素, 如:\nfinal ImmutableSet\u003cInteger\u003e numberSet = ImmutableSortedSet.\u003cInteger\u003enaturalOrder() .add(2, 3, 1) .add(4, 5, 6).build(); numberSet.asList().get(0) # 结果为1 4.3 智能的copyOf函数 前文提到, 不可变容器都提供了一个copyOf方法用于从另外一个容器构造出一个不可变容器. 值得指出的是不可变容器的copyOf方法在不需要拷贝数据的时候就会尽量避免拷贝数据, 但这是什么意思呢? 假如有如下的代码:\nImmutableSet\u003cString\u003e foobar = ImmutableSet.of(\"foo\", \"bar\", \"baz\"); thingamajig(foobar); void thingamajig(Collection\u003cString\u003e collection) { ImmutableList\u003cString\u003e defensiveCopy = ImmutableList.copyOf(collection); ... } 在上面的代码调用ImmutableList.copyOf(foobar)函数的时候, 函数的内部实现不会逐个拷贝, 而会直接通过foobar.asList()函数返回一个不可变值列表, 这样实现的算法时间复杂度就是O(1), 而不是O(n), 实现性能消耗的最小化, 这也就是小标题智能指的意思.\n但是需要注意的是, 并不是所有的不可变容器之间的转换都能实现O(1)时间复杂度, 例如ImmutableSet.copyOf(ImmutableList)就只能逐个元素拷贝, 时间复杂度退化到O(n).\n5 JDK容器与Guava不可变容器 对于JDK提供的标准容器, Guava提供了相应的不可变容器实现, 对于Guava自家的容器, Guava也提供了对应的不可变容器, 具体实现对比如下:\nInterface JDK or Guava? Immutable Version Collection JDK ImmutableCollection List JDK ImmutableList Set JDK ImmutableSet SortedSet=/=NavigableSet JDK ImmutableSortedSet Map JDK ImmutableMap SortedMap JDK ImmutableSortedMap Multiset Guava ImmutableMultiset SortedMultiset Guava ImmutableSortedMultiset Multimap Guava ImmutableMultimap ListMultimap Guava ImmutableListMultimap SetMultimap Guava ImmutableSetMultimap BiMap Guava ImmutableBiMap ClassToInstanceMap Guava ImmutableClassToInstanceMap Table Guava ImmutableTable 6 总结 因为不可变容器不会在运行时改变他们的内部状态, 所以他们是线程安全和无副作用的.\n因为这些属性, 不可变容器在多线程环境就会变得特别有用, 可以安全地传递数据. 总而言之, 生活和工作或许可以多拥抱变化, 对于代码, 最好还是多保持不变地好.\n7 参考 Immutable Collections ","wordCount":"2787","inLanguage":"zh","datePublished":"2019-09-05T15:36:00+08:00","dateModified":"2022-02-25T19:54:52+08:00","author":{"@type":"Person","name":"Ramsay Leung"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/"},"publisher":{"@type":"Organization","name":"花生地","logo":{"@type":"ImageObject","url":"https://ramsayleung.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ramsayleung.github.io/zh/ accesskey=h title="Home (Alt + H)"><img src=https://ramsayleung.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://ramsayleung.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://ramsayleung.github.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://ramsayleung.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://ramsayleung.github.io/zh/categories/ title=目录><span>目录</span></a></li><li><a href=https://ramsayleung.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://ramsayleung.github.io/zh/about_me_zh/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ramsayleung.github.io/zh/>主页</a></div><h1 class=post-title>guava探究系列之四：不可变容器</h1><div class=post-meta><span title='2019-09-05 15:36:00 +0800 +0800'>九月 5, 2019</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;2787 字&nbsp;·&nbsp;Ramsay Leung&nbsp;|&nbsp;<a href=https://github.com/ramsayleung/ramsayleung.github.io/blob/master/content/post/2019/guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前言>1 前言</a></li><li><a href=#关于不可变对象>2 关于不可变对象</a></li><li><a href=#代码实例>3 代码实例</a></li><li><a href=#具体细节>4 具体细节</a><ul><li><a href=#构造不可变容器>4.1 构造不可变容器</a></li><li><a href=#aslist-函数>4.2 <code>asList</code>函数</a></li><li><a href=#智能的-copyof-函数>4.3 智能的<code>copyOf</code>函数</a></li></ul></li><li><a href=#jdk容器与guava不可变容器>5 JDK容器与Guava不可变容器</a></li><li><a href=#总结>6 总结</a></li><li><a href=#参考>7 参考</a></li></ul></nav></div></details></div><div class=post-content><h2 id=前言>1 前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>先此声明, 个人倾向于将<code>Collection</code>翻译成容器, 将<code>Set</code>翻译成集合.</p><p>已经许久没有更新Guava研读系列的文章, 今天要介绍的是Guava的不可变容器.</p><h2 id=关于不可变对象>2 关于不可变对象<a hidden class=anchor aria-hidden=true href=#关于不可变对象>#</a></h2><p>不可变的对象有许多的优点, 如下:</p><ol><li>线程安全, 可以在多线程之间使用也不用担心有竞争条件的风险</li><li>可以放心地用于不被信任的第三方类库</li><li>不用考虑支持可变性, 无需额外的空间和时间消耗.</li><li>可用作常量使用</li></ol><p>使用对象的不可变拷贝是一项良好的编程防御策略, 为此,
Guava提供了许多简单易用的, 实现了标准库<code>Collection</code>接口的不可变容器,
当然也包括实现了他们自家<code>Collection</code>接口的不可变容器.</p><p>虽然通过JDK的静态方法<code>Collection.unmodifiableXXX</code>可以使用内置不可变容器,
但是在Guava团队的同学看来,
它们有若干的不足(又到了喜闻乐见的黑JDK的环节):</p><ol><li>笨重; 使用起来很笨重, 不够赏心悦目和优雅.</li><li>不安全;
上述静态方法返回的容器只有在没有对象持有原来容器的情况下才是真正不可变的.
例如,
当想要通过可变Map=ids=来生成一个不可变Map的时候,=Collections.unmodifiableMap(ids)=,
如果有多个对象持有<code>ids</code>时, 静态方法返回的对象就不是真正的不可变.
具体的分析可以参考<a href=https://stackoverflow.com/questions/22636575/unmodifiablemap-java-collections-vs-immutablemap-google/22636674>StackOverFlow关于unmodifiableMap和ImmutableMap的讨论</a></li><li>低效; 静态方法生成的不可变容器和可变容器有着同样的性能开销,
包括并发修改, 动态扩容等(对于真正的不可变容器而言,
这些都是不会出现的操作)</li></ol><p>综上所述, 如果你不想修改某个容器, 或者你想把某个容器当作不可变常量,
把这个容器变成一个不可变容器是一个很好的手段(使用Guava的不可变容器).</p><p>此外, 在之前的文章中, 我阐述过Guava对于空指针的态度是尽量不要使用空指针,
Guava的类库对于空指针都是快速失败的, Guava的不可变容器也是不例外的,
是拒绝接受空指针的.</p><h2 id=代码实例>3 代码实例<a hidden class=anchor aria-hidden=true href=#代码实例>#</a></h2><p>前面详细介绍了不可变容器, 现在是时候来看一下Guava不可变容器的代码例子:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>COLOR_NAMES</span> <span class=o>=</span> <span class=n>ImmutableSet</span><span class=o>.</span><span class=na>of</span><span class=o>(</span>
</span></span><span class=line><span class=cl>								       <span class=s>&#34;red&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>								       <span class=s>&#34;orange&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>								       <span class=s>&#34;purple&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Foo</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>Bar</span><span class=o>&gt;</span> <span class=n>bars</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=o>(</span><span class=n>Set</span><span class=o>&lt;</span><span class=n>Bar</span><span class=o>&gt;</span> <span class=n>bars</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=k>this</span><span class=o>.</span><span class=na>bars</span> <span class=o>=</span> <span class=n>ImmutableSet</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>bars</span><span class=o>);</span> <span class=c1>// defensive copy!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>前文提到的, <code>Collections.unmodifiableXXX(mutableXXX)</code>,
Collections方法不能提供真正的不可变容器,
除非没有对象持有可变对象<code>mutableXXX</code>的引用</p><p>那么Guava的不可变容器又是否是真正的不可变呢? 以<code>ImmutableSet</code>为例,
发现所有可以修改<code>ImmutableSet</code>对象的操作函数,
包括<code>add</code>, <code>remove</code>, <code>addAll</code>, <code>removeAll</code>等函数都被重载,
然后标注成<code>@Deprecated</code>,
重载函数的内容就是抛出<code>UnsupportedOperationException</code>异常,
所以不可能修改<code>ImmutableSet</code>对象的内容:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Guaranteed to throw an exception and leave the collection unmodified.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @throws UnsupportedOperationException always
</span></span></span><span class=line><span class=cl><span class=cm> * @deprecated Unsupported operation.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@Deprecated</span>
</span></span><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>final</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>UnsupportedOperationException</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>至于持有<code>mutableXXX</code>对象引用,
修改<code>mutableXXX</code>对象内容导致不可变内容发生改变的情况也不会发生:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>testImmutable</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Set</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>colors</span> <span class=o>=</span> <span class=n>Sets</span><span class=o>.</span><span class=na>newHashSet</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>colors</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;blue&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Set</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>modifiableSet</span> <span class=o>=</span> <span class=n>Collections</span><span class=o>.</span><span class=na>unmodifiableSet</span><span class=o>(</span><span class=n>colors</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Set</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>unmodifiableSet</span> <span class=o>=</span> <span class=n>Collections</span><span class=o>.</span><span class=na>unmodifiableSet</span><span class=o>(</span><span class=k>new</span> <span class=n>HashSet</span><span class=o>&lt;&gt;(</span><span class=n>colors</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=kd>final</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>COLOR_NAMES</span> <span class=o>=</span> <span class=n>ImmutableSet</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>colors</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>colors</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;yellow&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 不会修改不可变集合的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Assert</span><span class=o>.</span><span class=na>assertFalse</span><span class=o>(</span><span class=n>COLOR_NAMES</span><span class=o>.</span><span class=na>contains</span><span class=o>(</span><span class=s>&#34;yellow&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 修改引用导致集合值发生修改
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Assert</span><span class=o>.</span><span class=na>assertTrue</span><span class=o>(</span><span class=n>modifiableSet</span><span class=o>.</span><span class=na>contains</span><span class=o>(</span><span class=s>&#34;yellow&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 因为没有对象持有new HashSet&lt;&gt;(colors)的引用, 所以unmodifiableSet是不可变集合, 不能修改
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Assert</span><span class=o>.</span><span class=na>assertFalse</span><span class=o>(</span><span class=n>unmodifiableSet</span><span class=o>.</span><span class=na>contains</span><span class=o>(</span><span class=s>&#34;yellow&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Assert</span><span class=o>.</span><span class=na>assertTrue</span><span class=o>(</span><span class=n>colors</span><span class=o>.</span><span class=na>contains</span><span class=o>(</span><span class=s>&#34;yellow&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>查看<code>ImmutableSet.copyOf(Set&lt;T>)</code>函数的源码,
发现不可变集合的实现逻辑和在构造函数新建对象实现对象引用拷贝的逻辑一致,
即和<code>Collections.unmodifiableSet(new HashSet&lt;>(colors))</code>的逻辑一样的:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>copyOf</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>E</span><span class=o>&gt;</span> <span class=n>elements</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * TODO(lowasser): consider checking for ImmutableAsList here
</span></span></span><span class=line><span class=cl><span class=cm>     * TODO(lowasser): consider checking for Multiset here
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>elements</span> <span class=k>instanceof</span> <span class=n>ImmutableSet</span> <span class=o>&amp;&amp;</span> <span class=o>!(</span><span class=n>elements</span> <span class=k>instanceof</span> <span class=n>ImmutableSortedSet</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span> <span class=c1>// all supported methods are covariant
</span></span></span><span class=line><span class=cl><span class=c1></span>	    <span class=c1>// 新建对象, 拷贝对象引用
</span></span></span><span class=line><span class=cl><span class=c1></span>	    <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>set</span> <span class=o>=</span> <span class=o>(</span><span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;)</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=o>(!</span><span class=n>set</span><span class=o>.</span><span class=na>isPartialView</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	    <span class=k>return</span> <span class=n>set</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>elements</span> <span class=k>instanceof</span> <span class=n>EnumSet</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>copyOfEnumSet</span><span class=o>((</span><span class=n>EnumSet</span><span class=o>)</span> <span class=n>elements</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span><span class=o>[]</span> <span class=n>array</span> <span class=o>=</span> <span class=n>elements</span><span class=o>.</span><span class=na>toArray</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>construct</span><span class=o>(</span><span class=n>array</span><span class=o>.</span><span class=na>length</span><span class=o>,</span> <span class=n>array</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=具体细节>4 具体细节<a hidden class=anchor aria-hidden=true href=#具体细节>#</a></h2><p>下面我们来讨论一下各种不可变容器的具体使用细节.</p><h3 id=构造不可变容器>4.1 构造不可变容器<a hidden class=anchor aria-hidden=true href=#构造不可变容器>#</a></h3><p>关于如何构造一个不可变容器, Guava提供的手段是多种多样的:</p><ol><li>使用<code>copyOf</code>静态方法, 例如<code>ImmutableSet.copyOf(set)</code>,
这种构造方法与JDK不可变容器的构造方式类似<code>Collections.unmodifiableXXX(mutableXXX)</code></li><li>使用<code>of</code>静态方法,
例如<code>ImmutableSet.of("a", "b", "c")</code>或者<code>ImmutableMap.of("a", 1, "b", 2)</code>,
前文已经介绍过, 在此就不赘言</li><li>使用<code>Builder</code>构造不可变容器, 例如:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>Color</span><span class=o>&gt;</span> <span class=n>GOOGLE_COLORS</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>ImmutableSet</span><span class=o>.&lt;</span><span class=n>Color</span><span class=o>&gt;</span><span class=n>builder</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>addAll</span><span class=o>(</span><span class=n>WEBSAFE_COLORS</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Color</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>191</span><span class=o>,</span> <span class=mi>255</span><span class=o>))</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>build</span><span class=o>();</span>
</span></span></code></pre></div><p>不过某些不可变容器的builder方法废弃了,
如<code>ImmutableSortedSet</code>的<code>builder</code>方法就被替换成了<code>naturalOrder</code>.</p><p>此外, 对于有序容器(sorted collections)而言,
容器内的元素的顺序是按照构造时元素的插入顺序排列的, 例如如下代码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>alphaTable</span> <span class=o>=</span> <span class=n>ImmutableSet</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>,</span> <span class=s>&#34;c&#34;</span><span class=o>,</span> <span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=s>&#34;d&#34;</span><span class=o>,</span> <span class=s>&#34;b&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>alphaTable</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 结果为 a b c d
</span></span></span></code></pre></div><h3 id=aslist-函数>4.2 <code>asList</code>函数<a hidden class=anchor aria-hidden=true href=#aslist-函数>#</a></h3><p>所有的不可变容器都提供了一个<code>asList</code>方法来返回一个不可变列表<code>ImmutableList</code>,
所以即使你把数据存在一个不可变有序集合<code>ImmutableSortedSet</code>,
你也可以通过下标索引获取最小的元素或者第n小的元素, 如:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>final</span> <span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>numberSet</span> <span class=o>=</span> <span class=n>ImmutableSortedSet</span><span class=o>.&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=n>naturalOrder</span><span class=o>()</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=mi>3</span><span class=o>,</span> <span class=mi>1</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=mi>4</span><span class=o>,</span> <span class=mi>5</span><span class=o>,</span> <span class=mi>6</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>numberSet</span><span class=o>.</span><span class=na>asList</span><span class=o>().</span><span class=na>get</span><span class=o>(</span><span class=mi>0</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=err>#</span> <span class=err>结果为</span><span class=mi>1</span>
</span></span></code></pre></div><h3 id=智能的-copyof-函数>4.3 智能的<code>copyOf</code>函数<a hidden class=anchor aria-hidden=true href=#智能的-copyof-函数>#</a></h3><p>前文提到,
不可变容器都提供了一个<code>copyOf</code>方法用于从另外一个容器构造出一个不可变容器.
值得指出的是不可变容器的<code>copyOf</code>方法在不需要拷贝数据的时候就会尽量避免拷贝数据,
但这是什么意思呢? 假如有如下的代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ImmutableSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>foobar</span> <span class=o>=</span> <span class=n>ImmutableSet</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;foo&#34;</span><span class=o>,</span> <span class=s>&#34;bar&#34;</span><span class=o>,</span> <span class=s>&#34;baz&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>thingamajig</span><span class=o>(</span><span class=n>foobar</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thingamajig</span><span class=o>(</span><span class=n>Collection</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>collection</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ImmutableList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>defensiveCopy</span> <span class=o>=</span> <span class=n>ImmutableList</span><span class=o>.</span><span class=na>copyOf</span><span class=o>(</span><span class=n>collection</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span></code></pre></div><p>在上面的代码调用<code>ImmutableList.copyOf(foobar)</code>函数的时候,
函数的内部实现不会逐个拷贝,
而会直接通过<code>foobar.asList()</code>函数返回一个不可变值列表,
这样实现的算法时间复杂度就是<code>O(1)</code>, 而不是<code>O(n)</code>, 实现性能消耗的最小化,
这也就是小标题智能指的意思.</p><p>但是需要注意的是,
并不是所有的不可变容器之间的转换都能实现<code>O(1)</code>时间复杂度,
例如<code>ImmutableSet.copyOf(ImmutableList)</code>就只能逐个元素拷贝,
时间复杂度退化到<code>O(n)</code>.</p><h2 id=jdk容器与guava不可变容器>5 JDK容器与Guava不可变容器<a hidden class=anchor aria-hidden=true href=#jdk容器与guava不可变容器>#</a></h2><p>对于JDK提供的标准容器, Guava提供了相应的不可变容器实现,
对于Guava自家的容器, Guava也提供了对应的不可变容器, 具体实现对比如下:</p><table><thead><tr><th>Interface</th><th>JDK or Guava?</th><th>Immutable Version</th></tr></thead><tbody><tr><td><code>Collection</code></td><td>JDK</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableCollection.html><code>ImmutableCollection</code></a></td></tr><tr><td><code>List</code></td><td>JDK</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableList.html><code>ImmutableList</code></a></td></tr><tr><td><code>Set</code></td><td>JDK</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSet.html><code>ImmutableSet</code></a></td></tr><tr><td><code>SortedSet=/=NavigableSet</code></td><td>JDK</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedSet.html><code>ImmutableSortedSet</code></a></td></tr><tr><td><code>Map</code></td><td>JDK</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMap.html><code>ImmutableMap</code></a></td></tr><tr><td><code>SortedMap</code></td><td>JDK</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedMap.html><code>ImmutableSortedMap</code></a></td></tr><tr><td><a href=https://github.com/google/guava/wiki/NewCollectionTypesExplained#Multiset><code>Multiset</code></a></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultiset.html><code>ImmutableMultiset</code></a></td></tr><tr><td><code>SortedMultiset</code></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/12.0/api/docs/com/google/common/collect/ImmutableSortedMultiset.html><code>ImmutableSortedMultiset</code></a></td></tr><tr><td><a href=https://github.com/google/guava/wiki/NewCollectionTypesExplained#Multimap><code>Multimap</code></a></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultimap.html><code>ImmutableMultimap</code></a></td></tr><tr><td><code>ListMultimap</code></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableListMultimap.html><code>ImmutableListMultimap</code></a></td></tr><tr><td><code>SetMultimap</code></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSetMultimap.html><code>ImmutableSetMultimap</code></a></td></tr><tr><td><a href=https://github.com/google/guava/wiki/NewCollectionTypesExplained#BiMap><code>BiMap</code></a></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableBiMap.html><code>ImmutableBiMap</code></a></td></tr><tr><td><a href=https://github.com/google/guava/wiki/NewCollectionTypesExplained#ClassToInstanceMap><code>ClassToInstanceMap</code></a></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableClassToInstanceMap.html><code>ImmutableClassToInstanceMap</code></a></td></tr><tr><td><a href=https://github.com/google/guava/wiki/NewCollectionTypesExplained#Table><code>Table</code></a></td><td>Guava</td><td><a href=http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableTable.html><code>ImmutableTable</code></a></td></tr></tbody></table><h2 id=总结>6 总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>因为不可变容器不会在运行时改变他们的内部状态, 所以他们是线程安全和无副作用的.</p><p>因为这些属性, 不可变容器在多线程环境就会变得特别有用, 可以安全地传递数据. 总而言之,
生活和工作或许可以多拥抱变化, 对于代码, 最好还是多保持不变地好.</p><h2 id=参考>7 参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://github.com/google/guava/wiki/ImmutableCollectionsExplained>Immutable
Collections</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://ramsayleung.github.io/zh/tags/java/>java</a></li><li><a href=https://ramsayleung.github.io/zh/tags/guava/>guava</a></li></ul><nav class=paginav><a class=prev href=https://ramsayleung.github.io/zh/post/2019/%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0/><span class=title>« 上一页</span><br><span>沉默的大多数</span></a>
<a class=next href=https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%94%B9%E5%96%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/><span class=title>下一页 »</span><br><span>Guava探究系列之三：改善通用方法</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on x" href="https://x.com/intent/tweet/?text=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8&url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f&hashtags=java%2cguava"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f&title=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8&summary=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8&source=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f&title=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on whatsapp" href="https://api.whatsapp.com/send?text=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8%20-%20https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on telegram" href="https://telegram.me/share/url?text=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8&url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share guava探究系列之四：不可变容器 on ycombinator" href="https://news.ycombinator.com/submitlink?t=guava%e6%8e%a2%e7%a9%b6%e7%b3%bb%e5%88%97%e4%b9%8b%e5%9b%9b%ef%bc%9a%e4%b8%8d%e5%8f%af%e5%8f%98%e5%ae%b9%e5%99%a8&u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2019%2fguava%25E6%258E%25A2%25E7%25A9%25B6%25E7%25B3%25BB%25E5%2588%2597%25E4%25B9%258B%25E4%25B8%258D%25E5%258F%25AF%25E5%258F%2598%25E5%25AE%25B9%25E5%2599%25A8%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=ramsayleung/comment issue-term=title theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>See this site&rsquo;s source code <a href=https://github.com/ramsayleung/ramsayleung.github.io>here</a>, licensed under GPLv3 ·</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>