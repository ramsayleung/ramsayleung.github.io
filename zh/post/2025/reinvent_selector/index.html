<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>重新造轮子系列(三): HTML Selector | 菠萝油与天光墟</title>
<meta name=keywords content="reinvent"><meta name=description content="项目 GitHub 地址: Selector 1
1 前言
以前写爬虫的时候，必不可少的一个工具就是 HTML selector, 就是用于匹配指定的 HTML 标签。
毕竟爬虫的本质就是找出需要的标签里面的内容，然后解析出来。"><meta name=author content="Ramsay Leung"><link rel=canonical href=https://ramsayleung.github.io/zh/post/2025/reinvent_selector/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e49221d19ec5f71a6d6c298762fd5b141b0b759f7129339638cb7280a05807b2.css integrity="sha256-5JIh0Z7F9xptbCmHYv1bFBsLdZ9xKTOWOMtygKBYB7I=" rel="preload stylesheet" as=style><link rel=icon href=https://ramsayleung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ramsayleung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ramsayleung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ramsayleung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ramsayleung.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://ramsayleung.github.io/zh/post/2025/reinvent_selector/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css integrity=sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js integrity=sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MG65HQHEL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MG65HQHEL")}</script><meta property="og:url" content="https://ramsayleung.github.io/zh/post/2025/reinvent_selector/"><meta property="og:site_name" content="菠萝油与天光墟"><meta property="og:title" content="重新造轮子系列(三): HTML Selector"><meta property="og:description" content="项目 GitHub 地址: Selector 1
1 前言 以前写爬虫的时候，必不可少的一个工具就是 HTML selector, 就是用于匹配指定的 HTML 标签。
毕竟爬虫的本质就是找出需要的标签里面的内容，然后解析出来。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-15T10:53:00-07:00"><meta property="article:modified_time" content="2025-04-04T00:16:01-07:00"><meta property="article:tag" content="Reinvent"><meta property="og:image" content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="重新造轮子系列(三): HTML Selector"><meta name=twitter:description content="项目 GitHub 地址: Selector 1
1 前言
以前写爬虫的时候，必不可少的一个工具就是 HTML selector, 就是用于匹配指定的 HTML 标签。
毕竟爬虫的本质就是找出需要的标签里面的内容，然后解析出来。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ramsayleung.github.io/zh/post/"},{"@type":"ListItem","position":2,"name":"重新造轮子系列(三): HTML Selector","item":"https://ramsayleung.github.io/zh/post/2025/reinvent_selector/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"重新造轮子系列(三): HTML Selector","name":"重新造轮子系列(三): HTML Selector","description":"项目 GitHub 地址: Selector 1\n1 前言 以前写爬虫的时候，必不可少的一个工具就是 HTML selector, 就是用于匹配指定的 HTML 标签。\n毕竟爬虫的本质就是找出需要的标签里面的内容，然后解析出来。\n","keywords":["reinvent"],"articleBody":"项目 GitHub 地址: Selector 1\n1 前言 以前写爬虫的时候，必不可少的一个工具就是 HTML selector, 就是用于匹配指定的 HTML 标签。\n毕竟爬虫的本质就是找出需要的标签里面的内容，然后解析出来。\n而 selector 主要有两个流派，一个是 CSS selector 2, 另外一个是 XPath selector 3 ,本质都是通过某种语法来匹配指定的标签，区别只是一个用的是 CSS 的语法，另外一个是 XML 语法.\n这次我们就来写个基于 CSS 语法的 Selector, 来深入理解下 HTML 的 DOM 模型\n2 DOM 写过前端的朋友应该都知道，前端代码主要是由所谓的三剑客组成的：HTML + CSS + JavaScript, 其中的三剑客各司其职，相互配合。\nHTML 负责内容展示, CSS 负责布局和样式，而 JavaScript 是负责用户与页面之间的动态交互。\n而对于如下的 HTML 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eExample\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eTitle\u003c/h1\u003e \u003cblockquote id=\"important\"\u003e \u003cp\u003eOpening\u003c/p\u003e \u003cp\u003eExplanation\u003c/p\u003e \u003cp class=\"highlight\"\u003eWarning\u003c/p\u003e \u003c/blockquote\u003e \u003cp\u003eClosing\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 浏览器会将其进行解析，并生成名为 Document Object Model(DOM) 的数据结构，听着好像很玄乎，但本质就是一棵多叉树 (Multiway Tree):\n知道 DOM 是多叉树, 我们就可以写出简化版本 DOM 的数据结构了：\n1 2 3 4 5 6 7 8 9 10 11 12 export interface DomNode { type: string; name?: string; attribs?: { id?: string; class?: string; [key: string]: string | undefined; }; children?: DomNode[]; data?: string; parent?: DomNode; } 一个节点可能有多个子节点 (children?) 或者一个父节点 (parent?), 也可能都没有，所以标记成 ?(optional);\n一个节点可能有多个属性 attribs.\n而节点的=type= 可能是 tag, text, comment, script, style, 而对于 text 和 comment 类型的节点， name 也是为空的.\n这个 DOM 结构只是我们的简化版本，完整的 DOM 还有很多的属性和回调函数，详情可以查看文档： Document Object Model (DOM)\n3 BFS vs DFS 理解到 DOM 的本质是个多叉树之后，我们很快就能意识到， selector 本质也就是遍历多叉树，找到符合要求的所有节点, 比如按 tag 名来匹配，按 id 来匹配，按 class 来匹配等等。\n而用于遍历多叉树的常用算法就是广度优先搜索(Breadth First Search, BFS)和深度优先搜索(Depth First Search, DFS)\n通常来说，BFS 和 DFS 都能完成多叉树遍历，时间复杂度也是相同的，BFS通常使用一个 queue 来记录遍历待节点，所以会使用更多的内存，但是能找到最短路径；而 DFS 通常使用递归，如果遇到个循环图，就会 StackOverflow，无法找到结果。\n因为我们明确知道 DOM 是个多叉树（有向无环图），所以我们就使用 DFS 来遍历查找。\n4 Strategy 设计模式 分析好问题之后，我们的实现也差不多能出来了, 按 tag 名来匹配，无非是 domNode.name === tagName; 按 class 来匹配, 即 domNode.attribs.class=== class.\n为了解耦和易于扩展，我们可以使用个策略设计模式(Strategy Design Pattern 4).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface Selector { match(node: DomNode): boolean; } const findByTagName = (tag: string): Selector =\u003e ({ match: (node: DomNode): boolean =\u003e { return node.name.toLowerCase() === tag.toLowerCase() } }); const findById = (id: string): Selector =\u003e ({ match: (node: DomNode): boolean =\u003e { return node.attribs.id === id; } }) const findByClass = (clazz: string): Selector =\u003e ({ match: (node: DomNode): boolean =\u003e { return node.attribs.class === clazz; } }); 然后遍历节点的时候，只需要判断 Selector 是否符合要求，而具体的匹配条件则由 selector 决定:\n1 2 3 const isMatch = (node: DomNode, selectors: Selector[]): boolean =\u003e { return selectors.every(selector =\u003e selector.match(node)); } 这样的话，要增加一个根据属性keyValue值的匹配条件也是非常容易的, 如 div[align=center], 即匹配属性 align 和value 为 center:\n1 2 3 4 5 const findByAttributes = (key: string, value: string): Selector =\u003e ({ match: (node: DomNode): boolean =\u003e { return node.attribs[key] === value; } }) 5 测试验证 DFS + Strategy design pattern 就实现了一个基础的 CSS Selector, 我们自然需要测试验证下是否正确:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 describe('HTML selector testsuite', () =\u003e { const HTML = ` text of first p\ntext of p#id-01\ntext of p#id-02\ntext of p.class-03\ntext of div / p\ntext of div / p#id-04\ntext of div / p.class-05\nshould not be found\ntext of div#id-07 / p\ntext of div#id-07 / p.class-06\n` it.each([ ['p', 'text of first p'], ['p#id-01', 'text of p#id-01'], ['p#id-02', 'text of p#id-02'], ['p.class-03', 'text of p.class-03'], ['div p', 'text of div / p'], ['div p#id-04', 'text of div / p#id-04'], ['div p.class-05', 'text of div / p.class-05'], ['div#id-07 p', 'text of div#id-07 / p'], ['div#id-07 p.class-06', 'text of div#id-07 / p.class-06'] ])('test select %s %s', async (selector, expected) =\u003e { const doc = htmlparser2.parseDOM(HTML)[0]; const node = select(doc, selector); const actual = getText(node); expect(actual).toBe(expected); }) }) 使用 Jest 框架编写了如上的单元测试用例， unit test 都通过了，完工.\n顺便一提的是，这种相同的验证逻辑, 但是输入多个不同的参数以验证不同case的做法，叫做 Parameterized Test\n我在《测试技能进阶系列》的第二篇也曾经介绍过： Parameterized Tests\n6 总结 这个简单的 CSS Selector 全部代码仅有 103 行, 但麻雀虽小，五脏俱全，功能还是齐备的:\n1 2 3 4 5 6 7 8 \u003e tokei simple-selectors.ts =============================================================================== Language Files Lines Code Comments Blanks =============================================================================== TypeScript 1 131 103 9 19 =============================================================================== Total 1 131 103 9 19 =============================================================================== 所以标题也可以修改成 100 行代码实现一个简单的 CSS Selector :)\n如果细看实现，还是有不少的优化之处的，比如 parseSelector 函数可以实现得更优雅些，以便进一步扩展支持其他的语法。\n另外就是目前支持的都是所有 selector 完全匹配的情况，即 and, 但是目前不支持 or 的功能，即类如: h1,h2,h3, 可以匹配 h1, h2, 或者 h3.\n如果想要看下较完整版本的 CSS Selector, 可以看下我六年多前我用 C++ 实现的版本, 实现从字符串解析并生成 DOM, 再实现 CSS 解析器，纯正的 OOP 风味。\n当时初学 C++, 这个算是我早期写得比较大的 C++17 项目，核心代码大概1000行，还有几百行的单元测试。\n现在再翻看自己的代码，会惊讶于当时自己代码写的工整，可谓是有板有眼，像极了书法初学者写的楷书。\n这本砖头书读过, 其他的C++书籍, 如, , 也读过, 感觉不把书中的内容实践下, 很容易遗忘。\n但是日常的工作内容并不会涉及底层网络服务, 一切底层细节内容都被框架给包掉了, 开发的主力语言是Java, 也不会使用到C++.\n因此决定创造个机会实践下这些知识，最终决定只用C/C++内置函数库实现。\n的确所有工具都是用C/C++内置函数库实现的，甚至测试框架还是自己用宏实现的.\n只是我未曾想到的是，写了这段话后不足一年，C++就成为了我下一家公司干活的主力语言; 而现在，我又在重新写 Java, 着实是「白衣苍狗」。\n回到本系列的目录\nhttps://github.com/ramsayleung/reinvent/tree/master/html_selector ↩︎\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors ↩︎\nhttps://developer.mozilla.org/en-US/docs/Web/XML/XPath/Guides ↩︎\nhttps://refactoring.guru/design-patterns/strategy ↩︎\n","wordCount":"2033","inLanguage":"zh","image":"https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-15T10:53:00-07:00","dateModified":"2025-04-04T00:16:01-07:00","author":{"@type":"Person","name":"Ramsay Leung"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ramsayleung.github.io/zh/post/2025/reinvent_selector/"},"publisher":{"@type":"Organization","name":"菠萝油与天光墟","logo":{"@type":"ImageObject","url":"https://ramsayleung.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ramsayleung.github.io/zh/ accesskey=h title="Home (Alt + H)"><img src=https://ramsayleung.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://ramsayleung.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li class=dropdown><a href=https://ramsayleung.github.io/zh/categories/ title="系列 "><span>系列 ▾</span></a><div class="menu-more-content dropdown-content"><a href=https://ramsayleung.github.io/zh/categories/%E5%B1%A5%E8%BF%B9%E4%B8%8E%E6%B2%89%E6%80%9D/ title=履迹与沉思><span>履迹与沉思
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E6%97%85%E5%8A%A0%E7%BB%8F%E5%8E%86 title=旅加经历><span>旅加经历
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/ title=我的工作流><span>我的工作流
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6/ title=测试技能进阶><span>测试技能进阶
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BD%AF%E6%8A%80%E8%83%BD%E6%8C%87%E5%8C%97/ title=软件工程师的软技能指北><span>软件工程师的软技能指北
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F/ title=读书感悟><span>读书感悟</span></a></div></li><li><a href=https://ramsayleung.github.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://ramsayleung.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://ramsayleung.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://ramsayleung.github.io/zh/about_me_zh/ title=关于><span>关于</span></a></li><li><a href=https://ramsayleung.github.io/zh/index.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ramsayleung.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://ramsayleung.github.io/zh/post/>Posts</a></div><h1 class="post-title entry-hint-parent">重新造轮子系列(三): HTML Selector</h1><div class=post-quote><blockquote><p>我从来不把安逸和快乐看作是生活目的本身, 对这种伦理基础, 我称之为'猪栏的理想'。</p><cite>— 爱因斯坦</cite></blockquote></div><hr class=post-separator><div class=post-meta><span title='2025-03-15 10:53:00 -0700 -0700'>三月 15, 2025</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;2033 字&nbsp;|&nbsp;<a href=https://github.com/ramsayleung/ramsayleung.github.io/blob/master/content/post/2025/reinvent_selector.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前言><span class=section-num>1</span> 前言</a></li><li><a href=#dom><span class=section-num>2</span> DOM</a></li><li><a href=#bfs-vs-dfs><span class=section-num>3</span> BFS vs DFS</a></li><li><a href=#strategy-设计模式><span class=section-num>4</span> Strategy 设计模式</a></li><li><a href=#测试验证><span class=section-num>5</span> 测试验证</a></li><li><a href=#总结><span class=section-num>6</span> 总结</a></li></ul></nav></div></details></div><div class=post-content><p>项目 GitHub 地址: <a href=https://github.com/ramsayleung/reinvent/tree/master/html_selector>Selector</a> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><h2 id=前言><span class=section-num>1</span> 前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>以前写爬虫的时候，必不可少的一个工具就是 HTML selector, 就是用于匹配指定的 HTML 标签。</p><p>毕竟爬虫的本质就是找出需要的标签里面的内容，然后解析出来。</p><p>而 selector 主要有两个流派，一个是 <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors>CSS selector</a> <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, 另外一个是 <a href=https://developer.mozilla.org/en-US/docs/Web/XML/XPath/Guides>XPath selector</a> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> ,本质都是通过某种语法来匹配指定的标签，区别只是一个用的是 CSS 的语法，另外一个是 XML 语法.</p><p>这次我们就来写个基于 CSS 语法的 Selector, 来深入理解下 HTML 的 DOM 模型</p><h2 id=dom><span class=section-num>2</span> DOM<a hidden class=anchor aria-hidden=true href=#dom>#</a></h2><p>写过前端的朋友应该都知道，前端代码主要是由所谓的三剑客组成的：HTML + CSS + JavaScript, 其中的三剑客各司其职，相互配合。</p><p>HTML 负责内容展示, CSS 负责布局和样式，而 JavaScript 是负责用户与页面之间的动态交互。</p><p>而对于如下的 HTML 代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>Example<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Title<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>blockquote</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;important&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>Opening<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>Explanation<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=p>&lt;</span><span class=nt>p</span> <span class=na>class</span><span class=o>=</span><span class=s>&#34;highlight&#34;</span><span class=p>&gt;</span>Warning<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;/</span><span class=nt>blockquote</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>Closing<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>浏览器会将其进行解析，并生成名为 <a href=//developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model>Document Object Model</a>(DOM) 的数据结构，听着好像很玄乎，但本质就是一棵多叉树 (Multiway Tree):</p><figure><input type=checkbox id=zoomCheck-6910d hidden>
<label for=zoomCheck-6910d><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_dom_tree.jpg></label></figure><p>知道 <code>DOM</code> 是多叉树, 我们就可以写出简化版本 <code>DOM</code> 的数据结构了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>export</span> <span class=kr>interface</span> <span class=nx>DomNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>type</span><span class=o>:</span> <span class=nx>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span><span class=o>?:</span> <span class=nx>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>attribs</span><span class=o>?:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>id</span><span class=o>?:</span> <span class=nx>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kr>class</span><span class=o>?:</span> <span class=nx>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=nx>key</span><span class=o>:</span> <span class=nx>string</span><span class=p>]</span><span class=o>:</span> <span class=nx>string</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=nx>children</span><span class=o>?:</span> <span class=nx>DomNode</span><span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span><span class=o>?:</span> <span class=nx>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>parent</span><span class=o>?:</span> <span class=nx>DomNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>一个节点可能有多个子节点 <code>(children?)</code> 或者一个父节点 <code>(parent?)</code>, 也可能都没有，所以标记成 <code>?(optional)</code>;</p><p>一个节点可能有多个属性 <code>attribs</code>.</p><p>而节点的=type= 可能是 <code>tag</code>, <code>text</code>, <code>comment</code>, <code>script</code>, <code>style</code>, 而对于 <code>text</code> 和 <code>comment</code> 类型的节点， <code>name</code> 也是为空的.</p><p>这个 <code>DOM</code> 结构只是我们的简化版本，完整的 DOM 还有很多的属性和回调函数，详情可以查看文档： <a href=https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model>Document Object Model (DOM)</a></p><h2 id=bfs-vs-dfs><span class=section-num>3</span> BFS vs DFS<a hidden class=anchor aria-hidden=true href=#bfs-vs-dfs>#</a></h2><p>理解到 <code>DOM</code> 的本质是个多叉树之后，我们很快就能意识到， <code>selector</code> 本质也就是遍历多叉树，找到符合要求的所有节点, 比如按 <code>tag</code> 名来匹配，按 <code>id</code> 来匹配，按 <code>class</code> 来匹配等等。</p><p>而用于遍历多叉树的常用算法就是广度优先搜索(Breadth First Search, BFS)和深度优先搜索(Depth First Search, DFS)</p><figure><input type=checkbox id=zoomCheck-93592 hidden>
<label for=zoomCheck-93592><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_dfs_vs_bfs.jpg></label></figure><p>通常来说，BFS 和 DFS 都能完成多叉树遍历，时间复杂度也是相同的，BFS通常使用一个 <code>queue</code> 来记录遍历待节点，所以会使用更多的内存，但是能找到最短路径；而 DFS 通常使用递归，如果遇到个循环图，就会 StackOverflow，无法找到结果。</p><p>因为我们明确知道 DOM 是个多叉树（有向无环图），所以我们就使用 DFS 来遍历查找。</p><h2 id=strategy-设计模式><span class=section-num>4</span> Strategy 设计模式<a hidden class=anchor aria-hidden=true href=#strategy-设计模式>#</a></h2><p>分析好问题之后，我们的实现也差不多能出来了, 按 tag 名来匹配，无非是 <code>domNode.name === tagName</code>; 按 <code>class</code> 来匹配, 即 <code>domNode.attribs.class=== class</code>.</p><p>为了解耦和易于扩展，我们可以使用个策略设计模式(<a href=https://refactoring.guru/design-patterns/strategy>Strategy Design Pattern</a> <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>).</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>Selector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>match</span><span class=p>(</span><span class=nx>node</span><span class=o>:</span> <span class=nx>DomNode</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>findByTagName</span> <span class=o>=</span> <span class=p>(</span><span class=nx>tag</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Selector</span> <span class=p>=&gt;</span> <span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>match</span><span class=o>:</span> <span class=p>(</span><span class=nx>node</span><span class=o>:</span> <span class=nx>DomNode</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>node</span><span class=p>.</span><span class=nx>name</span><span class=p>.</span><span class=nx>toLowerCase</span><span class=p>()</span> <span class=o>===</span> <span class=nx>tag</span><span class=p>.</span><span class=nx>toLowerCase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>findById</span> <span class=o>=</span> <span class=p>(</span><span class=nx>id</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Selector</span> <span class=p>=&gt;</span> <span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>match</span><span class=o>:</span> <span class=p>(</span><span class=nx>node</span><span class=o>:</span> <span class=nx>DomNode</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>node</span><span class=p>.</span><span class=nx>attribs</span><span class=p>.</span><span class=nx>id</span> <span class=o>===</span> <span class=nx>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>findByClass</span> <span class=o>=</span> <span class=p>(</span><span class=nx>clazz</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Selector</span> <span class=p>=&gt;</span> <span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>match</span><span class=o>:</span> <span class=p>(</span><span class=nx>node</span><span class=o>:</span> <span class=nx>DomNode</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>node</span><span class=p>.</span><span class=nx>attribs</span><span class=p>.</span><span class=kr>class</span> <span class=o>===</span> <span class=nx>clazz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>然后遍历节点的时候，只需要判断 <code>Selector</code> 是否符合要求，而具体的匹配条件则由 <code>selector</code> 决定:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>isMatch</span> <span class=o>=</span> <span class=p>(</span><span class=nx>node</span><span class=o>:</span> <span class=nx>DomNode</span><span class=p>,</span> <span class=nx>selectors</span><span class=o>:</span> <span class=nx>Selector</span><span class=p>[])</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>selectors</span><span class=p>.</span><span class=nx>every</span><span class=p>(</span><span class=nx>selector</span> <span class=p>=&gt;</span> <span class=nx>selector</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>node</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这样的话，要增加一个根据属性keyValue值的匹配条件也是非常容易的, 如 <code>div[align=center]</code>, 即匹配属性 <code>align</code> 和value 为 <code>center</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>findByAttributes</span> <span class=o>=</span> <span class=p>(</span><span class=nx>key</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>Selector</span> <span class=p>=&gt;</span> <span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>match</span><span class=o>:</span> <span class=p>(</span><span class=nx>node</span><span class=o>:</span> <span class=nx>DomNode</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>node</span><span class=p>.</span><span class=nx>attribs</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=o>===</span> <span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=测试验证><span class=section-num>5</span> 测试验证<a hidden class=anchor aria-hidden=true href=#测试验证>#</a></h2><p>DFS + Strategy design pattern 就实现了一个基础的 CSS Selector, 我们自然需要测试验证下是否正确:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>describe</span><span class=p>(</span><span class=s1>&#39;HTML selector testsuite&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>HTML</span> <span class=o>=</span> <span class=sb>`&lt;main&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;p&gt;text of first p&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;p id=&#34;id-01&#34;&gt;text of p#id-01&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;p id=&#34;id-02&#34;&gt;text of p#id-02&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;p class=&#34;class-03&#34;&gt;text of p.class-03&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;div&gt;
</span></span></span><span class=line><span class=cl><span class=sb>    &lt;p&gt;text of div / p&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>    &lt;p id=&#34;id-04&#34;&gt;text of div / p#id-04&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>    &lt;p class=&#34;class-05&#34;&gt;text of div / p.class-05&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>    &lt;p class=&#34;class-06&#34;&gt;should not be found&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;/div&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;div id=&#34;id-07&#34;&gt;
</span></span></span><span class=line><span class=cl><span class=sb>    &lt;p&gt;text of div#id-07 / p&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>    &lt;p class=&#34;class-06&#34;&gt;text of div#id-07 / p.class-06&lt;/p&gt;
</span></span></span><span class=line><span class=cl><span class=sb>  &lt;/div&gt;
</span></span></span><span class=line><span class=cl><span class=sb>&lt;/main&gt;`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>it</span><span class=p>.</span><span class=nx>each</span><span class=p>([</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;p&#39;</span><span class=p>,</span> <span class=s1>&#39;text of first p&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;p#id-01&#39;</span><span class=p>,</span> <span class=s1>&#39;text of p#id-01&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;p#id-02&#39;</span><span class=p>,</span> <span class=s1>&#39;text of p#id-02&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;p.class-03&#39;</span><span class=p>,</span> <span class=s1>&#39;text of p.class-03&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;div p&#39;</span><span class=p>,</span> <span class=s1>&#39;text of div / p&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;div p#id-04&#39;</span><span class=p>,</span> <span class=s1>&#39;text of div / p#id-04&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;div p.class-05&#39;</span><span class=p>,</span> <span class=s1>&#39;text of div / p.class-05&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;div#id-07 p&#39;</span><span class=p>,</span> <span class=s1>&#39;text of div#id-07 / p&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;div#id-07 p.class-06&#39;</span><span class=p>,</span> <span class=s1>&#39;text of div#id-07 / p.class-06&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>])(</span><span class=s1>&#39;test select %s %s&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>selector</span><span class=p>,</span> <span class=nx>expected</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>doc</span> <span class=o>=</span> <span class=nx>htmlparser2</span><span class=p>.</span><span class=nx>parseDOM</span><span class=p>(</span><span class=nx>HTML</span><span class=p>)[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>node</span> <span class=o>=</span> <span class=nx>select</span><span class=p>(</span><span class=nx>doc</span><span class=p>,</span> <span class=nx>selector</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>actual</span> <span class=o>=</span> <span class=nx>getText</span><span class=p>(</span><span class=nx>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=nx>expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>使用 Jest 框架编写了如上的单元测试用例， unit test 都通过了，完工.</p><p>顺便一提的是，这种相同的验证逻辑, 但是输入多个不同的参数以验证不同case的做法，叫做 <code>Parameterized Test</code></p><p>我在《<a href=https://ramsayleung.github.io/zh/categories/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6/>测试技能进阶系列</a>》的第二篇也曾经介绍过： <a href=https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%BA%8C_parameterized_tests/>Parameterized Tests</a></p><h2 id=总结><span class=section-num>6</span> 总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>这个简单的 CSS Selector 全部代码仅有 <strong>103</strong> 行, 但麻雀虽小，五脏俱全，功能还是齐备的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>&gt; tokei simple-selectors.ts
</span></span><span class=line><span class=cl><span class=o>===============================================================================</span>
</span></span><span class=line><span class=cl>Language            Files        Lines         Code     Comments       <span class=nv>Blanks</span>
</span></span><span class=line><span class=cl><span class=o>===============================================================================</span>
</span></span><span class=line><span class=cl>TypeScript              <span class=m>1</span>          <span class=m>131</span>          <span class=m>103</span>            <span class=m>9</span>           <span class=nv>19</span>
</span></span><span class=line><span class=cl><span class=o>===============================================================================</span>
</span></span><span class=line><span class=cl>Total                   <span class=m>1</span>          <span class=m>131</span>          <span class=m>103</span>            <span class=m>9</span>           <span class=nv>19</span>
</span></span><span class=line><span class=cl><span class=o>===============================================================================</span>
</span></span></code></pre></td></tr></table></div></div><p>所以标题也可以修改成 100 行代码实现一个简单的 CSS Selector :)</p><p>如果细看实现，还是有不少的优化之处的，比如 <code>parseSelector</code> 函数可以实现得更优雅些，以便进一步扩展支持其他的语法。</p><p>另外就是目前支持的都是所有 selector 完全匹配的情况，即 <code>and</code>, 但是目前不支持 <code>or</code> 的功能，即类如: <code>h1,h2,h3</code>, 可以匹配 <code>h1</code>, <code>h2</code>, 或者 <code>h3</code>.</p><hr><p>如果想要看下较完整版本的 CSS Selector, 可以看下我六年多前我用 C++ 实现的<a href=https://github.com/ramsayleung/crawler>版本</a>, 实现从字符串解析并生成 <code>DOM</code>, 再实现 CSS 解析器，纯正的 OOP 风味。</p><p>当时初学 C++, 这个算是我早期写得比较大的 C++17 项目，核心代码大概1000行，还有几百行的单元测试。</p><p>现在再翻看自己的代码，会惊讶于当时自己代码写的工整，可谓是有板有眼，像极了书法初学者写的楷书。</p><blockquote><p><span class=org-target id=org-target--Unix----></span>这本砖头书读过, 其他的C++书籍, 如<span class=org-target id=org-target--C---Primer></span>, <span class=org-target id=org-target--Effective-C--></span>, <span class=org-target id=org-target--Modern-C--></span>也读过, 感觉不把书中的内容实践下, 很容易遗忘。</p><p>但是日常的工作内容并不会涉及底层网络服务, 一切底层细节内容都被框架给包掉了, 开发的主力语言是Java, 也不会使用到C++.</p><p>因此决定创造个机会实践下这些知识，最终决定只用C/C++内置函数库实现。</p></blockquote><p>的确所有工具都是用C/C++内置函数库实现的，甚至测试框架还是自己用宏实现的.</p><p>只是我未曾想到的是，写了这段话后不足一年，C++就成为了我下一家公司干活的主力语言; 而现在，我又在重新写 Java, 着实是「白衣苍狗」。</p><p><a href=/zh/post/2025/reinvent_project/>回到本系列的目录</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/ramsayleung/reinvent/tree/master/html_selector>https://github.com/ramsayleung/reinvent/tree/master/html_selector</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors>https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://developer.mozilla.org/en-US/docs/Web/XML/XPath/Guides>https://developer.mozilla.org/en-US/docs/Web/XML/XPath/Guides</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://refactoring.guru/design-patterns/strategy>https://refactoring.guru/design-patterns/strategy</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ramsayleung.github.io/zh/tags/reinvent/>Reinvent</a></li></ul><nav class=paginav><a class=prev href=https://ramsayleung.github.io/zh/post/2025/reinvent_regex/><span class=title>« 上一页</span><br><span>重新造轮子系列(四)：正则表达式引擎</span>
</a><a class=next href=https://ramsayleung.github.io/zh/post/2025/reinvent_file_backup/><span class=title>下一页 »</span><br><span>重新造轮子系列(二)：文件备份</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on x" href="https://x.com/intent/tweet/?text=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f&amp;hashtags=reinvent"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f&amp;title=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector&amp;summary=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector&amp;source=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on reddit" href="https://reddit.com/submit?url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f&title=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on whatsapp" href="https://api.whatsapp.com/send?text=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector%20-%20https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on telegram" href="https://telegram.me/share/url?text=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(三): HTML Selector on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%89%29%3a%20HTML%20Selector&u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_selector%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><section><h2>Comments</h2><div id=comments-giscus></div></section><script type=text/javascript>function getCurrentTheme(){return document.documentElement.getAttribute("data-theme")||document.body.classList.contains("dark")?"dark":"light"}function setGiscusTheme(e=!1){const s=e?"dark":"light";var n,t=document.querySelector(".giscus-frame");t&&(n=new URL(t.src),n.searchParams.set("theme",s),t.src=n.toString())}function loadComment(e=!1){const n="zh"=="zh",t=document.getElementById("comments-giscus");if(t!==null&&!t.hasAttribute("data-giscus-loaded")){console.log("Initial giscus load");const s=document.createElement("script");s.setAttribute("src","https://giscus.app/client.js"),s.setAttribute("data-repo","ramsayleung/comment"),s.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkzMDk2NjQ1NDk="),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOEnUbJc4Cltnz"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",e?"dark":"light"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("data-lang",n?"zh-CN":"en"),s.setAttribute("async","true"),t.appendChild(s),t.setAttribute("data-giscus-loaded","true")}}let currentTheme=getCurrentTheme();loadComment(currentTheme==="dark");const themeObserver=new MutationObserver(e=>{e.forEach(e=>{if(e.type==="attributes"&&e.attributeName==="class"){const e=getCurrentTheme();e!==currentTheme&&(currentTheme=e,setGiscusTheme(currentTheme==="dark"))}})});themeObserver.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script></article></main><footer class=footer><span>See this site&rsquo;s source code <a href=https://github.com/ramsayleung/ramsayleung.github.io>here</a>, licensed under GPLv3 ·</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>