<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>重新造轮子系列(四)：正则表达式引擎 | 过河卒</title>
<meta name=keywords content="reinvent"><meta name=description content="项目 GitHub 地址: Regex 1 前言 所谓的正则表达式，指的是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本。 最开始是一位叫 Stephen Cole Kleene 的数学家用被他称为 Regular"><meta name=author content="Ramsay Leung"><link rel=canonical href=https://ramsayleung.github.io/zh/post/2025/reinvent_regex/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a4a99a31823c5fb400c5486f9eeacbdb2fe3f0a60577136c53b4354303c674e8.css integrity="sha256-pKmaMYI8X7QAxUhvnurL2y/j8KYFdxNsU7Q1QwPGdOg=" rel="preload stylesheet" as=style><link rel=icon href=https://ramsayleung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ramsayleung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ramsayleung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ramsayleung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ramsayleung.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://ramsayleung.github.io/zh/post/2025/reinvent_regex/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MG65HQHEL"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MG65HQHEL",{anonymize_ip:!1})}</script><meta property="og:title" content="重新造轮子系列(四)：正则表达式引擎"><meta property="og:description" content="项目 GitHub 地址: Regex 1 前言 所谓的正则表达式，指的是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本。 最开始是一位叫 Stephen Cole Kleene 的数学家用被他称为 Regular"><meta property="og:type" content="article"><meta property="og:url" content="https://ramsayleung.github.io/zh/post/2025/reinvent_regex/"><meta property="og:image" content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-15T11:01:00-07:00"><meta property="article:modified_time" content="2025-04-04T00:13:14-07:00"><meta property="og:site_name" content="Ramsay's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="重新造轮子系列(四)：正则表达式引擎"><meta name=twitter:description content="项目 GitHub 地址: Regex 1 前言 所谓的正则表达式，指的是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本。 最开始是一位叫 Stephen Cole Kleene 的数学家用被他称为 Regular"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ramsayleung.github.io/zh/post/"},{"@type":"ListItem","position":2,"name":"重新造轮子系列(四)：正则表达式引擎","item":"https://ramsayleung.github.io/zh/post/2025/reinvent_regex/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"重新造轮子系列(四)：正则表达式引擎","name":"重新造轮子系列(四)：正则表达式引擎","description":"项目 GitHub 地址: Regex 1 前言 所谓的正则表达式，指的是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本。 最开始是一位叫 Stephen Cole Kleene 的数学家用被他称为 Regular","keywords":["reinvent"],"articleBody":"项目 GitHub 地址: Regex\n1 前言 所谓的正则表达式，指的是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本。\n最开始是一位叫 Stephen Cole Kleene 的数学家用被他称为 Regular Events 的数学表达式来描述这一模型，在 1968 年，由C语言之父 Ken Tompson 将这个表达式引入到行编辑器 QED, 随后是 Unix 上的编辑器 ed (vi 的前身) ，并最终引入到 grep.\n我一直很好奇正则表达式 (regular expression, 即 Regex ) 是怎么实现的，自正则表达式被引入编程语言之后 之后，可谓说有字符串的地方就基本有正则表达式。\n想起个关于 Regex 的经典笑话:\n程序员A：我有个问题，想用正则表达式解决。\n程序员B：现在你有两个问题了。\n2 需求 完整版本的正则表达式非常复杂，我们的实现不会覆盖所有的规则，所以先来看下我们要支持的正则表达式规则：\n含义 字符 任意的字符 c c 任意的单个字符 . 匹配开头的字符 ^ 匹配结尾的字符 $ 匹配零个或多个的字符 * 虽然这五条原则看起来不是很多，但是已经覆盖日常开发绝大多数的场景了。\n比如 ^ab*c 就意味着匹配以 a 开头，并且0到无数个的 b, 再接一个字符 c, 所以它能匹配: ac, abc 以及 abbbbbc\n3 初始版本 根据上面的需求，可以使用40行不到的代码就实现一个简单的递归版本的正则表达式引擎：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 export const match = (pattern: string, text: string): boolean =\u003e { // '^' at start of pattern matches start of next. if (pattern[0] === '^') { return matchHere(pattern, 1, text, 0); } // Try all possible starting points for pattern. let iText = 0; do { if (matchHere(pattern, 0, text, iText)) { return true; } iText += 1; } while (iText \u003c text.length); // Nothing worked. return false; } const matchHere = (pattern: string, patternIndex: number, text: string, textIndex: number) =\u003e { // There is no more pattern to match. if (patternIndex === pattern.length) { return true; } // '$' at end of pattern matches end of text. if ((patternIndex === (pattern.length - 1)) \u0026\u0026 (pattern[patternIndex] === '$') \u0026\u0026 (textIndex === text.length)) { return true; } // '*' following current character means zero or more. if (((pattern.length - patternIndex) \u003e 1) \u0026\u0026 (pattern[patternIndex + 1] === '*')) { // Try matching zero occurences(skip the current char and the '*') if (matchHere(pattern, patternIndex + 2, text, textIndex)) { return true; } // Try matching one or more occurences while ((textIndex \u003c text.length) \u0026\u0026 (pattern[patternIndex] === '.' || text[textIndex] === pattern[patternIndex])) { // Try to match the rest of pattern after consuming this // character if (matchHere(pattern, patternIndex + 2, text, textIndex + 1)) { return true; } textIndex += 1; } // if there is any match, it will return early in the while loop, // so when reach this statement, it means nothing found. return false; } // Match a single chacater. if (textIndex \u003c text.length \u0026\u0026 (pattern[patternIndex] === '.') || (pattern[patternIndex] === text[textIndex])) { return matchHere(pattern, patternIndex + 1, text, textIndex + 1); } // Nothing worked. return false; } 实现思路如下图:\n好的，我们的正则表达式引擎完工了，正则表达式看起来也没有那么难嘛。\n只是用是能用的，但是看起来不同含义的字符都耦合在 matchHere 函数了，想要支持新的字符匹配(例如 +, 或者 | )很难扩展。\n4 面向对象版本 4.1 接口 再来思考一下版本1的问题:\n我们把不同模式的符号都耦合在同一个函数中。\n在讨论解耦方式之前，先来观察下每个模式的共同点，以便我们抽象接口。\n以最简单的 ^c 模式为例，我们需要将 c 与给定的文本 abc 和 cde 作比较，首先匹配第一个字符，如果匹配失败(如 abc)，则直接结束； 如果匹配第一个字符成功（=cde=）, 那么就匹配剩余的其他字符, 直到模式匹配结束.\n那么对于精确匹配字符的模式 Literal 而言，入参就是字符 c 和文本 text, 返回结果就是true/false, 用来表示是否匹配成功.\n1 const literal_match = (pattern: string, text: string): boolean =\u003e {} 如果不同的模式匹配都使用这个函数签名的话，每次匹配之后，都需要把剩下需要匹配的文本给复制出来，频繁拷贝字符串可能会导致性能开销很大。\n我们可以做个小优化, 通过下标 start 来指定需要匹配的文本, 就可以在不同的模式中都只使用同一份的字符串，避免了多次拷贝的开销。\n而返回结果也不再是 boolean, 而是下一个模式需要匹配的下标。\n比如 ^c 来匹配 cde ，匹配成功之后就返回 1, 就意味着下个模式从 1, 也就是 d 开始匹配.\n那匹配失败要怎么表示？这个也很简单，返回一个不合法的下标，比如 -1 即可，那么我们的模式的函数接口就变成:\n1 const literal_match = (pattern: string, text: string, index: number): number =\u003e {} 4.2 模板设计模式 既然版本一提到了 matchHere 实现耦合在一起，那么有什么方式可以实现解耦呢？\n其中的一个经典解决方式就是面向对象编程(Object Oriented Programming)，这也是面向对象编程的设计初衷。\n既然前面实现的缺点是不同的模式耦合在一起，那么我们可以把每种模式实现成一个函数或者一个类，然后再通过某种模式给组合起来。\n既然用到 OOP, 那么自然少不了设计模式了。如果使用一种模式表示成一个类，那么会是哪种设计模式呢？\n要不就是策略模式(strategy):\n1 2 3 4 5 6 7 8 9 10 11 class ConcreteAlgorithm : IAlgorithm { void DoAlgorithm(int datum) {...} } class Strategy { Strategy(IAlgorithm algo) {...} void run(int datum) { this-\u003ealgo.DoAlgorithm(datum); } } 要么就是模板方法(template method):\n1 2 3 4 5 6 7 8 9 10 11 class ConcreteAlgorithm : AbstractTemplate { void DoAlgorithm(int datum) {...} } class AbstractTemplate { void run(int datum) { DoAlgorithm(datum); } virtual void DoAlgorithm() = 0; // abstract } 看起来好像都可以，那不如就使用模板方式吧。\n4.3 单向链表 那么就让我们来定义个基类 RegexBase :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 export const INVALID_INDEX = -1; export abstract class RegexBase { // index to continue matching at or -1 indicating that matching failed abstract _match(text: string, start: number): number; abstract rest: RegexBase; match(text: string): boolean { // check if the pattern matches at the start of the string if (this._match(text, 0) !== INVALID_INDEX) { return true; } for (let i = 1; i \u003c text.length; i += 1) { if (this._match(text, i) !== undefined) { return true; } } return false; } } 细看之下, 函数签名与我们上文讨论的有所不同，那是因为我们把模式 pattern 作为每个模式类的成员变量了，就不需要显式定义在 _match 函数中了。\n再来看下我们精确匹配字符的 Lit 模式类的实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class RegexLit extends RegexBase { private chars: string; rest: RegexBase constructor(chars: string, rest: RegexBase | null = null) { super() this.chars = chars; this.rest = rest; } _match(text: string, start: number): number { const nextIndex = start + this.chars.length; if (nextIndex \u003e text.length) { return INVALID_INDEX; } if (text.slice(start, nextIndex) !== this.chars) { return INVALID_INDEX; } if (this.rest === null) { return nextIndex; } return this.rest._match(text, nextIndex); } } 实现很简单, 但 rest 又是什么呢?\n还是以 ^c 为例, 现在改复杂一点, 模式变成 ^cd 来匹配 cde ，模式 ^c 匹配完 c 之后, 就要使用剩下的模式(rest) d 来匹配剩下的文本 de, 剩下的模式可能也会再包含剩下的模式，用来匹配再被剩下的文本，依此类推.\n相当于 rest 就是指向下一个模式类的单向指针，用来表示下一个模式需要匹配剩余的文本，直到所有的模式匹配完成，即 rest 指针指向 null\n所以模式 cde 就可以表示成 Lit('c', Lit('d', Lit('e')))\n而所有的模式组合在一起，本质就是一条单向链条，而正则表达式就是判断是否存在依次匹配链表中所有模式的文本。\n4.4 Any 模式 Any 模式即 * 匹配 0到任意个前一个字符，与其类似的还有 Plus 模式，即 + 匹配1到任意个前一个字符字符；以及 ? 表示匹配0到1个前一个字符，Any算是最有代表性和最难实现的模式。\n即 a*b 表示可以匹配0到任意个 a ，再匹配一个 b , 所以 b, ab, aaaaaab 它都可以匹配上。\n那么问题就来了，既然它可以匹配0到任意个字符，那么匹配的时候我要匹配几个字符呢？\n理论上有 N 个的可能性, N = 待匹配文本 text 的长度。\n既然不知道要匹配几个字符，那不如我们把所有可能性都穷举一次呗，而这种穷举算法，则被称为是回溯算法(backtracking)\n我们知道穷举的上界是 N(N=len(text)), 下界是 0, 那么是从 0 穷举到 N, 还是从 N 穷举到 0 呢？\n两种方法都可以解决问题，计算机科学家们还给这两种做法起了个洋气的名字， N -\u003e 0, 因为是先开始匹配所有的字符，所以就被称为贪婪匹配 greedy(eager) matching.\n而从 0 -\u003e N, 因为是从0开始，所以又被称为是惰性匹配 lazy matching。\n从性能的角度来说，是 lazy matching 更优，因为它尽可能地去掉了不必要的匹配了。\n我们可以先来看下贪婪匹配的实现，再看下惰性匹配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class RegexAny extends RegexBase { private child: RegexBase; private rest: RegexBase; constructor(child: RegexBase, rest: RegexBase | null) { super(); this.child = child; this.rest = rest; } _match(text: string, start: number): number | null { const maxPossible = text.length - start; for (let num = maxPossible; num \u003e= 0; num -= 1) { const afterMany = this._matchMany(text, start, num); if (afterMany !== undefined) { return afterMany; } } return undefined; } _matchMany(text: string, start: number, num: number) { for (let i = 0; i \u003c num; i += 1) { start = this.child._match(text, start); if (start === undefined) { return undefined; } } if (this.rest !== null) { return this.rest._match(text, start); } return start; } } a*b 会被解析成, Any(Lit('a'), Lit('b')), 因为 * 表示匹配0到任意个前一个字符，前一个字符还可能另外一种模式，所以我们可以把前一个字符也解析成模式，作为 child 传入到 Any.\n_matchMany 是从 start 匹配到 start+num 位置，看是否匹配，而 maxPossible 表示当前剩余文本中可能的最大匹配次数.\n以 text = \"aab\", start = 0, pattern = a*b 为例， maxPossible = len(text) = 3,\n第一轮尝试(num=3):\n尝试匹配 3 个 a -\u003e 失败(只有 2 个 a) 第二轮尝试(num=2):\n匹配 2 个 =a=(位置 0-\u003e1-\u003e2) 然后匹配 rest(b 在位置 2-\u003e3): 成功！ 返回 3 以及使用模式 a*ab 来匹配文本 ab 的过程: 4.5 支持的模式 每种模式对应一个单独的类之后，再通过 rest 指针进行关联，现在的实现就非常易于扩展了，我们可以很容易地支持其他的模式，具体列表如下：\n含义 字符 例子 对应实现 任意的字符 c c c 匹配字符c Lit 任意的单个字符 . . 匹配任意字符 匹配开头的字符 ^ ^c 匹配以 c 开头的字符串 Start 匹配结尾的字符 $ c$ 匹配以 c 结尾的字符串 End 匹配零个或多个的字符 * a* 匹配0-任意个a的字符串, 贪婪匹配 GreedyAny 匹配零个或多个的字符 * a* 匹配0-任意个a的字符串, 惰性匹配 LazyAny 匹配一个或多个的字符 + a+ 匹配1-任意个a的字符串 Plus 匹配零个或一个的字符 ? a? 匹配0-1个a的字符串 Opt 多选一匹配 ❘ a❘b 匹配a或b的字符串 Alt 序列匹配 () (ab) 匹配 ab 的字符串 Group 匹配方括号内的任意单个字符 [] [abcd] 匹配a或b或c或d的字符串 CharClass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 describe('Regex testsuite', () =\u003e { it.each([ ['a', 'a', true, Lit('a')], ['b', 'a', false, Lit('b')], ['ab', 'ba', false, Lit('ab')], ['^a', 'ab', true, Start(Lit('a'))], ['^b', 'ab', false, Start(Lit('b'))], ['a$', 'ab', false, Lit('a', End())], ['a$', 'ba', true, Lit('a', End())], ['a*', '', true, Any(Lit('a'))], ['a*', 'baac', true, Any(Lit('a'))], ['ab*c', 'ac', true, Lit('a', Any(Lit('b'), Lit('c')))], ['ab*c', 'acc', true, Lit('a', Any(Lit('b'), Lit('c')))], ['ab*c', 'abc', true, Lit('a', Any(Lit('b'), Lit('c')))], ['ab*c', 'abbbc', true, Lit('a', Any(Lit('b'), Lit('c')))], ['ab*c', 'abxc', false, Lit('a', Any(Lit('b'), Lit('c')))], ['ab*c', 'ac', true, Lit('a', LazyAny(Lit('b'), Lit('c')))], ['ab*c', 'acc', true, Lit('a', LazyAny(Lit('b'), Lit('c')))], ['ab*', 'ab', true, Lit('a', LazyAny(Lit('b')))], ['ab+c', 'ac', false, Lit('a', Plus(Lit('b'), Lit('c')))], ['ab+c', 'abc', true, Lit('a', Plus(Lit('b'), Lit('c')))], ['a(b|c)d', 'xabdy', true, Lit('a', Alt(Lit('b'), Lit('c'), Lit('d')))], ['a(b|c)d', 'xabady', false, Lit('a', Alt(Lit('b'), Lit('c'), Lit('d')))], ['ab?c', 'abc', true, Lit('a', Opt(Lit('b'), Lit('c')))], ['ab?c', 'acc', true, Lit('a', Opt(Lit('b'), Lit('c')))], ['ab?c', 'a', false, Lit('a', Opt(Lit('b'), Lit('c')))], [\"[abcd]\", 'a', true, CharClass([Lit('a'), Lit('b'), Lit('c'), Lit('d')])], [\"[abcd]\", 'ab', true, CharClass([Lit('a'), Lit('b'), Lit('c'), Lit('d')])], [\"[abcd]\", 'xhy', false, CharClass([Lit('a'), Lit('b'), Lit('c'), Lit('d')])], [\"c[abcd]\", 'c', false, Lit('c', CharClass([Lit('a'), Lit('b'), Lit('c'), Lit('d')]))], ])('Regex base test (\"%s\" \"%s\" \"%p\")', (_pattern, text, expected, matcher) =\u003e { const actual = matcher.match(text); expect(actual).toBe(expected); }) }); 顺便一提的是，这种相同的验证逻辑, 但是输入多个不同的参数以验证不同case的做法，叫做 Parameterized Test\n我在《测试技能进阶系列》的第二篇也曾经介绍过： Parameterized Tests\n这样我们就完成了一个功能较完整的正则表达式引擎了。\n5 表达式解析 虽然我们已经完成了一个正则表达式引擎，只不过我们平时用表达式是 a*bc ，现在要写成 Any(Lit('a'), Lib('b', Lib('c'))) 多个类的实例也太烦琐了。\n让我们再来分析下正则表达式，以 ^(a|b|$)*z$ 为例，以任意数量的 a, b, 或 $ 开头, 再紧接一个 z, 然后结束。\n我们可以创建一个树来表达这个表达式:\n在考虑如何把表达式变成上面那棵树之前，我们可以先从最简单的步骤开始：分割字符串\n正如物理学家给不可再分的元素称之为「原子」(atom), 计算机科学家也给不可再分割的文本起了一个名字，称之为 token, 类似 a, b, $, * 这些都是 token，而把文本切分成 token 的过程，即为 tokenize 。\n不同的token可能代表不同的含义，像 a, b, c 这类，所以它们的值不同，但是它们都可以被称为字面量(Literal), 而像 *, +, |, (, ) 这样的字符又各种其代表的含义, 如:\n1 2 3 4 5 6 const SYMBOL_TOKEN_TYPE_MAP = { '*': TokenKind.Any, '|': TokenKind.Alt, '(': TokenKind.GroupStart, ')': TokenKind.GroupEnd, } 定义好 token 类型之后， tokenize 跃然纸上了：\n直接按照字符作匹配，如果能匹配上的就是特殊类型的 Token ，不然就是字面量:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 export interface Token { kind: TokenKind, location: number value?: string, } export const tokenize = (text: string) =\u003e { const result: Token[] = []; for (let i = 0; i \u003c text.length; i += 1) { const c = text[i] if (c in SIMPLE) { result.push({ kind: SIMPLE[c], location: i }); } else if ((c === '^') \u0026\u0026 (i === 0)) { result.push({ kind: TokenKind.Start, location: i }); } else if ((c === '$') \u0026\u0026 (i === (text.length - 1))) { result.push({ kind: TokenKind.End, location: i }); } else { result.push({ kind: TokenKind.Lit, location: i, value: c }); } } return result; } ^(a|b|$)*z$ 就会被解析成如下的结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 [ { \"kind\": \"Start\", \"location\": 0 }, { \"kind\": \"GroupStart\", \"location\": 1 }, { \"kind\": \"Lit\", \"location\": 2, \"value\": \"a\" }, { \"kind\": \"Alt\", \"location\": 3 }, { \"kind\": \"Lit\", \"location\": 4, \"value\": \"b\" }, { \"kind\": \"Alt\", \"location\": 5 }, { \"kind\": \"Lit\", \"location\": 6, \"value\": \"$\" }, { \"kind\": \"GroupEnd\", \"location\": 7 }, { \"kind\": \"Any\", \"location\": 8 }, { \"kind\": \"Lit\", \"location\": 9, \"value\": \"z\" }, { \"kind\": \"End\", \"location\": 10 } ] 6 组装抽象语法树 tokenize 的结果是一个包含 Token 的列表，我们要如何组装成树状数据结构呢？\n顺带一提，这树状数据结构全称是抽象语法树(Abstract syntax tree, AST), 是一种用来表示程序结构的数据结构，如:\n我们可以分情况来讨论，因为不同的模式有不同的组装方式，组装完之后的 AST 的输出是一个 output, 包含组装后的 token 列表:\n对于表达式 a, 我们可以创建一个 Lit 类型的 token (为了便于理解，「创建」指创建一个 token, 然后插入到 output.)\n对于表达式 a* 呢？我们可以先创建一个 Lit('a') 的 token, 当遇到 * 时，因为 * 表示匹配0至任意的前一个字符, 所以我们可以创建一个 Any 类型的 token, 然后把 output 最后一个元素 pop 出来，作为 Any 的 child 元素.\n对于表达式 (ab), 情况就变得复杂一些: 当遇到 ( 括号的时候，我们可以创建一个 Group ，但是问题在于，我们不知道这个 Group 什么时候结束，即不知道什么时候才会遇上 ).\n所以我们需要换种解决思路：当遇到 (, 创建一个 GroupStart 类型的 token, 然后再继续处理 a, b, 当遇到 ) 时，创建一个 Group 类型的 token, 然后一直调用 pop 函数直到把 GroupStart 也 pop 出来, 然后把过程中 pop 出来的 token 都当作是 Group 的 children 列表，而 GroupStart 相当于起到一个标记符的作用。\n这种思路就自动处理了 (a*) 和 (a(b*)c) 的差异:\n对于表达式 a|b, 我们是否可以参考 Any 的做法呢?\n遇到 a 的时候先创建一个 Lit('a'), 遇到 | 时再创建一个 Alt, 然后把 Lit('a') 从 output pop 出来作为 left 节点， 再遇到下一个字符 b 的时候，再把 Alt 从 output pop 出来，把 b 作为 right 节点。\n听起来没问题，但是上面的算法无法正确解析 a|b*, 它表示匹配一个 a 或者是任意数量的 b, 但是我们的做法会把它解析成 (a|b)*, 即任意数量的 a 或 b.\n更合理的做法是先部分组装 Alt 的 left 节点，等解析完所有字符之后，再重新解析一次，把 right 节点给组装上。\n以 a|b* 为例子:\n创建一个 Lit('a') token 当遇到 | 的时候，创建一个 Alt, 并将 Lit('a') pop 出来作为 left 节点 创建一个 Lit('b') token 创建一个 Any token, 并将 Lit('b') pop 出来作为 child 节点. 当解析完所有字符后, 再遍历一次 output, 如果遇到 Alt token, 那么就把它的下一个 token (即 Any) 作为它的 right 节点. 实现代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 export const parse = (text: string) =\u003e { const result: Token[] = []; const allTokens = tokenize(text); for (let i = 0; i \u003c allTokens.length; i += 1) { const token = allTokens[i]; const isLast = i === allTokens.length - 1; handle(result, token, isLast); } return compress(result); } const handle = (result: Token[], token: Token, isLast: boolean) =\u003e { if (token.kind === TokenKind.Lit) { result.push(token); } else if (token.kind === TokenKind.Start) { assert(result.length === 0, 'Should not have start token after other tokens'); result.push(token); } else if (token.kind === TokenKind.End) { assert(isLast, `Should not have end token before other tokens`); result.push(token); } else if (token.kind === TokenKind.GroupStart) { result.push(token); } else if (token.kind === TokenKind.GroupEnd) { result.push(groupEnd(result, token)); } else if (token.kind === TokenKind.Any) { assert(result.length \u003e 0, `No Operand for '*' (location ${token.location})`); token.child = result.pop(); result.push(token) } else if (token.kind === TokenKind.Alt) { assert(result.length \u003e 0, `No Operand for '|' (location ${token.location})`); token.left = result.pop(); token.right = null; result.push(token) } else { assert(false, `UNIMPLEMENTED`); } } const groupEnd = (result: Token[], token: Token): Token =\u003e { const group: Token = { kind: TokenKind.Group, location: null, end: token.location, children: [] }; while (true) { assert(result.length \u003e 0, `Unmatched end parenthesis (location ${token.location})`); const child = result.pop(); if (child.kind === TokenKind.GroupStart) { group.location = child.location; break; } group.children.unshift(child); } return group; } // go through the output list to fill in the right side of Alts: const compress = (raw: Token[]) =\u003e { const cooked: Token[] = []; while (raw.length \u003e 0) { const token = raw.pop(); if (token.kind === TokenKind.Alt) { assert(cooked.length \u003e 0, `No right operand for alt (location ${token.location})`); token.right = cooked.shift(); } cooked.unshift(token); } return cooked; } 对于表达式 a|(bc), 输出的 AST 如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ { kind: TokenKind.Alt, location: 1, left: { kind: TokenKind.Lit, location: 0, value: 'a' }, right: { kind: TokenKind.Group, location: 2, end: 5, children: [ { kind: TokenKind.Lit, location: 3, value: 'b' }, { kind: TokenKind.Lit, location: 4, value: 'c' }, ] } }, ] 7 实例化 既然抽象语法树 AST 已经就绪了，我们就差最后一步了，把 AST 转变为我们的类实例.\n还记得上文提到过, 不同的模式对应不同的类，然后通过 rest 指针指向下一个模式类，以此串成一个链表。\n那么我们对于 output 这个包含多个 token 的列表，我们可以抽象成两个 token, 当前 token 和下一个 token:\n假如我们有函数 f 可以把当前 token 初始化对应的模式类，我们只需要再把剩下的 token 列表初始化成 rest, 那么 rest 要怎么初始化呢？\n只需要再调用 f 即可.\n这不就是递归嘛! 是的，通过递归就很简单地把实例化也实现出来了:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 export const compile = (text: string): RegexBase =\u003e { const tokens: Token[] = parse(text); return createObjectByAST(tokens); } // return instances of classes derived from RegexBase by abstract syntax tree const createObjectByAST = (tokens: Token[]): RegexBase | null =\u003e { if (tokens.length === 0) { return null; } const token = tokens.shift(); if (token.kind === TokenKind.Lit) { return Lit(token.value, createObjectByAST(tokens)); } else if (token.kind === TokenKind.Start) { return Start(createObjectByAST(tokens)); } else if (token.kind === TokenKind.End) { assert(tokens.length === 0, `Should not have end token before other tokens`); return End(); } else if (token.kind === TokenKind.Alt) { return Alt(createObjectByAST([token.left]), createObjectByAST([token.right]), createObjectByAST(tokens)); } else if (token.kind === TokenKind.Group) { return Group(token.children.map((childToken) =\u003e createObjectByAST([childToken])), createObjectByAST(tokens)); } else if (token.kind === TokenKind.Any) { return Any(createObjectByAST([token.child]), createObjectByAST(tokens)); } else { assert(false, `UNKNOWN token type ${token.kind}`); } } 8 总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 it.each([ ['a', 'a', true, Lit('a')], ['^a', 'ab', true, Start(Lit('a'))], ['a$', 'ab', false, Lit('a', End())], ['a*', 'baac', true, Any(Lit('a'))], ['ab+c', 'abc', true, Lit('a', Plus(Lit('b'), Lit('c')))], ['ab+c', 'abxc', false, Lit('a', Plus(Lit('b'), Lit('c')))], ['(ab)|(cd)', 'xaby', true, Alt(Group([Lit('a'), Lit('b')]), Group([Lit('c'), Lit('d')]))], ['a(b|c)d', 'xabdy', true, Lit('a', Group([Alt(Lit('b'), Lit('c'))], Lit('d')))], ['ab?c', 'ac', true, Lit('a', Opt(Lit('b'), Lit('c')))], ['ab?c', 'acc', true, Lit('a', Opt(Lit('b'), Lit('c')))], [\"[abcd]c\", 'ac', true, CharClass([Lit('a'), Lit('b'), Lit('c'), Lit('d')], Lit('c'))], [\"c[abcd]\", 'c', false, Lit('c', CharClass([Lit('a'), Lit('b'), Lit('c'), Lit('d')]))], ])('parse, compile and matcher test (\"%s\" \"%s\" \"%p\")', (pattern, text, expected, expectedMatcher) =\u003e { const actualMatcher = compile(pattern); expect(actualMatcher).toStrictEqual(expectedMatcher); const actual = actualMatcher.match(text); expect(actual).toBe(expected); }) 大功告成，终于将所有的功能都组装起来实现这个正则表达式引擎了, 除去前文提到的功能之外，还实现了 \\* 转义特殊字符， [xya] 匹配 x, y, z 其中任意字符，以及 *? 实现惰性匹配的功能。\n完整功能集的测试 case 可见 parser_test.ts\n日常使用正则表达式的场景非常多，因为其强大的功能和表达能力，总会下意识觉得很难实现（当然，高性能的完整版本的确是非常有挑战性的）。\n但是当自己把正则表达式引擎这个轮子拆开，再重新造一个出来之后，才感悟到：\n「没有启程的路才会遥不可及」，很多时候，困难只是我们给自己设下的心理障碍。\n回到本系列的目录\n9 参考 https://en.wikipedia.org/wiki/Stephen_Cole_Kleene https://en.wikipedia.org/wiki/Ed_(software) https://en.wikipedia.org/wiki/Grep https://third-bit.com/sdxjs/regex-parser/ https://third-bit.com/sdxjs/pattern-matching/ ","wordCount":"6263","inLanguage":"zh","image":"https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-15T11:01:00-07:00","dateModified":"2025-04-04T00:13:14-07:00","author":{"@type":"Person","name":"Ramsay Leung"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ramsayleung.github.io/zh/post/2025/reinvent_regex/"},"publisher":{"@type":"Organization","name":"过河卒","logo":{"@type":"ImageObject","url":"https://ramsayleung.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ramsayleung.github.io/zh/ accesskey=h title="Home (Alt + H)"><img src=https://ramsayleung.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://ramsayleung.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li class=dropdown><a href=https://ramsayleung.github.io/zh/categories/ title="系列 "><span>系列 ▾</span></a><div class="menu-more-content dropdown-content"><a href=https://ramsayleung.github.io/zh/categories/%E5%BE%97%E5%A4%B1%E6%84%9F%E6%82%9F/ title=得失感悟><span>得失感悟
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E6%97%85%E5%8A%A0%E7%BB%8F%E5%8E%86 title=旅加经历><span>旅加经历
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E5%B7%A5%E4%BD%9C%E6%B5%81/ title=我的工作流><span>我的工作流
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6/ title=测试技能进阶><span>测试技能进阶
</span></a><a href=https://ramsayleung.github.io/zh/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%BD%AF%E6%8A%80%E8%83%BD%E6%8C%87%E5%8C%97/ title=软件工程师的软技能指北><span>软件工程师的软技能指北
</span></a><a href=https://ramsayleung.github.io/zh/categories/reinvent-%E9%87%8D%E6%96%B0%E9%80%A0%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97 title=Reinvent-重新造轮子系列><span>Reinvent-重新造轮子系列</span></a></div></li><li><a href=https://ramsayleung.github.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://ramsayleung.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://ramsayleung.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://ramsayleung.github.io/zh/about_me_zh/ title=关于><span>关于</span></a></li><li><a href=https://ramsayleung.github.io/zh/index.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ramsayleung.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://ramsayleung.github.io/zh/post/>Posts</a></div><h1 class="post-title entry-hint-parent">重新造轮子系列(四)：正则表达式引擎</h1><div class=post-meta><span title='2025-03-15 11:01:00 -0700 -0700'>三月 15, 2025</span>&nbsp;·&nbsp;13 分钟&nbsp;·&nbsp;6263 字&nbsp;·&nbsp;Ramsay Leung&nbsp;|&nbsp;<a href=https://github.com/ramsayleung/ramsayleung.github.io/blob/master/content/post/2025/reinvent_regex.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#前言><span class=section-num>1</span> 前言</a></li><li><a href=#需求><span class=section-num>2</span> 需求</a></li><li><a href=#初始版本><span class=section-num>3</span> 初始版本</a></li><li><a href=#面向对象版本><span class=section-num>4</span> 面向对象版本</a><ul><li><a href=#接口><span class=section-num>4.1</span> 接口</a></li><li><a href=#模板设计模式><span class=section-num>4.2</span> 模板设计模式</a></li><li><a href=#单向链表><span class=section-num>4.3</span> 单向链表</a></li><li><a href=#any-模式><span class=section-num>4.4</span> Any 模式</a></li><li><a href=#支持的模式><span class=section-num>4.5</span> 支持的模式</a></li></ul></li><li><a href=#表达式解析><span class=section-num>5</span> 表达式解析</a></li><li><a href=#组装抽象语法树><span class=section-num>6</span> 组装抽象语法树</a></li><li><a href=#实例化><span class=section-num>7</span> 实例化</a></li><li><a href=#总结><span class=section-num>8</span> 总结</a></li><li><a href=#参考><span class=section-num>9</span> 参考</a></li></ul></nav></div></details></div><div class=post-content><p>项目 GitHub 地址: <a href=https://github.com/ramsayleung/reinvent/tree/master/regular_expression>Regex</a></p><h2 id=前言><span class=section-num>1</span> 前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>所谓的正则表达式，指的是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本。</p><p>最开始是一位叫 <a href=https://en.wikipedia.org/wiki/Stephen_Cole_Kleene>Stephen Cole Kleene</a> 的数学家用被他称为 Regular Events 的数学表达式来描述这一模型，在 1968 年，由C语言之父 Ken Tompson 将这个表达式引入到行编辑器 <a href=https://en.wikipedia.org/wiki/QED_(text_editor)>QED</a>, 随后是 Unix 上的编辑器 <a href=https://en.wikipedia.org/wiki/Ed_(software)>ed</a> (vi 的前身) ，并最终引入到 <a href=https://en.wikipedia.org/wiki/Grep>grep</a>.</p><p>我一直很好奇正则表达式 (regular expression, 即 <code>Regex</code> ) 是怎么实现的，自正则表达式被引入编程语言之后 之后，可谓说有字符串的地方就基本有正则表达式。</p><p>想起个关于 <code>Regex</code> 的经典笑话:</p><blockquote><p>程序员A：我有个问题，想用正则表达式解决。</p><p>程序员B：现在你有两个问题了。</p></blockquote><h2 id=需求><span class=section-num>2</span> 需求<a hidden class=anchor aria-hidden=true href=#需求>#</a></h2><p>完整版本的正则表达式非常复杂，我们的实现不会覆盖所有的规则，所以先来看下我们要支持的正则表达式规则：</p><table><thead><tr><th>含义</th><th>字符</th></tr></thead><tbody><tr><td>任意的字符 <code>c</code></td><td><code>c</code></td></tr><tr><td>任意的单个字符</td><td><code>.</code></td></tr><tr><td>匹配开头的字符</td><td><code>^</code></td></tr><tr><td>匹配结尾的字符</td><td><code>$</code></td></tr><tr><td>匹配零个或多个的字符</td><td><code>*</code></td></tr></tbody></table><p>虽然这五条原则看起来不是很多，但是已经覆盖日常开发绝大多数的场景了。</p><p>比如 <code>^ab*c</code> 就意味着匹配以 <code>a</code> 开头，并且0到无数个的 <code>b</code>, 再接一个字符 <code>c</code>, 所以它能匹配:
<code>ac</code>, <code>abc</code> 以及 <code>abbbbbc</code></p><h2 id=初始版本><span class=section-num>3</span> 初始版本<a hidden class=anchor aria-hidden=true href=#初始版本>#</a></h2><p>根据上面的需求，可以使用40行不到的代码就实现一个简单的递归版本的正则表达式引擎：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=kr>const</span> <span class=nx>match</span> <span class=o>=</span> <span class=p>(</span><span class=nx>pattern</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// &#39;^&#39; at start of pattern matches start of next.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>===</span> <span class=s1>&#39;^&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>matchHere</span><span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Try all possible starting points for pattern.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>let</span> <span class=nx>iText</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>matchHere</span><span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>iText</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>iText</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nx>iText</span> <span class=o>&lt;</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Nothing worked.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>matchHere</span> <span class=o>=</span> <span class=p>(</span><span class=nx>pattern</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>patternIndex</span><span class=o>:</span> <span class=nx>number</span><span class=p>,</span> <span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>textIndex</span><span class=o>:</span> <span class=nx>number</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// There is no more pattern to match.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>patternIndex</span> <span class=o>===</span> <span class=nx>pattern</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// &#39;$&#39; at end of pattern matches end of text.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>((</span><span class=nx>patternIndex</span> <span class=o>===</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>[</span><span class=nx>patternIndex</span><span class=p>]</span> <span class=o>===</span> <span class=s1>&#39;$&#39;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>textIndex</span> <span class=o>===</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// &#39;*&#39; following current character means zero or more.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(((</span><span class=nx>pattern</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=nx>patternIndex</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>[</span><span class=nx>patternIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>===</span> <span class=s1>&#39;*&#39;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Try matching zero occurences(skip the current char and the &#39;*&#39;)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>matchHere</span><span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=nx>patternIndex</span> <span class=o>+</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>textIndex</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Try matching one or more occurences
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>((</span><span class=nx>textIndex</span> <span class=o>&lt;</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>[</span><span class=nx>patternIndex</span><span class=p>]</span> <span class=o>===</span> <span class=s1>&#39;.&#39;</span> <span class=o>||</span> <span class=nx>text</span><span class=p>[</span><span class=nx>textIndex</span><span class=p>]</span> <span class=o>===</span> <span class=nx>pattern</span><span class=p>[</span><span class=nx>patternIndex</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Try to match the rest of pattern after consuming this
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// character
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=nx>matchHere</span><span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=nx>patternIndex</span> <span class=o>+</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>textIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=nx>textIndex</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// if there is any match, it will return early in the while loop,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// so when reach this statement, it means nothing found.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Match a single chacater.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>textIndex</span> <span class=o>&lt;</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>[</span><span class=nx>patternIndex</span><span class=p>]</span> <span class=o>===</span> <span class=s1>&#39;.&#39;</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>[</span><span class=nx>patternIndex</span><span class=p>]</span> <span class=o>===</span> <span class=nx>text</span><span class=p>[</span><span class=nx>textIndex</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>matchHere</span><span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=nx>patternIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>textIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Nothing worked.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>实现思路如下图:</p><figure><input type=checkbox id=zoomCheck-26048 hidden>
<label for=zoomCheck-26048><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_simple_regex_design.png></label></figure><p>好的，我们的正则表达式引擎完工了，正则表达式看起来也没有那么难嘛。</p><p>只是用是能用的，但是看起来不同含义的字符都耦合在 <code>matchHere</code> 函数了，想要支持新的字符匹配(例如 <code>+</code>, 或者 <code>|</code> )很难扩展。</p><h2 id=面向对象版本><span class=section-num>4</span> 面向对象版本<a hidden class=anchor aria-hidden=true href=#面向对象版本>#</a></h2><h3 id=接口><span class=section-num>4.1</span> 接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h3><p>再来思考一下版本1的问题:</p><p>我们把不同模式的符号都耦合在同一个函数中。</p><p>在讨论解耦方式之前，先来观察下每个模式的共同点，以便我们抽象接口。</p><p>以最简单的 <code>^c</code> 模式为例，我们需要将 <code>c</code> 与给定的文本 <code>abc</code> 和 <code>cde</code> 作比较，首先匹配第一个字符，如果匹配失败(如 <code>abc</code>)，则直接结束； 如果匹配第一个字符成功（=cde=）, 那么就匹配剩余的其他字符, 直到模式匹配结束.</p><p>那么对于精确匹配字符的模式 <code>Literal</code> 而言，入参就是字符 <code>c</code> 和文本 <code>text</code>, 返回结果就是true/false, 用来表示是否匹配成功.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>literal_match</span> <span class=o>=</span> <span class=p>(</span><span class=nx>pattern</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>=&gt;</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果不同的模式匹配都使用这个函数签名的话，每次匹配之后，都需要把剩下需要匹配的文本给复制出来，频繁拷贝字符串可能会导致性能开销很大。</p><p>我们可以做个小优化, 通过下标 <code>start</code> 来指定需要匹配的文本, 就可以在不同的模式中都只使用同一份的字符串，避免了多次拷贝的开销。</p><p>而返回结果也不再是 boolean, 而是下一个模式需要匹配的下标。</p><p>比如 <code>^c</code> 来匹配 <code>cde</code> ，匹配成功之后就返回 <code>1</code>, 就意味着下个模式从 <code>1</code>, 也就是 <code>d</code> 开始匹配.</p><p>那匹配失败要怎么表示？这个也很简单，返回一个不合法的下标，比如 <code>-1</code> 即可，那么我们的模式的函数接口就变成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>literal_match</span> <span class=o>=</span> <span class=p>(</span><span class=nx>pattern</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>index</span><span class=o>:</span> <span class=nx>number</span><span class=p>)</span><span class=o>:</span> <span class=nx>number</span> <span class=p>=&gt;</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=模板设计模式><span class=section-num>4.2</span> 模板设计模式<a hidden class=anchor aria-hidden=true href=#模板设计模式>#</a></h3><p>既然版本一提到了 <code>matchHere</code> 实现耦合在一起，那么有什么方式可以实现解耦呢？</p><p>其中的一个经典解决方式就是面向对象编程(Object Oriented Programming)，这也是面向对象编程的设计初衷。</p><p>既然前面实现的缺点是不同的模式耦合在一起，那么我们可以把每种模式实现成一个函数或者一个类，然后再通过某种模式给组合起来。</p><p>既然用到 OOP, 那么自然少不了设计模式了。如果使用一种模式表示成一个类，那么会是哪种设计模式呢？</p><p>要不就是<a href=https://refactoring.guru/design-patterns/strategy>策略模式(strategy)</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcreteAlgorithm</span> <span class=o>:</span> <span class=n>IAlgorithm</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DoAlgorithm</span><span class=p>(</span><span class=kt>int</span> <span class=n>datum</span><span class=p>)</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Strategy</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Strategy</span><span class=p>(</span><span class=n>IAlgorithm</span> <span class=n>algo</span><span class=p>)</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>run</span><span class=p>(</span><span class=kt>int</span> <span class=n>datum</span><span class=p>)</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>algo</span><span class=p>.</span><span class=n>DoAlgorithm</span><span class=p>(</span><span class=n>datum</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>要么就是<a href=https://refactoring.guru/design-patterns/template-method>模板方法(template method)</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcreteAlgorithm</span> <span class=o>:</span> <span class=n>AbstractTemplate</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DoAlgorithm</span><span class=p>(</span><span class=kt>int</span> <span class=n>datum</span><span class=p>)</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AbstractTemplate</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>run</span><span class=p>(</span><span class=kt>int</span> <span class=n>datum</span><span class=p>)</span> <span class=p>{</span> <span class=n>DoAlgorithm</span><span class=p>(</span><span class=n>datum</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>DoAlgorithm</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// abstract
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>看起来好像都可以，那不如就使用模板方式吧。</p><h3 id=单向链表><span class=section-num>4.3</span> 单向链表<a hidden class=anchor aria-hidden=true href=#单向链表>#</a></h3><p>那么就让我们来定义个基类 <code>RegexBase</code> :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=kr>const</span> <span class=nx>INVALID_INDEX</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kr>abstract</span> <span class=kr>class</span> <span class=nx>RegexBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// index to continue matching at or -1 indicating that matching failed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>abstract</span> <span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>start</span><span class=o>:</span> <span class=nx>number</span><span class=p>)</span><span class=o>:</span> <span class=nx>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>abstract</span> <span class=nx>rest</span><span class=o>:</span> <span class=nx>RegexBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>match</span><span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// check if the pattern matches at the start of the string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!==</span> <span class=nx>INVALID_INDEX</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span> <span class=o>!==</span> <span class=kc>undefined</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>细看之下, 函数签名与我们上文讨论的有所不同，那是因为我们把模式 <code>pattern</code> 作为每个模式类的成员变量了，就不需要显式定义在 <code>_match</code> 函数中了。</p><p>再来看下我们精确匹配字符的 <code>Lit</code> 模式类的实现:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>class</span> <span class=nx>RegexLit</span> <span class=kr>extends</span> <span class=nx>RegexBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>private</span> <span class=nx>chars</span><span class=o>:</span> <span class=nx>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>rest</span><span class=o>:</span> <span class=nx>RegexBase</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>chars</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>rest</span><span class=o>:</span> <span class=nx>RegexBase</span> <span class=o>|</span> <span class=kc>null</span> <span class=o>=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>super</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>chars</span> <span class=o>=</span> <span class=nx>chars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>rest</span> <span class=o>=</span> <span class=nx>rest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>start</span><span class=o>:</span> <span class=nx>number</span><span class=p>)</span><span class=o>:</span> <span class=nx>number</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>nextIndex</span> <span class=o>=</span> <span class=nx>start</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>chars</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>nextIndex</span> <span class=o>&gt;</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>INVALID_INDEX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>text</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=nx>start</span><span class=p>,</span> <span class=nx>nextIndex</span><span class=p>)</span> <span class=o>!==</span> <span class=k>this</span><span class=p>.</span><span class=nx>chars</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>INVALID_INDEX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>rest</span> <span class=o>===</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>nextIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>rest</span><span class=p>.</span><span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=nx>nextIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>实现很简单, 但 <code>rest</code> 又是什么呢?</p><p>还是以 <code>^c</code> 为例, 现在改复杂一点, 模式变成 <code>^cd</code> 来匹配 <code>cde</code> ，模式 <code>^c</code> 匹配完 <code>c</code> 之后, 就要使用剩下的模式(<code>rest</code>) <code>d</code> 来匹配剩下的文本 <code>de</code>, 剩下的模式可能也会再包含剩下的模式，用来匹配再被剩下的文本，依此类推.</p><figure><input type=checkbox id=zoomCheck-2d2c9 hidden>
<label for=zoomCheck-2d2c9><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_regex_rest_pointer.jpg></label></figure><p>相当于 <code>rest</code> 就是指向下一个模式类的单向指针，用来表示下一个模式需要匹配剩余的文本，直到所有的模式匹配完成，即 <code>rest</code> 指针指向 <code>null</code></p><p>所以模式 <code>cde</code> 就可以表示成 <code>Lit('c', Lit('d', Lit('e')))</code></p><p>而所有的模式组合在一起，本质就是一条单向链条，而正则表达式就是判断是否存在依次匹配链表中所有模式的文本。</p><h3 id=any-模式><span class=section-num>4.4</span> Any 模式<a hidden class=anchor aria-hidden=true href=#any-模式>#</a></h3><p>Any 模式即 <code>*</code> 匹配 0到任意个前一个字符，与其类似的还有 Plus 模式，即 <code>+</code> 匹配1到任意个前一个字符字符；以及 <code>?</code> 表示匹配0到1个前一个字符，Any算是最有代表性和最难实现的模式。</p><p>即 <code>a*b</code> 表示可以匹配0到任意个 <code>a</code> ，再匹配一个 <code>b</code> , 所以 <code>b</code>, <code>ab</code>, <code>aaaaaab</code> 它都可以匹配上。</p><p>那么问题就来了，既然它可以匹配0到任意个字符，那么匹配的时候我要匹配几个字符呢？</p><p>理论上有 <code>N</code> 个的可能性, N = 待匹配文本 <code>text</code> 的长度。</p><p>既然不知道要匹配几个字符，那不如我们把所有可能性都穷举一次呗，而这种穷举算法，则被称为是<a href=https://labuladong.online/algo/essential-technique/backtrack-framework/#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90>回溯算法</a>(<a href=https://en.wikipedia.org/wiki/Backtracking>backtracking</a>)</p><p>我们知道穷举的上界是 N(<code>N=len(text)</code>), 下界是 0, 那么是从 0 穷举到 <code>N</code>, 还是从 <code>N</code> 穷举到 <code>0</code> 呢？</p><p>两种方法都可以解决问题，计算机科学家们还给这两种做法起了个洋气的名字， <code>N</code> -> <code>0</code>, 因为是先开始匹配所有的字符，所以就被称为贪婪匹配 greedy(eager) matching.</p><p>而从 <code>0</code> -> <code>N</code>, 因为是从0开始，所以又被称为是惰性匹配 lazy matching。</p><p>从性能的角度来说，是 <code>lazy matching</code> 更优，因为它尽可能地去掉了不必要的匹配了。</p><p>我们可以先来看下贪婪匹配的实现，再看下惰性匹配：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>class</span> <span class=nx>RegexAny</span> <span class=kr>extends</span> <span class=nx>RegexBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>private</span> <span class=nx>child</span><span class=o>:</span> <span class=nx>RegexBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>private</span> <span class=nx>rest</span><span class=o>:</span> <span class=nx>RegexBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>child</span><span class=o>:</span> <span class=nx>RegexBase</span><span class=p>,</span> <span class=nx>rest</span><span class=o>:</span> <span class=nx>RegexBase</span> <span class=o>|</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>super</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>child</span> <span class=o>=</span> <span class=nx>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>rest</span> <span class=o>=</span> <span class=nx>rest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>start</span><span class=o>:</span> <span class=nx>number</span><span class=p>)</span><span class=o>:</span> <span class=nx>number</span> <span class=o>|</span> <span class=kc>null</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>maxPossible</span> <span class=o>=</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=nx>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>num</span> <span class=o>=</span> <span class=nx>maxPossible</span><span class=p>;</span> <span class=nx>num</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>num</span> <span class=o>-=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>afterMany</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>_matchMany</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>afterMany</span> <span class=o>!==</span> <span class=kc>undefined</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>afterMany</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>_matchMany</span><span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>,</span> <span class=nx>start</span><span class=o>:</span> <span class=nx>number</span><span class=p>,</span> <span class=nx>num</span><span class=o>:</span> <span class=nx>number</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>num</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>start</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>child</span><span class=p>.</span><span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=nx>start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>start</span> <span class=o>===</span> <span class=kc>undefined</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>rest</span> <span class=o>!==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>rest</span><span class=p>.</span><span class=nx>_match</span><span class=p>(</span><span class=nx>text</span><span class=p>,</span> <span class=nx>start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>a*b</code> 会被解析成, <code>Any(Lit('a'), Lit('b'))</code>, 因为 <code>*</code> 表示匹配0到任意个前一个字符，前一个字符还可能另外一种模式，所以我们可以把前一个字符也解析成模式，作为 <code>child</code> 传入到 <code>Any</code>.</p><p><code>_matchMany</code> 是从 <code>start</code> 匹配到 <code>start+num</code> 位置，看是否匹配，而 <code>maxPossible</code> 表示当前剩余文本中可能的最大匹配次数.</p><p>以 <code>text = "aab"</code>, <code>start = 0</code>, <code>pattern = a*b</code> 为例， <code>maxPossible = len(text) = 3</code>,</p><ol><li><p>第一轮尝试(<code>num=3</code>):</p><ul><li>尝试匹配 3 个 <code>a</code> -> 失败(只有 2 个 <code>a</code>)</li></ul></li><li><p>第二轮尝试(<code>num=2</code>):</p><ul><li>匹配 2 个 =a=(位置 <code>0->1->2</code>)</li><li>然后匹配 rest(b 在位置 <code>2->3</code>): 成功！</li><li>返回 3</li></ul><figure><input type=checkbox id=zoomCheck-c2c3c hidden>
<label for=zoomCheck-c2c3c><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_regex_match_aab.png></label></figure></li></ol><p>以及使用模式 <code>a*ab</code> 来匹配文本 <code>ab</code> 的过程:
<img loading=lazy src=/ox-hugo/reinvent_regex_match_ab.jpg alt></p><h3 id=支持的模式><span class=section-num>4.5</span> 支持的模式<a hidden class=anchor aria-hidden=true href=#支持的模式>#</a></h3><p>每种模式对应一个单独的类之后，再通过 <code>rest</code> 指针进行关联，现在的实现就非常易于扩展了，我们可以很容易地支持其他的模式，具体列表如下：</p><table><thead><tr><th>含义</th><th>字符</th><th>例子</th><th>对应实现</th></tr></thead><tbody><tr><td>任意的字符 <code>c</code></td><td><code>c</code></td><td><code>c</code> 匹配字符c</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-lit.ts>Lit</a></td></tr><tr><td>任意的单个字符</td><td><code>.</code></td><td><code>.</code> 匹配任意字符</td><td></td></tr><tr><td>匹配开头的字符</td><td><code>^</code></td><td><code>^c</code> 匹配以 <code>c</code> 开头的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-start.ts>Start</a></td></tr><tr><td>匹配结尾的字符</td><td><code>$</code></td><td><code>c$</code> 匹配以 <code>c</code> 结尾的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-end.ts>End</a></td></tr><tr><td>匹配零个或多个的字符</td><td><code>*</code></td><td><code>a*</code> 匹配0-任意个a的字符串, 贪婪匹配</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-any.ts>GreedyAny</a></td></tr><tr><td>匹配零个或多个的字符</td><td><code>*</code></td><td><code>a*</code> 匹配0-任意个a的字符串, 惰性匹配</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-lazy-any.ts>LazyAny</a></td></tr><tr><td>匹配一个或多个的字符</td><td><code>+</code></td><td><code>a+</code> 匹配1-任意个a的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-plus.ts>Plus</a></td></tr><tr><td>匹配零个或一个的字符</td><td><code>?</code></td><td><code>a?</code> 匹配0-1个a的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-opt.ts>Opt</a></td></tr><tr><td>多选一匹配</td><td><code>❘</code></td><td><code>a❘b</code> 匹配a或b的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-alt.ts>Alt</a></td></tr><tr><td>序列匹配</td><td><code>()</code></td><td><code>(ab)</code> 匹配 ab 的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-group.ts>Group</a></td></tr><tr><td>匹配方括号内的任意单个字符</td><td><code>[]</code></td><td><code>[abcd]</code> 匹配a或b或c或d的字符串</td><td><a href=https://github.com/ramsayleung/reinvent/blob/master/regular_expression/regex-charclass.ts>CharClass</a></td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>describe</span><span class=p>(</span><span class=s1>&#39;Regex testsuite&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>it</span><span class=p>.</span><span class=nx>each</span><span class=p>([</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=s1>&#39;ba&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;ab&#39;</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;^a&#39;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Start</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;^b&#39;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Start</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a$&#39;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>End</span><span class=p>())],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a$&#39;</span><span class=p>,</span> <span class=s1>&#39;ba&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>End</span><span class=p>())],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a*&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a*&#39;</span><span class=p>,</span> <span class=s1>&#39;baac&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;ac&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;acc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;abc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;abbbc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;abxc&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;ac&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>LazyAny</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*c&#39;</span><span class=p>,</span> <span class=s1>&#39;acc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>LazyAny</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab*&#39;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>LazyAny</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab+c&#39;</span><span class=p>,</span> <span class=s1>&#39;ac&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Plus</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab+c&#39;</span><span class=p>,</span> <span class=s1>&#39;abc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Plus</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a(b|c)d&#39;</span><span class=p>,</span> <span class=s1>&#39;xabdy&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Alt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;a(b|c)d&#39;</span><span class=p>,</span> <span class=s1>&#39;xabady&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Alt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab?c&#39;</span><span class=p>,</span> <span class=s1>&#39;abc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Opt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab?c&#39;</span><span class=p>,</span> <span class=s1>&#39;acc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Opt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s1>&#39;ab?c&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Opt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s2>&#34;[abcd]&#34;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>CharClass</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)])],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s2>&#34;[abcd]&#34;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>CharClass</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)])],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s2>&#34;[abcd]&#34;</span><span class=p>,</span> <span class=s1>&#39;xhy&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>CharClass</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)])],</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=s2>&#34;c[abcd]&#34;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=nx>CharClass</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)]))],</span>
</span></span><span class=line><span class=cl>    <span class=p>])(</span><span class=s1>&#39;Regex base test (&#34;%s&#34; &#34;%s&#34; &#34;%p&#34;)&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>_pattern</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>expected</span><span class=p>,</span> <span class=nx>matcher</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>actual</span> <span class=o>=</span> <span class=nx>matcher</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=nx>expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>顺便一提的是，这种相同的验证逻辑, 但是输入多个不同的参数以验证不同case的做法，叫做 <code>Parameterized Test</code></p><p>我在《<a href=https://ramsayleung.github.io/zh/categories/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6/>测试技能进阶系列</a>》的第二篇也曾经介绍过： <a href=https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%BA%8C_parameterized_tests/>Parameterized Tests</a></p><p>这样我们就完成了一个功能较完整的正则表达式引擎了。</p><h2 id=表达式解析><span class=section-num>5</span> 表达式解析<a hidden class=anchor aria-hidden=true href=#表达式解析>#</a></h2><p>虽然我们已经完成了一个正则表达式引擎，只不过我们平时用表达式是 <code>a*bc</code> ，现在要写成 <code>Any(Lit('a'), Lib('b', Lib('c')))</code> 多个类的实例也太烦琐了。</p><p>让我们再来分析下正则表达式，以 <code>^(a|b|$)*z$</code> 为例，以任意数量的 <code>a</code>, <code>b</code>, 或 <code>$</code> 开头, 再紧接一个 <code>z</code>, 然后结束。</p><p>我们可以创建一个树来表达这个表达式:</p><figure><input type=checkbox id=zoomCheck-4379e hidden>
<label for=zoomCheck-4379e><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_regex_express_as_tree.jpg></label></figure><p>在考虑如何把表达式变成上面那棵树之前，我们可以先从最简单的步骤开始：分割字符串</p><p>正如物理学家给不可再分的元素称之为「原子」(atom), 计算机科学家也给不可再分割的文本起了一个名字，称之为 <strong>token</strong>, 类似 <code>a</code>, <code>b</code>, <code>$</code>, <code>*</code> 这些都是 token，而把文本切分成 token 的过程，即为 <em>tokenize</em> 。</p><p>不同的token可能代表不同的含义，像 <code>a</code>, <code>b</code>, <code>c</code> 这类，所以它们的值不同，但是它们都可以被称为字面量(Literal), 而像 <code>*</code>, <code>+</code>, <code>|</code>, <code>(</code>, <code>)</code> 这样的字符又各种其代表的含义, 如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>SYMBOL_TOKEN_TYPE_MAP</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;*&#39;</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Any</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;|&#39;</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Alt</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;(&#39;</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>GroupStart</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;)&#39;</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>GroupEnd</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>定义好 token 类型之后， <code>tokenize</code> 跃然纸上了：</p><p>直接按照字符作匹配，如果能匹配上的就是特殊类型的 <code>Token</code> ，不然就是字面量:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=kr>interface</span> <span class=nx>Token</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>location</span><span class=o>:</span> <span class=nx>number</span>
</span></span><span class=line><span class=cl>  <span class=nx>value</span><span class=o>?:</span> <span class=nx>string</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kr>const</span> <span class=nx>tokenize</span> <span class=o>=</span> <span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>result</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[]</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>text</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>c</span> <span class=o>=</span> <span class=nx>text</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>c</span> <span class=k>in</span> <span class=nx>SIMPLE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>({</span> <span class=nx>kind</span><span class=o>:</span> <span class=nx>SIMPLE</span><span class=p>[</span><span class=nx>c</span><span class=p>],</span> <span class=nx>location</span><span class=o>:</span> <span class=nx>i</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=nx>c</span> <span class=o>===</span> <span class=s1>&#39;^&#39;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>i</span> <span class=o>===</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>({</span> <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Start</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=nx>i</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>((</span><span class=nx>c</span> <span class=o>===</span> <span class=s1>&#39;$&#39;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>i</span> <span class=o>===</span> <span class=p>(</span><span class=nx>text</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>({</span> <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>End</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=nx>i</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>({</span> <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Lit</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=nx>c</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>^(a|b|$)*z$</code> 就会被解析成如下的结果:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Start&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;GroupStart&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Lit&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;value&#34;</span><span class=o>:</span> <span class=s2>&#34;a&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Alt&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Lit&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;value&#34;</span><span class=o>:</span> <span class=s2>&#34;b&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Alt&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Lit&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>6</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;value&#34;</span><span class=o>:</span> <span class=s2>&#34;$&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;GroupEnd&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Any&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;Lit&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>9</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;value&#34;</span><span class=o>:</span> <span class=s2>&#34;z&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;kind&#34;</span><span class=o>:</span> <span class=s2>&#34;End&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;location&#34;</span><span class=o>:</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=组装抽象语法树><span class=section-num>6</span> 组装抽象语法树<a hidden class=anchor aria-hidden=true href=#组装抽象语法树>#</a></h2><p><code>tokenize</code> 的结果是一个包含 Token 的列表，我们要如何组装成树状数据结构呢？</p><p>顺带一提，这树状数据结构全称是抽象语法树(Abstract syntax tree, AST), 是一种用来表示程序结构的数据结构，如:</p><figure><input type=checkbox id=zoomCheck-7b55c hidden>
<label for=zoomCheck-7b55c><img class=zoomCheck loading=lazy src=/ox-hugo/Abstract_syntax_tree_for_Euclidean_algorithm.svg.png></label></figure><p>我们可以分情况来讨论，因为不同的模式有不同的组装方式，组装完之后的 AST 的输出是一个 <code>output</code>, 包含组装后的 <code>token</code> 列表:</p><p>对于表达式 <code>a</code>, 我们可以创建一个 <code>Lit</code> 类型的 <code>token</code> (为了便于理解，「创建」指创建一个 <code>token</code>, 然后插入到 <code>output</code>.)</p><p>对于表达式 <code>a*</code> 呢？我们可以先创建一个 <code>Lit('a')</code> 的 <code>token</code>, 当遇到 <code>*</code> 时，因为 <code>*</code> 表示匹配0至任意的前一个字符, 所以我们可以创建一个 <code>Any</code> 类型的 token, 然后把 <code>output</code> 最后一个元素 <code>pop</code> 出来，作为 <code>Any</code> 的 <code>child</code> 元素.</p><figure><input type=checkbox id=zoomCheck-63031 hidden>
<label for=zoomCheck-63031><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_regex_construct_ast_any.jpg></label></figure><p>对于表达式 <code>(ab)</code>, 情况就变得复杂一些:
当遇到 <code>(</code> 括号的时候，我们可以创建一个 <code>Group</code> ，但是问题在于，我们不知道这个 <code>Group</code> 什么时候结束，即不知道什么时候才会遇上 <code>)</code>.</p><p>所以我们需要换种解决思路：当遇到 <code>(</code>, 创建一个 <code>GroupStart</code> 类型的 <code>token</code>, 然后再继续处理 <code>a</code>, <code>b</code>, 当遇到 <code>)</code> 时，创建一个 <code>Group</code> 类型的 <code>token</code>, 然后一直调用 <code>pop</code> 函数直到把 <code>GroupStart</code> 也 <code>pop</code> 出来, 然后把过程中 <code>pop</code> 出来的 <code>token</code> 都当作是 <code>Group</code> 的 <code>children</code> 列表，而 <code>GroupStart</code> 相当于起到一个标记符的作用。</p><p>这种思路就自动处理了 <code>(a*)</code> 和 <code>(a(b*)c)</code> 的差异:</p><figure><input type=checkbox id=zoomCheck-49c57 hidden>
<label for=zoomCheck-49c57><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_regex_ast_group.jpg></label></figure><p>对于表达式 <code>a|b</code>, 我们是否可以参考 <code>Any</code> 的做法呢?</p><p>遇到 <code>a</code> 的时候先创建一个 <code>Lit('a')</code>, 遇到 <code>|</code> 时再创建一个 <code>Alt</code>, 然后把 <code>Lit('a')</code> 从 <code>output</code> pop 出来作为 <code>left</code> 节点， 再遇到下一个字符 <code>b</code> 的时候，再把 <code>Alt</code> 从 output pop 出来，把 <code>b</code> 作为 <code>right</code> 节点。</p><p>听起来没问题，但是上面的算法无法正确解析 <code>a|b*</code>, 它表示匹配一个 <code>a</code> 或者是任意数量的 <code>b</code>, 但是我们的做法会把它解析成 <code>(a|b)*</code>, 即任意数量的 <code>a</code> 或 <code>b</code>.</p><p>更合理的做法是先部分组装 Alt 的 <code>left</code> 节点，等解析完所有字符之后，再重新解析一次，把 <code>right</code> 节点给组装上。</p><p>以 <code>a|b*</code> 为例子:</p><ol><li>创建一个 <code>Lit('a')</code> token</li><li>当遇到 <code>|</code> 的时候，创建一个 <code>Alt</code>, 并将 <code>Lit('a')</code> pop 出来作为 <code>left</code> 节点</li><li>创建一个 <code>Lit('b')</code> token</li><li>创建一个 <code>Any</code> token, 并将 <code>Lit('b')</code> pop 出来作为 <code>child</code> 节点.</li><li>当解析完所有字符后, 再遍历一次 <code>output</code>, 如果遇到 <code>Alt</code> token, 那么就把它的下一个 <code>token</code> (即 <code>Any</code>) 作为它的 <code>right</code> 节点.</li></ol><figure><input type=checkbox id=zoomCheck-11542 hidden>
<label for=zoomCheck-11542><img class=zoomCheck loading=lazy src=/ox-hugo/reinvent_regex_ast_alt.jpg></label></figure><p>实现代码如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=kr>const</span> <span class=nx>parse</span> <span class=o>=</span> <span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>result</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[]</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>allTokens</span> <span class=o>=</span> <span class=nx>tokenize</span><span class=p>(</span><span class=nx>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>allTokens</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=nx>allTokens</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>isLast</span> <span class=o>=</span> <span class=nx>i</span> <span class=o>===</span> <span class=nx>allTokens</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>handle</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>token</span><span class=p>,</span> <span class=nx>isLast</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>compress</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>handle</span> <span class=o>=</span> <span class=p>(</span><span class=nx>result</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[],</span> <span class=nx>token</span><span class=o>:</span> <span class=nx>Token</span><span class=p>,</span> <span class=nx>isLast</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Lit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Start</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>length</span> <span class=o>===</span> <span class=mi>0</span><span class=p>,</span> <span class=s1>&#39;Should not have start token after other tokens&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>End</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=nx>isLast</span><span class=p>,</span> <span class=sb>`Should not have end token before other tokens`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>GroupStart</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>GroupEnd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>groupEnd</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>token</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=sb>`No Operand for &#39;*&#39; (location </span><span class=si>${</span><span class=nx>token</span><span class=p>.</span><span class=nx>location</span><span class=si>}</span><span class=sb>)`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>token</span><span class=p>.</span><span class=nx>child</span> <span class=o>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>token</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Alt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=sb>`No Operand for &#39;|&#39; (location </span><span class=si>${</span><span class=nx>token</span><span class=p>.</span><span class=nx>location</span><span class=si>}</span><span class=sb>)`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>token</span><span class=p>.</span><span class=nx>left</span> <span class=o>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>token</span><span class=p>.</span><span class=nx>right</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>token</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=sb>`UNIMPLEMENTED`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>groupEnd</span> <span class=o>=</span> <span class=p>(</span><span class=nx>result</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[],</span> <span class=nx>token</span><span class=o>:</span> <span class=nx>Token</span><span class=p>)</span><span class=o>:</span> <span class=nx>Token</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>group</span><span class=o>:</span> <span class=nx>Token</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Group</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>location</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>end</span><span class=o>:</span> <span class=nx>token</span><span class=p>.</span><span class=nx>location</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>children</span><span class=o>:</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=sb>`Unmatched end parenthesis (location </span><span class=si>${</span><span class=nx>token</span><span class=p>.</span><span class=nx>location</span><span class=si>}</span><span class=sb>)`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>child</span> <span class=o>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>child</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>GroupStart</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>group</span><span class=p>.</span><span class=nx>location</span> <span class=o>=</span> <span class=nx>child</span><span class=p>.</span><span class=nx>location</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>group</span><span class=p>.</span><span class=nx>children</span><span class=p>.</span><span class=nx>unshift</span><span class=p>(</span><span class=nx>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>group</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// go through the output list to fill in the right side of Alts:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>compress</span> <span class=o>=</span> <span class=p>(</span><span class=nx>raw</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[])</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>cooked</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[]</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nx>raw</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=nx>raw</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Alt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>assert</span><span class=p>(</span><span class=nx>cooked</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=sb>`No right operand for alt (location </span><span class=si>${</span><span class=nx>token</span><span class=p>.</span><span class=nx>location</span><span class=si>}</span><span class=sb>)`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nx>token</span><span class=p>.</span><span class=nx>right</span> <span class=o>=</span> <span class=nx>cooked</span><span class=p>.</span><span class=nx>shift</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cooked</span><span class=p>.</span><span class=nx>unshift</span><span class=p>(</span><span class=nx>token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>cooked</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对于表达式 <code>a|(bc)</code>, 输出的 AST 如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Alt</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>left</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Lit</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=s1>&#39;a&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nx>right</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Group</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>end</span><span class=o>:</span> <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>children</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Lit</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=mi>3</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=s1>&#39;b&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=nx>kind</span><span class=o>:</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Lit</span><span class=p>,</span> <span class=nx>location</span><span class=o>:</span> <span class=mi>4</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=s1>&#39;c&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=实例化><span class=section-num>7</span> 实例化<a hidden class=anchor aria-hidden=true href=#实例化>#</a></h2><p>既然抽象语法树 AST 已经就绪了，我们就差最后一步了，把 AST 转变为我们的类实例.</p><p>还记得上文提到过, 不同的模式对应不同的类，然后通过 <code>rest</code> 指针指向下一个模式类，以此串成一个链表。</p><p>那么我们对于 <code>output</code> 这个包含多个 token 的列表，我们可以抽象成两个 token, 当前 token 和下一个 token:</p><p>假如我们有函数 <code>f</code> 可以把当前 <code>token</code> 初始化对应的模式类，我们只需要再把剩下的 token 列表初始化成 <code>rest</code>, 那么 <code>rest</code> 要怎么初始化呢？</p><p>只需要再调用 <code>f</code> 即可.</p><p>这不就是递归嘛! 是的，通过递归就很简单地把实例化也实现出来了:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>export</span> <span class=kr>const</span> <span class=nx>compile</span> <span class=o>=</span> <span class=p>(</span><span class=nx>text</span><span class=o>:</span> <span class=nx>string</span><span class=p>)</span><span class=o>:</span> <span class=nx>RegexBase</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>tokens</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[]</span> <span class=o>=</span> <span class=nx>parse</span><span class=p>(</span><span class=nx>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>createObjectByAST</span><span class=p>(</span><span class=nx>tokens</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// return instances of classes derived from RegexBase by abstract syntax tree
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>createObjectByAST</span> <span class=o>=</span> <span class=p>(</span><span class=nx>tokens</span><span class=o>:</span> <span class=nx>Token</span><span class=p>[])</span><span class=o>:</span> <span class=nx>RegexBase</span> <span class=o>|</span> <span class=kc>null</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>tokens</span><span class=p>.</span><span class=nx>length</span> <span class=o>===</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=nx>tokens</span><span class=p>.</span><span class=nx>shift</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Lit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>Lit</span><span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>value</span><span class=p>,</span> <span class=nx>createObjectByAST</span><span class=p>(</span><span class=nx>tokens</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Start</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>Start</span><span class=p>(</span><span class=nx>createObjectByAST</span><span class=p>(</span><span class=nx>tokens</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>End</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=nx>tokens</span><span class=p>.</span><span class=nx>length</span> <span class=o>===</span> <span class=mi>0</span><span class=p>,</span> <span class=sb>`Should not have end token before other tokens`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>End</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Alt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>Alt</span><span class=p>(</span><span class=nx>createObjectByAST</span><span class=p>([</span><span class=nx>token</span><span class=p>.</span><span class=nx>left</span><span class=p>]),</span> <span class=nx>createObjectByAST</span><span class=p>([</span><span class=nx>token</span><span class=p>.</span><span class=nx>right</span><span class=p>]),</span> <span class=nx>createObjectByAST</span><span class=p>(</span><span class=nx>tokens</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>Group</span><span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>children</span><span class=p>.</span><span class=nx>map</span><span class=p>((</span><span class=nx>childToken</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>createObjectByAST</span><span class=p>([</span><span class=nx>childToken</span><span class=p>])),</span> <span class=nx>createObjectByAST</span><span class=p>(</span><span class=nx>tokens</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span> <span class=o>===</span> <span class=nx>TokenKind</span><span class=p>.</span><span class=nx>Any</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>createObjectByAST</span><span class=p>([</span><span class=nx>token</span><span class=p>.</span><span class=nx>child</span><span class=p>]),</span> <span class=nx>createObjectByAST</span><span class=p>(</span><span class=nx>tokens</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>assert</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span> <span class=sb>`UNKNOWN token type </span><span class=si>${</span><span class=nx>token</span><span class=p>.</span><span class=nx>kind</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=总结><span class=section-num>8</span> 总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>it</span><span class=p>.</span><span class=nx>each</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;^a&#39;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Start</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;a$&#39;</span><span class=p>,</span> <span class=s1>&#39;ab&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>End</span><span class=p>())],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;a*&#39;</span><span class=p>,</span> <span class=s1>&#39;baac&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Any</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;ab+c&#39;</span><span class=p>,</span> <span class=s1>&#39;abc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Plus</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;ab+c&#39;</span><span class=p>,</span> <span class=s1>&#39;abxc&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Plus</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;(ab)|(cd)&#39;</span><span class=p>,</span> <span class=s1>&#39;xaby&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Alt</span><span class=p>(</span><span class=nx>Group</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>)]),</span> <span class=nx>Group</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)]))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;a(b|c)d&#39;</span><span class=p>,</span> <span class=s1>&#39;xabdy&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Group</span><span class=p>([</span><span class=nx>Alt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>))],</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;ab?c&#39;</span><span class=p>,</span> <span class=s1>&#39;ac&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Opt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s1>&#39;ab?c&#39;</span><span class=p>,</span> <span class=s1>&#39;acc&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=nx>Opt</span><span class=p>(</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>)))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s2>&#34;[abcd]c&#34;</span><span class=p>,</span> <span class=s1>&#39;ac&#39;</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>CharClass</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)],</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>))],</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=s2>&#34;c[abcd]&#34;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=nx>CharClass</span><span class=p>([</span><span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;b&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>),</span> <span class=nx>Lit</span><span class=p>(</span><span class=s1>&#39;d&#39;</span><span class=p>)]))],</span>
</span></span><span class=line><span class=cl><span class=p>])(</span><span class=s1>&#39;parse, compile and matcher test (&#34;%s&#34; &#34;%s&#34; &#34;%p&#34;)&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=nx>text</span><span class=p>,</span> <span class=nx>expected</span><span class=p>,</span> <span class=nx>expectedMatcher</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>actualMatcher</span> <span class=o>=</span> <span class=nx>compile</span><span class=p>(</span><span class=nx>pattern</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>actualMatcher</span><span class=p>).</span><span class=nx>toStrictEqual</span><span class=p>(</span><span class=nx>expectedMatcher</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>actual</span> <span class=o>=</span> <span class=nx>actualMatcher</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=nx>expected</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>大功告成，终于将所有的功能都组装起来实现这个正则表达式引擎了, 除去前文提到的功能之外，还实现了 <code>\*</code> 转义特殊字符， <code>[xya]</code> 匹配 <code>x</code>, <code>y</code>, <code>z</code> 其中任意字符，以及 <code>*?</code> 实现惰性匹配的功能。</p><p>完整功能集的测试 case 可见 <a href=https://github.com/ramsayleung/reinvent/blob/master/__tests__/regular_expression/parser-test.ts>parser_test.ts</a></p><p>日常使用正则表达式的场景非常多，因为其强大的功能和表达能力，总会下意识觉得很难实现（当然，高性能的完整版本的确是非常有挑战性的）。</p><p>但是当自己把正则表达式引擎这个轮子拆开，再重新造一个出来之后，才感悟到：</p><p>「没有启程的路才会遥不可及」，很多时候，困难只是我们给自己设下的心理障碍。</p><p><a href=/zh/post/2025/reinvent_project/>回到本系列的目录</a></p><h2 id=参考><span class=section-num>9</span> 参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Stephen_Cole_Kleene>https://en.wikipedia.org/wiki/Stephen_Cole_Kleene</a></li><li><a href=https://en.wikipedia.org/wiki/Ed_(software)>https://en.wikipedia.org/wiki/Ed_(software)</a></li><li><a href=https://en.wikipedia.org/wiki/Grep>https://en.wikipedia.org/wiki/Grep</a></li><li><a href=https://third-bit.com/sdxjs/regex-parser/>https://third-bit.com/sdxjs/regex-parser/</a></li><li><a href=https://third-bit.com/sdxjs/pattern-matching/>https://third-bit.com/sdxjs/pattern-matching/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://ramsayleung.github.io/zh/tags/reinvent/>reinvent</a></li></ul><nav class=paginav><a class=prev href=https://ramsayleung.github.io/zh/post/2025/%E8%BF%87%E6%B2%B3%E5%8D%92/><span class=title>« 上一页</span><br><span>《过河卒》: 比特币雏形之父之父的故事</span>
</a><a class=next href=https://ramsayleung.github.io/zh/post/2025/reinvent_selector/><span class=title>下一页 »</span><br><span>重新造轮子系列(三): HTML Selector</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on x" href="https://x.com/intent/tweet/?text=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f&amp;hashtags=reinvent"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f&amp;title=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e&amp;summary=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e&amp;source=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f&title=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e%20-%20https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on telegram" href="https://telegram.me/share/url?text=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e&amp;url=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 重新造轮子系列(四)：正则表达式引擎 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e9%87%8d%e6%96%b0%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e5%9b%9b%29%ef%bc%9a%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%bc%95%e6%93%8e&u=https%3a%2f%2framsayleung.github.io%2fzh%2fpost%2f2025%2freinvent_regex%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><section><h2>Comments</h2><div id=comments-giscus></div></section><script type=text/javascript>function getCurrentTheme(){return document.documentElement.getAttribute("data-theme")||document.body.classList.contains("dark")?"dark":"light"}function setGiscusTheme(e=!1){const s=e?"dark":"light";var n,t=document.querySelector(".giscus-frame");t&&(n=new URL(t.src),n.searchParams.set("theme",s),t.src=n.toString())}function loadComment(e=!1){const n="zh"=="zh",t=document.getElementById("comments-giscus");if(t!==null&&!t.hasAttribute("data-giscus-loaded")){console.log("Initial giscus load");const s=document.createElement("script");s.setAttribute("src","https://giscus.app/client.js"),s.setAttribute("data-repo","ramsayleung/comment"),s.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnkzMDk2NjQ1NDk="),s.setAttribute("data-category","General"),s.setAttribute("data-category-id","DIC_kwDOEnUbJc4Cltnz"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",e?"dark":"light"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("data-lang",n?"zh-CN":"en"),s.setAttribute("async","true"),t.appendChild(s),t.setAttribute("data-giscus-loaded","true")}}let currentTheme=getCurrentTheme();loadComment(currentTheme==="dark");const themeObserver=new MutationObserver(e=>{e.forEach(e=>{if(e.type==="attributes"&&e.attributeName==="class"){const e=getCurrentTheme();e!==currentTheme&&(currentTheme=e,setGiscusTheme(currentTheme==="dark"))}})});themeObserver.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script></article></main><footer class=footer><span>See this site&rsquo;s source code <a href=https://github.com/ramsayleung/ramsayleung.github.io>here</a>, licensed under GPLv3 ·</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>