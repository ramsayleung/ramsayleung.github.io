<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>java on 自由庄园</title>
    <link>https://ramsayleung.github.io/zh/tags/java/</link>
    <description>Recent content in java on 自由庄园</description>
    <image>
      <title>自由庄园</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>See this site&#39;s source code [here](https://github.com/ramsayleung/ramsayleung.github.io), licensed under GPLv3 ·</copyright>
    <lastBuildDate>Sun, 05 Jul 2020 16:51:00 +0800</lastBuildDate><atom:link href="https://ramsayleung.github.io/zh/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java8基于堆实现尾递归优化</title>
      <link>https://ramsayleung.github.io/zh/post/2020/java%E5%AE%9E%E7%8E%B0%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 05 Jul 2020 16:51:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2020/java%E5%AE%9E%E7%8E%B0%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/</guid>
      <description>1 前言 尾调用消除(tail call elimination, TCE)是函数式编程的重要概念, 有时也被称为尾调用优化(tail call optimization, TCO), 作用是将尾递归函数转化成循环, 避免创建许</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>尾调用消除(tail call elimination, TCE)是函数式编程的重要概念, 有时也被称为尾调用优化(tail call optimization, TCO),
作用是将尾递归函数转化成循环, 避免创建许多栈帧, 减少开销.</p>
<p>遗憾的是, Java不支持TCE, 所以本文主要是介绍, 如何使用java8特性, 基于堆来实现尾递归优化.</p>
<hr>
<p>一个有趣的事，这篇文章是我在阿里ATA上发的最后一篇文章。发在内网的第二天，也就是我的last day，有位P8的同事在钉钉上夸我文章写得好，只回复了一句，还未来得及多交流几句，我的离职流程就走完，钉钉被强制下线了，甚至没看到这位同事的回复。</p>
<h2 id="尾调用与尾递归"><span class="section-num">2</span> 尾调用与尾递归</h2>
<p>想要了解尾递归优化, 首先要了解下什么是尾调用.</p>
<p>尾调用的概念非常简单,
一言以蔽之, 指函数的最后一步是调用另一个函数. 以斐波那契数列为例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">fac</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽说上面的函数看起来像是尾调用函数, 但实际上它只是普通的递归函数,
因为它最后一步不是调用函数, 它只是作了加法计算, 上面的逻辑等同于:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">fac</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">fac</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">accumulator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>既然调用 <code>fac(n-1)</code>函数的目的是为了获取累加值,
那么我们自然将累加值抽出来,
然后把上面的斐波那契数列函数改成尾调用函数呢:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">fac</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">facTailCall</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">facTailCall</span><span class="o">(</span><span class="kt">int</span> <span class="n">accumulator</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">accumulator</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">facTailCall</span><span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">accumulator</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数调用自身, 称为递归函数. 如果尾调用函数自身, 就称为尾递归函数.
那尾递归函数有什么用呢? 仅仅是将斐波那契数列的累加值抽了出来么?</p>
<p>要回答这个问题, 让我们先把目光投回到递归版本的斐波那契数列, 当调用
<code>fac(6)</code>时发生了什么事情:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="mi">6</span> <span class="o">*</span> <span class="n">fac</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="mi">6</span> <span class="o">*</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">fac</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="mi">6</span> <span class="o">*</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">fac</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// N次展开之后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="mi">6</span> <span class="o">*</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="o">(</span><span class="mi">3</span> <span class="o">*</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">1</span><span class="o">)))))</span> <span class="c1">// &lt;= 最终的展开
</span></span></span><span class="line"><span class="cl"><span class="c1">// 到这里为止, 程序做的仅仅还只是展开而已, 并没有运算真正运运算, 接下来才是运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="mi">6</span> <span class="o">*</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="o">(</span><span class="mi">3</span> <span class="o">*</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">    <span class="mi">6</span> <span class="o">*</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="o">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">    <span class="mi">6</span> <span class="o">*</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">6</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="c1">// N次调用之后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="mi">720</span> <span class="c1">// &lt;= 最终的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">fac</span><span class="o">(</span><span class="mi">10000</span><span class="o">)</span> <span class="c1">// =&gt; java.lang.StackOverflowError
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的例子可以看出, 普通递归的问题在于展开的时候会需要非常大的空间,
这些空间指的就是函数调用的栈帧, 每一次递归的调用都需要创建新的栈帧,
递归调用有对应的深度限制, 这个限制就是栈的大小.</p>
<p>默认栈空间从32kb到1024kb不等, 具体取决于Java版本和所用的系统,
对于64位的java8程序而言, 递归的最大次数约为8000.</p>
<p>我们也没法通过增加栈的大小来增加递归的次数,
栈的大小相当于是一个全局配置, 所有的线程都会使用相同的栈,
增加栈的大小只是浪费资源而言.</p>
<p>那有没有方法可以避免上述的 <code>StackOverflowError</code> 呢? 那当然是有的,
答案就是上文提到的尾递归.</p>
<p>让我们来观察下尾递归版本的斐波那契数列, 看看调用 <code>facTailCall(1, 6)</code> 会发生什么事情?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">facTailCall</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="c1">// 1 是 fac(0) 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">facTailCall</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">facTailCall</span><span class="o">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">facTailCall</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">facTailCall</span><span class="o">(</span><span class="mi">360</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">facTailCall</span><span class="o">(</span><span class="mi">720</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="mi">720</span> <span class="c1">// &lt;= 最终的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">facTailCall</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">15000</span><span class="o">)</span> <span class="c1">// java.lang.StackOverflowError
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>与上方的普通递归函数相比, 尾递归函数在展开的过程中计算并且缓存了结果,
使得并不会像普通递归函数那样展开出非常庞大的中间结果,
<strong>但是尾递归函数还是递归函数, 如果不作尾递归优化(TCO), 依然会出现
StackOverflowError</strong>.</p>
<p>所谓的尾递归优化, 可以简单理解成将尾递归函数优化成循环; 在函数式编程中,
是鼓励大家使用递归, 而不是循环来解决问题.</p>
<p>这是因为循环会引入变量, 而变量是函数式编程中被视为洪水猛兽一样的存在.</p>
<p>但如果递归调用的深度比较大, 栈帧会开辟很多, 一来是浪费空间,
二来性能也必然会下降(有很多读写内存操作);</p>
<p>相反, 如果使用循环, 则只在一个函数栈空间里, 不会开辟更多的空间, 所以使用循环,
性能要好于递归.</p>
<p>所以在函数式编程语言中, 如Scheme, Haskell, Scala, 尾递归优化是标配, 所以不会出现 <strong>StackOverflowError</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">fact</span> <span class="nv">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">define</span> <span class="p">(</span><span class="nv">fact-tail</span> <span class="nv">x</span> <span class="nv">accum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">accum</span>
</span></span><span class="line"><span class="cl">	    <span class="p">(</span><span class="nv">fact-tail</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="nv">accum</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">fact-tail</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">fact</span> <span class="mi">1000000</span><span class="p">)</span><span class="o">,</span>  <span class="c1">;;; 返回一个很大很大的数, 使用的空间与(fact 3)相当</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>遗憾的是, Java并不支持尾递归优化.</p>
<h2 id="基于堆的尾递归"><span class="section-num">3</span> 基于堆的尾递归</h2>
<p>尾递归优化的一大用处是维持常数级空间, 保证不会爆栈.</p>
<p>既然爆栈的原因是栈空间不足, 又无法扩大栈的空间,
那么只能把函数存在其他地方, 比如堆(heap). 使用堆来抽象递归,
那么需要做的事情如下:</p>
<ol>
<li>表示一个函数的调用</li>
<li>把函数调用存储在栈式结构中, 直到条件终止</li>
<li>以后进先出(LIFO)的顺序调用函数</li>
</ol>
<p>为此我们可以定义一个名为<code>TailCall</code>的抽象类, 它有两个子类:
其一表示挂起一个函数以再次调用该函数对下一步求值, 如下,
先暂停<code>f()</code>的调用, 先调用出<code>g()</code>的结果, 再对<code>f()</code>进行求值,
此子类名为<code>Suspend</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">g</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而一个函数的调用可以通过java8引入的<code>Supplier&lt;T&gt;</code>类来表示,
以此来存储函数, T为TailCall, 表示下一个递归调用.</p>
<p>这样一来, 就可以通过每个尾调用引用下一个调用的方式来构造一个隐式链表,
完成栈式数据结构存储的要求.</p>
<p>另一个子类表示返回一个调用, 它应该返回结果,
不会持有到一个TailCall的引用, 因为已经没有下一个TailCall了,
所以其名为<code>Return</code>.</p>
<p>其外, 还需要几个额外的抽象方法: 返回一个调用,
返回结果, 以及判断是否判断<code>TailCall</code>是<code>Suspend</code>还是<code>Result</code>,
接口及子类实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author Ramsay/Ramsayleung@gmail.com
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Create on 7/5/20
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">resume</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">eval</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">isSuspend</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Return</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">t</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="nf">Return</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">resume</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;Return has no more TailCall&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">T</span> <span class="nf">eval</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSuspend</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Suppend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">final</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">resume</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="nf">Suppend</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">resume</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">this</span><span class="o">.</span><span class="na">resume</span> <span class="o">=</span> <span class="n">resume</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">resume</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="n">resume</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">T</span> <span class="nf">eval</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">tailCall</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	    <span class="k">while</span> <span class="o">(</span><span class="n">tailCall</span><span class="o">.</span><span class="na">isSuspend</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">tailCall</span> <span class="o">=</span> <span class="n">tailCall</span><span class="o">.</span><span class="na">resume</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="n">tailCall</span><span class="o">.</span><span class="na">eval</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSuspend</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Return</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">tReturn</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">new</span> <span class="n">Return</span><span class="o">&lt;&gt;(</span><span class="n">t</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Suppend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">suppend</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">TailCall</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">supplier</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">new</span> <span class="n">Suppend</span><span class="o">&lt;&gt;(</span><span class="n">supplier</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Return</code>并没有实现<code>resume</code>方法, 只是简单地抛出了异常, 因为前文提到过,
<code>Return</code>表示最后一个调用, 没有下一个调用了, 自然无法实现<code>resume</code>方法;</p>
<p>同理, 只要不是最后一个调用, 就没法实现<code>eval()</code>方法,
因为最后的一个调用才能返回结果.</p>
<p>那为啥<code>Suspend</code>还实现了<code>eval</code>方法呢? 主要是不让用户感知函数调用并返回结果的逻辑, 将其内敛到<code>Suspend</code>内.
现在让我们来看看效果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @author Ramsay/Ramsayleung@gmail.com
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Create on 7/5/20
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TailCallTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 尾递归版本斐波那契数列
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">fac</span><span class="o">(</span><span class="kt">int</span> <span class="n">accumulator</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">facTailCall</span><span class="o">(</span><span class="n">accumulator</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">eval</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">facTailCall</span><span class="o">(</span><span class="kt">int</span> <span class="n">accumulator</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="n">TailCall</span><span class="o">.</span><span class="na">tReturn</span><span class="o">(</span><span class="n">accumulator</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">TailCall</span><span class="o">.</span><span class="na">suppend</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">facTailCall</span><span class="o">(</span><span class="n">accumulator</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 递归版本的两数相加
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">addRecur</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl">	    <span class="n">addRecur</span><span class="o">(++</span><span class="n">x</span><span class="o">,</span> <span class="o">--</span><span class="n">y</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 尾递归优化版本的两数相加
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">addTCO</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">addTailCall</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).</span><span class="na">eval</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">addTailCall</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">_x_plus_one</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">_y_minus_one</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">TailCall</span><span class="o">.</span><span class="na">tReturn</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl">	    <span class="n">TailCall</span><span class="o">.</span><span class="na">suppend</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">addTailCall</span><span class="o">(</span><span class="n">_x_plus_one</span><span class="o">,</span> <span class="n">_y_minus_one</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addTest</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">addRecur</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// =&gt; 20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">addRecur</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span> <span class="c1">// StackoverFlowError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">addTCO</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">100000</span><span class="o">);</span> <span class="c1">// =&gt; 100003
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">fac</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span> <span class="c1">// =&gt; 720
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">fac</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">600000</span><span class="o">);</span> <span class="c1">// 数字过大溢出, 返回0, 且没有出现 StackOverflowError
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结"><span class="section-num">4</span> 总结</h2>
<p>至此, 我们通过java8的lambda, <code>Supplier</code>接口实现了基于堆的尾递归优化,
虽说没有优化成常数空间, 但终归解决了递归过深时, 栈空间不足导致
<code>StackOverflowError</code>的问题.</p>
<p>而按照<a href="https://stackoverflow.com/questions/53354898/tail-call-optimisation-in-java">Stackoverflow问题的说法</a>, java不支持尾调用的原因如下:</p>
<blockquote>
<p>In jdk classes there are a number of security sensitive methods that
rely on counting stack frames between jdk library code and calling
code to figure out who&rsquo;s calling them.</p>
</blockquote>
<p>后续java版本也暂无支持尾递归优化的计划, 无奈摊手.jpg</p>
<h2 id="参考"><span class="section-num">5</span> 参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a></li>
<li><a href="https://book.douban.com/subject/26981273/">Functional Programming in Java</a></li>
<li><a href="https://youtu.be/4tEi86h8-TM?t=32m30s">NightHacking with Venkat Subramaniam</a></li>
<li><a href="https://stackoverflow.com/questions/43937160/designing-tail-recursion-using-java-8">Designing tail recursion using java 8</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>guava 探究系列之五：新类型容器</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 12 Dec 2019 15:45:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AE%B9%E5%99%A8/</guid>
      <description>1 前言 JDK 提供了各种功能强大的工具类, 宛如装备齐全的军火库, 而容器就是其中一项内置的利器, 提供了包括诸多常用的数据结构, 下图对 JDK 已有容器进行了</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>JDK 提供了各种功能强大的工具类, 宛如装备齐全的军火库,
而容器就是其中一项内置的利器, 提供了包括诸多常用的数据结构, 下图对 JDK
已有容器进行了概括:</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191122171101.png"
         alt="Figure 1: JDK 容器"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>JDK 容器</p>
        </figcaption>
</figure>

<p>不过, 虽然 JDK 的容器类已经五花八门, 琳琅满目, 但是某些很有用的容器类
JDK 依然欠缺, 而 Guava 恰如其分地填补了这些空缺, 开发了 JDK
所欠缺的容器类, &ldquo;造福大众&rdquo;.</p>
<p>此外, 虽然引入了新的容器类, 但 Guava 实现了
JDK 的 <code>Collection</code> 接口, 保证 Guava 的容器类能够与 JDK
的容器类”和谐共处”, 避免不必要的”纷争”.</p>
<h2 id="multiset"><span class="section-num">2</span> Multiset</h2>
<p>假设你是个书店的老板, 你想统计下书店里不同书籍的存货量,
你可能写下这样的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">book</span> <span class="o">:</span> <span class="n">bookNames</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Integer</span> <span class="n">count</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">counts</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">book</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">counts</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">book</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>嗯, 我现在想改需求, 我想知道书店里共有多少本书? 怎么办呢? 把 <code>counts</code> 的
value 都加起来?</p>
<p>对于这样的要求, Guava 提供了一个更好的解决方案: 一个新类型容器
<code>Multiset</code> , 它支持新增多个相同类型的元素并统计. 维基百科给出的关于
<code>Multiset</code>
的<a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">解释</a>:</p>
<blockquote>
<p>这是个成员可以出现多次的集合(Set), 也被称为背包(bag)</p>
</blockquote>
<p>大名鼎鼎的《算法/Algorithm》也给出过 <a href="https://algs4.cs.princeton.edu/13stacks/">bag</a> 的解释和实现.</p>
<p>需要注意的是, <code>multisets</code> 的成员是无序的, <code>{a,a,b}</code> 和 <code>{a,b,a}</code>
这两个集合在 <code>multisets</code> 看来是相等.</p>
<p>我们可以从两个角度来分析 <code>multisets</code> :</p>
<ul>
<li>
<p><code>multisets</code> 就好像一个<code>ArrayList&lt;E&gt;</code>, 只不过是无序的.
当把它当作<code>ArrayList&lt;E&gt;</code>时:</p>
<ul>
<li>调用<code>add(E)</code>函数, 增加给定元素的出现次数</li>
<li>调用<code>iterator()</code>函数, 获取一个 <code>multisets</code> 的迭代器,
用来迭代每个元素</li>
<li>调用<code>size()</code>函数, 获取所有元素出现次数之和</li>
</ul>
</li>
<li>
<p><code>multisets</code> 就好象一个<code>Map&lt;E, Integer&gt;</code>, 包含元素和对应的数量,
只不过数量只能为正数. 当把它当作<code>Map&lt;E, Integer&gt;</code>的时候:</p>
<ul>
<li>调用<code>count(Object)</code>函数获取某个特定元素的出现次数.</li>
<li>调用<code>entrySet()</code>函数返回一个<code>Set&lt;Multiset.Entry&lt;E&gt;&gt;</code>, 大概类似一个
<code>Map</code> 返回 <code>entrySet</code> .</li>
<li>调用 <code>elementSet</code> 函数返回一个<code>Set&lt;E&gt;</code>对象,
返回所有的元素(去掉重复的元素)</li>
</ul>
</li>
</ul>
<h3 id="multiset-的例子"><span class="section-num">2.1</span> Multiset 的例子</h3>
<p>粗略介绍完 <code>Multiset</code> 之后, 现在就让我们用它重新实现原来的需求:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testMultiset</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">String</span> <span class="n">POTTER</span> <span class="o">=</span> <span class="s">&#34;Potter&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Multiset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">bookstore</span> <span class="o">=</span> <span class="n">HashMultiset</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">bookstore</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">POTTER</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bookstore</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">POTTER</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bookstore</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;四体&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">bookstore</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;五体&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">bookstore</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">POTTER</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">bookstore</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="n">POTTER</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">bookstore</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">bookstore</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">POTTER</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">bookstore</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">POTTER</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">bookstore</span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="n">POTTER</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>multisets</code> 完美满足了我们的需求.</p>
<h3 id="multiset-并不是一个-map"><span class="section-num">2.2</span> Multiset 并不是一个 Map</h3>
<p>需要注意的是, <code>Multiset</code> 虽然与<code>Map&lt;E, Integer&gt;</code>类似, 但 <code>Multiset</code>
并不是一个<code>Map&lt;E, Integer&gt;</code>, 请不要混淆它们两个.</p>
<p>最大的差别是, <code>Multiset</code> 实现了 <code>Collection</code> 接口, 完全遵守 <code>Collection</code>
接口需要满足的协议, 而 <code>Map</code> 和 <code>Collection</code> 是完全不同的接口,
这点需要牢记于心. 还有其他的差别, 诸如:</p>
<ol>
<li><code>Multiset&lt;E&gt;</code>出现的次数只能是正数, 没有任何元素的出现次数会是负数的,
出现次数为 0 的元素会被认为不存在,
这样的元素是不会出现在<code>elementSet()</code>和<code>entrySet()</code>的返回结果中的.
而<code>Map&lt;E, Integer&gt;</code>肯定不会有这样的限制.</li>
<li><code>multiset.size()</code>返回所有元素出现次数之和,
如果想要知道有多少个不重复的元素, 可以使用<code>elementSet().size()</code>,
例如<code>{a,a,b}</code>, <code>elementSet.size()</code>返回结果是 2,
<code>multiset.size()</code>返回结果是 3.</li>
<li><code>multiset.iterator()</code>用于迭代每个出现的元素,
所以迭代次数和<code>multiset.size()</code>的值一样的.</li>
<li><code>Multiset&lt;E&gt;</code>支持增加元素, 删减元素, 或者通过 <code>setCount</code>
函数直接设置元素的出现次数, <code>setCount(a, 0)</code>的意思等于将删除所有的
<code>a</code> 元素.</li>
<li><code>multiset.count(elem)</code>: 如果元素 <code>elem</code> 不存在, 那么返回值总是 0. 而
<code>Map</code> 对于不存在的元素, 返回的是 <code>null</code> .</li>
</ol>
<h3 id="multiset-实现"><span class="section-num">2.3</span> Multiset 实现</h3>
<p>鉴于 <code>Multiset</code> 只是个接口, Guava 提供许多的接口实现, 大致可以与 Java
中的容器对应上:</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>MultiSet</th>
<th>支持 <code>null</code> 元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashMultiset.html">HashMultiset</a></td>
<td>Yes</td>
</tr>
<tr>
<td>TreeMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeMultiset.html">TreeMultiset</a></td>
<td>Yes</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/LinkedHashMultiset.html">LinkedHashMultiset</a></td>
<td>Yes</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ConcurrentHashMultiset.html">ConcurrentHashMultiset</a></td>
<td>No</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultiset.html">ImmutableMultiset</a></td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="multimap"><span class="section-num">3</span> Multimap</h2>
<p>又来假设, 你是个班主任, 刚刚考完试, 你想记录下班里所有同学的成绩,
你可能写下这样的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Integer</span> <span class="n">studentScore</span> <span class="o">=</span> <span class="mi">60</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">studentName</span> <span class="o">=</span> <span class="s">&#34;Alan&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 每个学生的成绩单
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">studentScoresMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 如果 Alan 还没记录各科成绩的列表, 就新建一个列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">studentScores</span> <span class="o">=</span> <span class="n">studentScoresMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">studentName</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span><span class="n">studentScores</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">studentScores</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl">    <span class="n">studentScoresMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">studentName</span><span class="o">,</span> <span class="n">studentScores</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 然后将某个科目的成绩加进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">studentScores</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">studentScore</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个学生考试要考多个科目, 自然就会有多个学科成绩, 也就出现了一个 key
需要对应多个 value 的情况.
使用<code>Map&lt;K, List&lt;V&gt;&gt;</code>或者<code>Map&lt;K, Set&lt;V&gt;&gt;</code>这样的方式构建 key-values
自然可以, 只不过显得不甚优雅.</p>
<p>为此, Guava 提供了新的容器类型来应对一个
key 对应多个 values 的场景: <code>Multimap</code> . 同样的,
我们也可以从两个角度来理解 <code>Multimap</code> :</p>
<ul>
<li>一个 <code>key</code> 对应一个 <code>value</code> , 同样的 <code>key</code> 可以存在多个:</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">a -&gt; 1
</span></span><span class="line"><span class="cl">a -&gt; 2
</span></span><span class="line"><span class="cl">a -&gt; 4
</span></span><span class="line"><span class="cl">b -&gt; 3
</span></span><span class="line"><span class="cl">c -&gt; 5
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>或者一个 <code>key</code> 对应一个列表的 <code>value</code> :</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">a -&gt; [1, 2, 4]
</span></span><span class="line"><span class="cl">b -&gt; [3]
</span></span><span class="line"><span class="cl">c -&gt; [5]
</span></span></code></pre></td></tr></table>
</div>
</div><p>通常来说, 最好以第一种方式来理解 <code>Multimap</code> 接口,
不过你也可以以第二种方式来获取数据: <code>asMap()</code>函数, 返回一个
<code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 对象.</p>
<p>需要注意的是, 不存在 1 个 <code>key</code> 对应 0 个 <code>value</code> 的情况, 不会有空的值列表这样的说法, 要不一个 <code>key</code> 对应至少一个
<code>value</code> , 要不就是这个 <code>key</code> 不存在于这个 <code>Multimap</code> .</p>
<p>一般来说, 我们不会直接使用 <code>Multimap</code> 接口, 使用的是它的子接口; <code>Multimap</code>
接口提供了两个子接口: <code>ListMultimap</code> 和 <code>SetMultimap</code> , 大致类似于
<code>Map&lt;K, List&lt;V&gt;&gt;</code>和 <code>Map&lt;K, Set&lt;V&gt;&gt;</code>.</p>
<h3 id="multimap-的例子"><span class="section-num">3.1</span> Multimap 的例子</h3>
<p>现在让我们用 <code>Multimap</code> 重新实现一次学生不同科目的成绩单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">alan</span> <span class="o">=</span> <span class="s">&#34;Alan&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">turing</span> <span class="o">=</span> <span class="s">&#34;Turing&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建一个 ListMultimap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ListMultimap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">studentScoresMap</span> <span class="o">=</span> <span class="n">MultimapBuilder</span><span class="o">.</span><span class="na">hashKeys</span><span class="o">().</span><span class="na">arrayListValues</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">alan</span><span class="o">,</span> <span class="mi">95</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">alan</span><span class="o">,</span> <span class="mi">88</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">turing</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">studentScoresMap</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">alanScores</span> <span class="o">=</span> <span class="n">studentScoresMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">alan</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">alanScores</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">alanScores</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">studentScoresMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">alan</span><span class="o">).</span><span class="na">size</span><span class="o">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="构造"><span class="section-num">3.1.1</span> 构造</h4>
<p>细心的同学可能会发现, 上面创建 <code>ListMultimap</code>
的方式不是直接调用实现类的<code>.create()</code>函数, 而是使用 <code>MultimapBuilder</code> .</p>
<p>并不是 <code>Multimap</code> 的实现没有提供<code>.create()</code>方法, 是通过
<code>MultimapBuilder</code> 创建 <code>Multimap</code> 实现会更加便利一点,
使用<code>hashKeys()</code>函数创建的就是一个 <code>HashMap</code> ,
使用<code>treeKeys()</code>函数创建的就是一个 <code>TreeMap</code> .</p>
<h4 id="修改"><span class="section-num">3.1.2</span> 修改</h4>
<p><code>Multimap.get(key)</code>返回的就是特定 <code>key</code> 关联的集合, 对于一个
<code>ListMultimap</code> , 返回的就是一个 <code>List</code> ; 对于一个 <code>SetMultimap</code> ,
返回的就是一个 <code>Set</code> .</p>
<p>实际返回的是集合的引用, 所以对这个返回集合的操作,
将直接反馈在 <code>Multimap</code> 实例上. 如上面的例子所示, 把学生 <code>alan</code>
返回列表的数据清空, 在 <code>ListMultimap</code> 的数据也相应地被清空了.</p>
<h3 id="视图"><span class="section-num">3.2</span> 视图</h3>
<p>所谓的视图(Views), 我理解就是看待事物的方式和角度,
称为视图(或者视角&rsquo;perspective&rsquo;).</p>
<p><code>Multimap</code> 提供了若干个有用的视图:</p>
<ol>
<li>
<p><code>asMap</code> 把 <code>Multimap&lt;K,V&gt;</code> 看作一个 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> ,
返回一个的 map 对象支持 <code>remove</code> 操作, 但不支持 <code>put</code> 和 <code>putAll</code>
操作.</p>
<p>值得关注的是: 当对应的 key 不存在的时候, multiMap
返回的是一个新构造的, 为空的集合, 如果你想在对应的 key
不存在的时候返回空指针(就好像 HashMap 那样), 你可以通过
<code>asMap().get(key)</code> 实现这样的效果</p>
</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">asMap</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="n">alan</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 抛出 UnsupportedOperationException 异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">asMap</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">,</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 抛出 UnsupportedOperationException 异常, 除非 anotherScores 是个空的 Map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">asMap</span><span class="o">().</span><span class="na">putAll</span><span class="o">(</span><span class="n">anotherScores</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回空的集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">Elons</span> <span class="o">=</span> <span class="n">studentScoresMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;Elon&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 返回空指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">studentScoresMap</span><span class="o">.</span><span class="na">asMap</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;Elon&#34;</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>entries</code> 把 <code>Multimap</code> 内所有的记录(entry)看作
<code>Collection&lt;Map.Entry&lt;K,V&gt;&gt;</code>, 如前文的 <code>studentScoresMap.entries()</code>
返回的就是: <code>[{&quot;Alan&quot;: 95}, {&quot;Alan&quot;: 88}, {&quot;Turing&quot;: 100}]</code>.</li>
<li><code>keySets</code> 把 <code>Multimap</code> 内所有的不重复的 <code>key</code> 看作一个 <code>Set</code> .
如前文的 <code>studentScoresMap.keySets()</code> 返回的就是:
<code>Set([&quot;Alan&quot;,&quot;Turing&quot;])</code>.</li>
<li><code>keys</code> 把 <code>Multimap</code> 内所有的 key 看作一个前文提到的 <code>Multiset</code> ,
可以从这个 <code>Multiset</code> 删除元素, 但不能新增元素, 如前文的
<code>studentScoresMap.keys()</code> 返回的就是:
<code>Multiset([&quot;Alan&quot;,&quot;Alan&quot;, &quot;Turing&quot;])</code>.</li>
<li><code>values()</code> 把 <code>Multimap</code> 内所有的 value 看作一个集合, 相当于把所有 key
对应的 value 集合串联起来, 如前文的 <code>studentScoresMap.values()</code>
返回的就是: <code>[95, 88, 100]</code></li>
</ul>
<h3 id="multimap-也不是一个-map"><span class="section-num">3.3</span> Multimap 也不是一个 Map</h3>
<p>严格来说, 即使 <code>Multimap</code> 名字中带有 map, 甚至 <code>map</code> 可能用来实现
<code>Multimap</code> , 但一个 <code>Multimap&lt;K,V&gt;</code> 终究不是一个
<code>Map&lt;K, Collection&lt;V&gt;&gt;</code>. 它们之间的差异包括:</p>
<ol>
<li><code>Multimap.get(key)</code> 返回的对象总是不为空指针的, 即使查询的 key
不存在, 返回的是个空的集合. 而 <code>Map.get(key)</code> 查询的 key 不存在,
返回的就是空指针. 前文提到过, 如果想要让 <code>Multimap</code> 在查询 key
不存在的时候返回空指针, 可以使用 <code>Multimap.asMap().get(key)</code>.</li>
<li><code>Multimap.containsKey(key)</code> 在 values 集合为空的时候就会返回 false,
例如
<code>studentScoresMap.putAll(&quot;elon&quot;, Lists.newArrayList()); Assert.assertFalse(studentScoresMap.containsKey(&quot;elon&quot;))</code>,
但对于 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 而言, 返回的就会是 true, 因为 value
不为 null.</li>
<li><code>Multimap.size()</code> 返回的是所有记录的总数的, 即把所有的 value
的数量累加起来, 而 <code>Map&lt;K, Colleciton&lt;V&gt;&gt;</code> 返回的就是 key 对应的数量.</li>
</ol>
<h3 id="实现"><span class="section-num">3.4</span> 实现</h3>
<p><code>Multimap</code> 提供了若干个不同类型的实现, 你可以使用对应的实现来取代原来
<code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 的地方:</p>
<table>
<thead>
<tr>
<th>实现</th>
<th>key 表现得类似&hellip;</th>
<th>value 表现得类似&hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ArrayListMultimap.html">ArrayListMultimap</a></td>
<td>HashMap</td>
<td>ArrayList</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashMultimap.html">HashMultimap</a></td>
<td>HashMap</td>
<td>HashSet</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/LinkedListMultimap.html">LinkedListMultimap</a></td>
<td>LinkedHashMap</td>
<td>LinkedList</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/LinkedHashMultimap.html">LinkedHashMultimap</a></td>
<td>LinkedHashMap</td>
<td>LinkedHashSet</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeMultimap.html">TreeMultimap</a></td>
<td>TreeMap</td>
<td>TreeSet</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableListMultimap.html">ImmutableListMultimap</a></td>
<td>ImmutableMap</td>
<td>ImmutableList</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableSetMultimap.html">ImmutableSetMultimap</a></td>
<td>ImmutableMap</td>
<td>ImmutableSet</td>
</tr>
</tbody>
</table>
<p>上述的实现, 除了不可变的实现之外, 其他都支持 <code>null key</code> 与 <code>null value</code>.
并非所有的实现底层用的都是 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code>,
有好几个实现出于性能的考虑, 实现了自定义的 hash 表.</p>
<p><code>Multimap</code> 还支持自定义 value 的集合形式, 如 List 形式或者 Set 形式, 详情可见
<a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/Multimaps.html#newMultimap-java.util.Map-com.google.common.base.Supplier-"><code>Multimaps.newMultimap(Map, Supplier&lt;Collection&gt;)</code></a></p>
<h2 id="bimap"><span class="section-num">4</span> BiMap</h2>
<p>继续假设, 你是个班主任, 你有个学生名字与学号的名单,
你有时会通过名字查询对应学号, 有时又会根据学号反查询学生名字, 通常来说,
你会这么实现这个名单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">nameToId</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">idToName</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">nameToId</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;Linus&#34;</span><span class="o">,</span> <span class="s">&#34;0001&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">idToName</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">,</span> <span class="s">&#34;Linus&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果 0001 这个学号, 或者 Linus 这个名字已经存在了, 会发生什么事情呢?
</span></span></span><span class="line"><span class="cl"><span class="c1">// 会出现很微妙的 bug, 为了避免出现这种情况, 你需要手动维护这种限制
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不得不说, 通过两个 Map 和实现 <code>value</code> 反查 <code>key</code> 的传统做法并不优雅,
即增加了心理负担, 又容易出 bug.</p>
<p>幸运的是, Guava 有一个名为 <code>BiMap</code> 类库, 提供了通过 <code>value</code> 也反查 <code>key</code> 的特性.
一个<code>BiMap&lt;K,V&gt;</code>是一个<code>Map&lt;K,V&gt;</code>, 提供了如下功能:</p>
<ol>
<li>允许通过 <code>inverse()</code> 函数调转 key-value, 从 <code>Map&lt;K,V&gt;</code> 变成
<code>Map&lt;V,K&gt;</code></li>
<li>保证所有的 <code>value</code> 都是唯一的, <code>values()</code> 函数返回一个包含所有
<code>value</code> 的 Set</li>
<li>如果 <code>value</code> 已经存在, 那么 <code>BiMap.put(key,value)</code> 会抛出一个
<code>IllegalArgumentException</code> 异常, 如果想强制删除掉原来的 <code>value</code> ,
并插入一对新的 key-value, 可以使用
<a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/BiMap.html#forcePut-java.lang.Object-java.lang.Object-"><code>Bimap.forcePut(key,value)</code></a></li>
</ol>
<h3 id="bimap-例子"><span class="section-num">4.1</span> BiMap 例子</h3>
<p>让我们用 BiMap 来重新实现学生名字和学号的名单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BiMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">userId</span> <span class="o">=</span> <span class="n">HashBiMap</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">userId</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;Linus&#34;</span><span class="o">,</span> <span class="s">&#34;0001&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userId</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;Linus&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 反向查询, 通过学号查询名字.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">String</span> <span class="n">idForUser</span> <span class="o">=</span> <span class="n">userId</span><span class="o">.</span><span class="na">inverse</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IllegalArgumentException: value already present: 0001
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">userId</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;RMS&#34;</span><span class="o">,</span> <span class="s">&#34;0001&#34;</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bimap-实现"><span class="section-num">4.2</span> BiMap 实现</h3>
<table>
<thead>
<tr>
<th>key-value map 实现</th>
<th>value-key map 实现</th>
<th>对应的 BiMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>HashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashBiMap.html"><code>HashBiMap</code></a></td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableBiMap.html"><code>ImmutableBiMap</code></a></td>
</tr>
<tr>
<td>EnumMap</td>
<td>EnumMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/EnumBiMap.html"><code>EnumBiMap</code></a></td>
</tr>
<tr>
<td>EnumMap</td>
<td>HashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/EnumHashBiMap.html"><code>EnumHashBiMap</code></a></td>
</tr>
</tbody>
</table>
<h2 id="table"><span class="section-num">5</span> Table</h2>
<p>假设还是个班主任, 现在你需要制作一个包含学号, 姓名与成绩的名单,
然后可以通过姓名或者学号进搜索, 你会怎么实现呢? 什么? 用 excel?
你好幽默啊!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// key: 学号, value: {姓名: 成绩}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">studentScores</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">linus</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newHashMap</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">linus</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;Linus&#34;</span><span class="o">,</span> <span class="mi">99</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">studentScores</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">,</span> <span class="n">linus</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过学号获取成绩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">studentScores</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">).</span><span class="na">size</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">element</span> <span class="o">:</span> <span class="n">studentScores</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">).</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Integer</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 通过姓名获取成绩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">element</span> <span class="o">:</span> <span class="n">studentScores</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">id</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">nameScores</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">nameScores</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">&#34;Linus&#34;</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Integer</span> <span class="n">score</span> <span class="o">=</span> <span class="n">nameScores</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;Linus&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不得不说, 用 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code> 的形式来实现多 key 搜索非常难受,
算法效率变为 O(n), 线性时间复杂度, 不但不优雅, 还容易出错,
如果我是班主任, 我就辞职了, 给我个 excel 不行么?</p>
<p>excel 是没有的了, 但是 Guava 提供了一个类 excel 的多 key 存储/搜索的容器: <code>Table</code>,
它支持以行和列维度搜索.</p>
<h3 id="table-例子"><span class="section-num">5.1</span> Table 例子</h3>
<p>让我们用 <code>Table</code> 重新实现一次可根据姓名与学号进行搜索的成绩单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 从左到右各列分别是: 学号, 姓名, 成绩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Table</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">idNameScoreTranscript</span> <span class="o">=</span> <span class="n">HashBasedTable</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">idNameScoreTranscript</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">,</span> <span class="s">&#34;Linus&#34;</span><span class="o">,</span> <span class="mi">99</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">idNameScoreTranscript</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;0002&#34;</span><span class="o">,</span> <span class="s">&#34;Aaron&#34;</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">idNameScoreTranscript</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">,</span> <span class="s">&#34;RMS&#34;</span><span class="o">,</span> <span class="mi">98</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">idNameScoreTranscript</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;0004&#34;</span><span class="o">,</span> <span class="s">&#34;RMS&#34;</span><span class="o">,</span> <span class="mi">97</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// 返回结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Linus: 99
</span></span></span><span class="line"><span class="cl"><span class="c1">/// RMS: 98
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">idNameScoreTranscript</span><span class="o">.</span><span class="na">row</span><span class="o">(</span><span class="s">&#34;0001&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// 返回结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 0001: 98
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 0004: 97
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">idNameScoreTranscript</span><span class="o">.</span><span class="na">column</span><span class="o">(</span><span class="s">&#34;RMS&#34;</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>正常来说, 不会有两个学号一样的学生, 只是为了展示 <code>Table</code>
用法而这样造数据. <code>row</code>, <code>column</code> 函数可能让人比较迷惑,
这两个函数是怎么搜索的?</p>
<p>其实很简单, <code>row</code> 是以第一个 key 来搜索, 而 <code>column</code> 以第二个 key 来搜索, 如图:</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/guava_table_row.png"
         alt="Figure 2: row: 以第一个 key 来搜索"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>row: 以第一个 key 来搜索</p>
        </figcaption>
</figure>

<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/guava_table_column.png"
         alt="Figure 3: column: 以第二个 key 来搜索"/> <figcaption>
            <p><span class="figure-number">Figure 3: </span>column: 以第二个 key 来搜索</p>
        </figcaption>
</figure>

<h3 id="table-视图"><span class="section-num">5.2</span> Table 视图</h3>
<p>一往常, <code>Table</code> 也提供了若干个视图:</p>
<ol>
<li><code>rowMap()</code>, 把 <code>Table&lt;R, C, V&gt;</code> 看作一个 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code>, 同样的,
<code>rowKeySet()</code>返回一个<code>Set&lt;R&gt;</code>.</li>
<li><code>row(r)</code> 返回一个非空的 <code>Map&lt;C, V&gt;</code> 的引用, 对返回的 Map
的修改也会反馈给持有该引用 <code>Table</code>.</li>
<li>类似地, <code>column(c)</code> 返回一个非空的 <code>Map&lt;R, V&gt;</code> 的引用, 对返回的 Map
的修改也会反馈给持有该引用 <code>Table</code>.</li>
<li><code>cellSet()</code> 把<code>Table&lt;R, C, V&gt;</code>看作一个 <code>Table.Cell&lt;R, C, V&gt;</code>, <code>Cell</code>
与 <code>Map.Entry</code> 十分类似, 只不过它有两个 key, 形式是 <code>(r,c)=v</code>, 而
<code>Map.Entry</code> 是 <code>key = value</code>.</li>
</ol>
<h3 id="table-实现"><span class="section-num">5.3</span> Table 实现</h3>
<p>Table 依旧提供了若干个实现, 列表如下:</p>
<table>
<thead>
<tr>
<th>Table&lt;R, C, V&gt;</th>
<th>类似的 Map&lt;R, Map&lt;C, V&gt;&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashBasedTable.html"><code>HashBasedTable</code></a></td>
<td>HashMap&lt;R, HashMap&lt;C, V&gt;&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeBasedTable.html"><code>TreeBasedTable</code></a></td>
<td>TreeMap&lt;R, TreeMap&lt;C, V&gt;&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableTable.html"><code>ImmutableTable</code></a></td>
<td>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ArrayTable.html"><code>ArrayTable</code></a></td>
<td>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;, 特别的一个</td>
</tr>
</tbody>
</table>
<h2 id="classtoinstancemap"><span class="section-num">6</span> ClassToInstanceMap</h2>
<p>目前, 我们介绍过的 Map, 无论是原生 Jdk 的 Map, 抑或是 Guava 的 Map,
<code>key</code> 都是同一个类型的.</p>
<p>这是因为 Map 的签名是 <code>Map&lt;K,V&gt;</code>, 实例的时候, 只能实例成某具体一个类型的参数. 所谓凡事都有例外, 有没有支持 <code>key</code>
是不同类型的 map 呢? 自然是有的, Guava 的
<a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ClassToInstanceMap.html"><code>ClassToInstanceMap</code></a>
就可以支持多个类型的 key.</p>
<p>为什么它可以实现多个类型的 <code>key</code> 呢? 因为 <code>ClassToInstanceMap</code> 的签名声明为 <code>Map&lt;Class&lt;? extends B&gt;, B&gt;</code>,
通过传入不同类型的 <code>Class</code> 对象, 实现类型不同的 =key=(如果你要说,
即使传入不同类型的 Class 对象, 它只有一个 Class, 没有实现多个不同类型的
key 阿! 你也可以这样理解, well, 咬文嚼字就没有什么意义了)</p>
<h3 id="classtoinstancemap-例子"><span class="section-num">6.1</span> ClassToInstanceMap 例子</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ClassToInstanceMap</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">numberDefault</span> <span class="o">=</span> <span class="n">MutableClassToInstanceMap</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">numberDefault</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">numberDefault</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">20L</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 编译失败
</span></span></span><span class="line"><span class="cl"><span class="c1">//numberDefault.put(String.class, &#34;string&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">20L</span><span class="o">),</span> <span class="n">numberDefault</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果查看源码, 可以发现, <code>ClassToInstanceMap&lt;B&gt;</code> 只有一个类型参数 <code>B</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ClassToInstanceMap</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">B</span><span class="o">&gt;,</span> <span class="n">B</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>很明显的, 类型 <code>B</code> 限制了 <code>key</code> 与 <code>value</code> 的类型。</p>
<p>对于 <code>value</code> 的限制,
就和常规的 <code>map</code> 一样; 而对于 <code>key</code> 而言, 泛型实例化时的参数类型只能是
<code>B</code>, 或者是 <code>B</code> 的子类, 例如: <code>ClassToInstanceMap&lt;Number&gt;</code>, 那么这个 map
的 <code>key</code> 类型必须是 <code>Number</code> 或 <code>Number</code> 的子类, 而传入的 <code>Integer</code> 和
<code>Long</code> 都是 <code>Number</code> 子类, 因此能编译通过。</p>
<p>如果传入的是 <code>String,</code> 不符合声明, 编译就报错了.</p>
<p><strong>需要注意的是, 和 <code>Map&lt;Class, Object&gt;</code> 一样, 一个 <code>ClassToInstanceMap</code> 可以包含着是原始类型的 <code>value</code>,
而原始类型与它对应的包装类型并不是同一种类型, 不要混淆了哦</strong></p>
<h3 id="classtoinstancemap-实现"><span class="section-num">6.2</span> ClassToInstanceMap 实现</h3>
<p><code>ClassToInstanceMap</code> 提供了两个实现:</p>
<table>
<thead>
<tr>
<th>ClassToInstanceMap</th>
<th>类似的 Map</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/MutableClassToInstanceMap.html"><code>MutableClassToInstanceMap</code></a></td>
<td>Map&lt;Class, Object&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableClassToInstanceMap.html"><code>ImmutableClassToInstanceMap</code></a></td>
<td>ImmutableMap&lt;Class,Object&gt;</td>
</tr>
</tbody>
</table>
<h2 id="rangeset"><span class="section-num">7</span> RangeSet</h2>
<p>目前为止, 我们介绍过的新类型容器都是常见的 Map/Set/Table,
现在我们就来介绍一个表示区间的容器: <code>RangeSet</code>. 一个 <code>RangeSet</code>,
表示一个包含无连接的, 不为空的区间的集合, 例如包含一个整数区间的
<code>RangeSet</code>: <code>{[1,5], [7,9)}</code>.</p>
<p>在 <code>RangeSet</code> 中, 区间是由类 <code>Range</code> 来表示的, 当把一个区间加入到一个可变的 <code>RangeSet</code> 时,
任何有交集的区间都会被合并, 为空的区间就会被忽略, 例如将区间 <code>[3,5]</code>
加入到已有的 <code>RangeSet</code> <code>{[2,4]}</code>, 就会被合并成 <code>{[2,5]}</code>,
这个也符合我们日常的生活经验.</p>
<h3 id="rangeset-例子"><span class="section-num">7.1</span> RangeSet 例子</h3>
<p>让我们现在来看一下 <code>RangeSet</code> 的两个例子, 一个是整数的 <code>RangeSet</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RangeSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rangeSet</span> <span class="o">=</span> <span class="n">TreeRangeSet</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[2,4]}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[2,5]}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[1,10]}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 无连接上的区间: {[1,10], [11,15)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closedOpen</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">15</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 连接上的区间; {[1,10], [11,20)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closedOpen</span><span class="o">(</span><span class="mi">15</span><span class="o">,</span> <span class="mi">20</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 空区间, 被忽略; {[1,10],[11,20)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">openClosed</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 分割区间 [1,10]; {[1,5],[10,10],[11,20)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中, <code>[2,4]</code> 和 <code>[3,5]</code> 这两个区间有交集,
所以它们被自动合并到一起了, 而对于区间 <code>[1,10]</code> 和 <code>[11,15)</code>, 10
相邻的整数就是 11, 但两个区间也没有合并起来, 因为它们没有相交,
如果想要他们合并起来, 可以手动调用 <code>Range.canonical(DiscreteDomain)</code>,
即:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// {[1,10]}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">).</span><span class="na">canonical</span><span class="o">(</span><span class="n">DiscreteDomain</span><span class="o">.</span><span class="na">integers</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 连接上的区间: {[1,15)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closedOpen</span><span class="o">(</span><span class="mi">11</span><span class="o">,</span> <span class="mi">15</span><span class="o">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外一个例子是日期的 <code>RangeSet</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RangeSet</span><span class="o">&lt;</span><span class="n">LocalDate</span><span class="o">&gt;</span> <span class="n">rangeSet</span> <span class="o">=</span> <span class="n">TreeRangeSet</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[2019-10-10, 2019-12-25]}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-10&#34;</span><span class="o">),</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-12-25&#34;</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[2019-10-10, 2019-12-30)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closedOpen</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-12-24&#34;</span><span class="o">),</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-12-30&#34;</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">rangeSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeSet</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="o">),</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-30&#34;</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">rangeSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [2019-11-10,2019-11-25] 在 `{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}`的区间包围内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">rangeSet</span><span class="o">.</span><span class="na">encloses</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-11-11&#34;</span><span class="o">),</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-11-20&#34;</span><span class="o">))));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closedOpen</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-10&#34;</span><span class="o">),</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="o">)),</span>
</span></span><span class="line"><span class="cl">		    <span class="n">rangeSet</span><span class="o">.</span><span class="na">rangeContaining</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-19&#34;</span><span class="o">)));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[2019-10-10, 2019-12-30)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Range</span><span class="o">&lt;</span><span class="n">LocalDate</span><span class="o">&gt;</span> <span class="n">span</span> <span class="o">=</span> <span class="n">rangeSet</span><span class="o">.</span><span class="na">span</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-10-10&#34;</span><span class="o">),</span> <span class="n">span</span><span class="o">.</span><span class="na">lowerEndpoint</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2019-12-30&#34;</span><span class="o">),</span> <span class="n">span</span><span class="o">.</span><span class="na">upperEndpoint</span><span class="o">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>RangeSet</code> 提供了若干个查询函数, 用法在上面的代码已经展示了,
查询函数列表:</p>
<ul>
<li><code>contains(C)</code>: <code>RangeSet</code> 最基础的查询操作, 判断任意的元素是否在
<code>RangeSet</code> 内.</li>
<li><code>rangeContaining(C)</code>: 与 <code>contains(C)</code> 类似, 判断任意的元素是否在
<code>RangeSet</code> 内, 如果在的话返回一个对应的区间, 否则返回空指针. 如上代码,
有 <code>RangeSet</code>: <code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>,
而元素 <code>2019-10-19</code> 在区间 <code>[2019-10-10, 2019-10-20)</code> 内, 因此
<code>rangeContaining(C)</code> 函数返回的就是 <code>[2019-10-10, 2019-10-20)</code>.</li>
<li><code>encloses(Range&lt;C&gt;)</code>: 判断任意的区间是否在 <code>RangeSet</code> 的包围中.</li>
<li><code>span</code>: 返回一个最小区间, 包含 <code>RangeSet</code> 中的所有区间, 如有:
<code>RangeSet</code>: <code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>,
<code>span</code> 函数返回的区间就是 <code>{[2019-10-10, 2019-12-30)}</code>.</li>
</ul>
<h3 id="rangeset-视图"><span class="section-num">7.2</span> RangeSet 视图</h3>
<p>依照惯例, <code>RangeSet</code> 也提供了若干个视图:</p>
<ul>
<li><code>complement()</code>: 返回某个 <code>RangeSet</code> 的补集, 返回结果也是个 <code>RangeSet</code>,
如有 <code>RangeSet</code>:
<code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>, 那它的补集就是:
<code>RangeSet</code>:
<code>{(-∞,2019-10-10), [2019-10-20,2019-10-30], [2019-12-30,+∞)}</code>,
分别是三个区间: 负无穷到 <code>2019-10-10</code>, <code>2019-10-20</code> 到 <code>2019-10-30</code>,
以及 <code>2019-12-30</code> 到正无穷.</li>
<li><code>subRangeSet(Range&lt;C&gt;)</code>: 返回某个 <code>RangeSet</code> 相交的子区间, 如有
<code>RangeSet</code>: <code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>,
取子区间 <code>[2019-11-10,2019-11-20]</code>, 那么返回结果就是
<code>{[2019-11-10, 2019-11-20]}</code>; 如果取子区间 <code>[2019-10-15, 2019-11-20]</code>,
那么返回结果就是
<code>{[2019-10-10, 2019-10-20), (2019-10-30, 2019-11-20]}</code></li>
<li><code>asRanges()</code>: 把 <code>RangeSet</code> 当作一个 <code>Set&lt;Range&lt;C&gt;&gt;</code>, 如有 <code>RangeSet</code>:
<code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>, 返回结果就是:
<code>Set({[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)})</code></li>
</ul>
<h3 id="rangeset-实现"><span class="section-num">7.3</span> RangeSet 实现</h3>
<p><code>RangeSet</code> 提供了两个实现:</p>
<table>
<thead>
<tr>
<th><code>RangeSet</code></th>
<th>类似的 Set&lt;Range&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeRangeSet.html"><code>TreeRangeSet</code></a></td>
<td>TreeSet&lt;Range&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableRangeSet.html"><code>ImmutableRangeSet</code></a></td>
<td>ImmutableSet&lt;Range&gt;</td>
</tr>
</tbody>
</table>
<h2 id="rangemap"><span class="section-num">8</span> RangeMap</h2>
<p>既然能以区间集作为容器, 那么能否把区间当作 Map 的 <code>key</code> 呢?
答案是当然可以, Guava 就提供了一个这样的容器: <a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/RangeMap.html"><code>RangeMap</code></a>.</p>
<p>需要注意的是, 不像 <code>RangeSet</code> 那样, 相邻或者相交的区间不能连接起来的,
即使毗邻的区间映射的是同一个 <code>value</code>.</p>
<h2 id="rangemap-例子"><span class="section-num">9</span> RangeMap 例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RangeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">rangeMap</span> <span class="o">=</span> <span class="n">TreeRangeMap</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[1,10] =&gt; &#34;foo&#34;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">),</span> <span class="s">&#34;foo&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[1, 3] =&gt; &#34;foo&#34;, (3, 6) =&gt; &#34;bar&#34;, [6, 10] =&gt; &#34;foo&#34;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span> <span class="s">&#34;bar&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[1, 3] =&gt; &#34;foo&#34;, (3, 6) =&gt; &#34;bar&#34;, [6, 10] =&gt; &#34;foo&#34;, (10,20) =&gt; &#34;foo&#34;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">),</span> <span class="s">&#34;foo&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[1, 3] =&gt; &#34;foo&#34;, (3, 5) =&gt; &#34;bar&#34;, (11, 20) =&gt; &#34;foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">rangeMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">11</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertSame</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">,</span> <span class="n">rangeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Range</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">span</span> <span class="o">=</span> <span class="n">rangeMap</span><span class="o">.</span><span class="na">span</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">span</span><span class="o">.</span><span class="na">lowerEndpoint</span><span class="o">(),</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">span</span><span class="o">.</span><span class="na">upperEndpoint</span><span class="o">(),</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// {[12, 15]} =&gt; &#34;foo&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">RangeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">subRangeMap</span> <span class="o">=</span> <span class="n">rangeMap</span><span class="o">.</span><span class="na">subRangeMap</span><span class="o">(</span><span class="n">Range</span><span class="o">.</span><span class="na">closed</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">15</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">subRangeMap</span><span class="o">.</span><span class="na">span</span><span class="o">().</span><span class="na">lowerEndpoint</span><span class="o">(),</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">12</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">subRangeMap</span><span class="o">.</span><span class="na">span</span><span class="o">().</span><span class="na">upperEndpoint</span><span class="o">(),</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">15</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">,</span> <span class="n">subRangeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">12</span><span class="o">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>RangeMap</code> 提供的查询函数不多, 满打满算也只有 <code>get(K)</code> 和 <code>span</code>
这两个函数.</p>
<h3 id="rangemap-视图"><span class="section-num">9.1</span> RangeMap 视图</h3>
<p><code>RangeMap</code> 提供的视图也不多, 只有两个:</p>
<ul>
<li><code>asMapOfRanges()</code>, 把 <code>RangeMap</code> 看作一个 <code>Map&lt;Range&lt;K&gt;, V&gt;</code>,
可以用来遍历 <code>RangeMap</code></li>
<li><code>subRangeMap(Range&lt;K&gt;)</code>, 返回某个 <code>RangeMap</code>
相关区间的子区间以及对应的 <code>value</code>, 如有 <code>RangeMap</code>:
<code>{[1, 3] =&gt; &quot;foo&quot;, (3, 5) =&gt; &quot;bar&quot;, (11, 20) =&gt; &quot;foo&quot;</code>, 取子区间
<code>[12,15]</code>, 返回结果就是 <code>{[12, 15]} =&gt; &quot;foo&quot;</code>; 如果取子区间<code>[4,12]</code>,
返回结果就是: <code>{[4,5) =&gt; bar, (11, 12] =&gt; foo}</code></li>
</ul>
<h3 id="rangemap-实现"><span class="section-num">9.2</span> RangeMap 实现</h3>
<p>RangeMap 提供了两个实现:</p>
<table>
<thead>
<tr>
<th>RangeMap</th>
<th>类似的 Map&lt;Range, V&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeRangeMap.html">TreeRangeMap</a></td>
<td>TreeMap&lt;Range, V&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableRangeMap.html">ImmutableRangeMap</a></td>
<td>ImmutableMap&lt;Range&lt;K, V&gt;&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="总结"><span class="section-num">10</span> 总结</h2>
<p>介绍完新类型的容器之后, 希望大家对这些新类型容器熟悉起来, 应对需求来也能得心应手 :)</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>guava探究系列之四：不可变容器</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 05 Sep 2019 15:36:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/</guid>
      <description>1 前言 先此声明, 个人倾向于将Collection翻译成容器, 将Set翻译成集合. 已经许久没有更新Guava研读系列的文章, 今天要介绍的是Gu</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>先此声明, 个人倾向于将<code>Collection</code>翻译成容器, 将<code>Set</code>翻译成集合.</p>
<p>已经许久没有更新Guava研读系列的文章, 今天要介绍的是Guava的不可变容器.</p>
<h2 id="关于不可变对象"><span class="section-num">2</span> 关于不可变对象</h2>
<p>不可变的对象有许多的优点, 如下:</p>
<ol>
<li>线程安全, 可以在多线程之间使用也不用担心有竞争条件的风险</li>
<li>可以放心地用于不被信任的第三方类库</li>
<li>不用考虑支持可变性, 无需额外的空间和时间消耗.</li>
<li>可用作常量使用</li>
</ol>
<p>使用对象的不可变拷贝是一项良好的编程防御策略, 为此,
Guava提供了许多简单易用的, 实现了标准库<code>Collection</code>接口的不可变容器,
当然也包括实现了他们自家<code>Collection</code>接口的不可变容器.</p>
<p>虽然通过JDK的静态方法<code>Collection.unmodifiableXXX</code>可以使用内置不可变容器,
但是在Guava团队的同学看来,
它们有若干的不足(又到了喜闻乐见的黑JDK的环节):</p>
<ol>
<li>笨重; 使用起来很笨重, 不够赏心悦目和优雅.</li>
<li>不安全;
上述静态方法返回的容器只有在没有对象持有原来容器的情况下才是真正不可变的.
例如,
当想要通过可变Map=ids=来生成一个不可变Map的时候,=Collections.unmodifiableMap(ids)=,
如果有多个对象持有<code>ids</code>时, 静态方法返回的对象就不是真正的不可变.
具体的分析可以参考<a href="https://stackoverflow.com/questions/22636575/unmodifiablemap-java-collections-vs-immutablemap-google/22636674">StackOverFlow关于unmodifiableMap和ImmutableMap的讨论</a></li>
<li>低效; 静态方法生成的不可变容器和可变容器有着同样的性能开销,
包括并发修改, 动态扩容等(对于真正的不可变容器而言,
这些都是不会出现的操作)</li>
</ol>
<p>综上所述, 如果你不想修改某个容器, 或者你想把某个容器当作不可变常量,
把这个容器变成一个不可变容器是一个很好的手段(使用Guava的不可变容器).</p>
<p>此外, 在之前的文章中, 我阐述过Guava对于空指针的态度是尽量不要使用空指针,
Guava的类库对于空指针都是快速失败的, Guava的不可变容器也是不例外的,
是拒绝接受空指针的.</p>
<h2 id="代码实例"><span class="section-num">3</span> 代码实例</h2>
<p>前面详细介绍了不可变容器, 现在是时候来看一下Guava不可变容器的代码例子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">COLOR_NAMES</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">								       <span class="s">&#34;red&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">								       <span class="s">&#34;orange&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">								       <span class="s">&#34;purple&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bars</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">this</span><span class="o">.</span><span class="na">bars</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">bars</span><span class="o">);</span> <span class="c1">// defensive copy!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>前文提到的, <code>Collections.unmodifiableXXX(mutableXXX)</code>,
Collections方法不能提供真正的不可变容器,
除非没有对象持有可变对象<code>mutableXXX</code>的引用</p>
<p>那么Guava的不可变容器又是否是真正的不可变呢? 以<code>ImmutableSet</code>为例,
发现所有可以修改<code>ImmutableSet</code>对象的操作函数,
包括<code>add</code>, <code>remove</code>, <code>addAll</code>, <code>removeAll</code>等函数都被重载,
然后标注成<code>@Deprecated</code>,
重载函数的内容就是抛出<code>UnsupportedOperationException</code>异常,
所以不可能修改<code>ImmutableSet</code>对象的内容:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Guaranteed to throw an exception and leave the collection unmodified.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws UnsupportedOperationException always
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @deprecated Unsupported operation.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Deprecated</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Override</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>至于持有<code>mutableXXX</code>对象引用,
修改<code>mutableXXX</code>对象内容导致不可变内容发生改变的情况也不会发生:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testImmutable</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">colors</span> <span class="o">=</span> <span class="n">Sets</span><span class="o">.</span><span class="na">newHashSet</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">colors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;blue&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">modifiableSet</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">colors</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">unmodifiableSet</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">colors</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">COLOR_NAMES</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">colors</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">colors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;yellow&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 不会修改不可变集合的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">COLOR_NAMES</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;yellow&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改引用导致集合值发生修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">modifiableSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;yellow&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 因为没有对象持有new HashSet&lt;&gt;(colors)的引用, 所以unmodifiableSet是不可变集合, 不能修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">unmodifiableSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;yellow&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">colors</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;yellow&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看<code>ImmutableSet.copyOf(Set&lt;T&gt;)</code>函数的源码,
发现不可变集合的实现逻辑和在构造函数新建对象实现对象引用拷贝的逻辑一致,
即和<code>Collections.unmodifiableSet(new HashSet&lt;&gt;(colors))</code>的逻辑一样的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">copyOf</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">elements</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * TODO(lowasser): consider checking for ImmutableAsList here
</span></span></span><span class="line"><span class="cl"><span class="cm">     * TODO(lowasser): consider checking for Multiset here
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">elements</span> <span class="k">instanceof</span> <span class="n">ImmutableSet</span> <span class="o">&amp;&amp;</span> <span class="o">!(</span><span class="n">elements</span> <span class="k">instanceof</span> <span class="n">ImmutableSortedSet</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span> <span class="c1">// all supported methods are covariant
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	    <span class="c1">// 新建对象, 拷贝对象引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	    <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="o">(</span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;)</span> <span class="n">elements</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">isPartialView</span><span class="o">())</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">return</span> <span class="n">set</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">elements</span> <span class="k">instanceof</span> <span class="n">EnumSet</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">copyOfEnumSet</span><span class="o">((</span><span class="n">EnumSet</span><span class="o">)</span> <span class="n">elements</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">construct</span><span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">array</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="具体细节"><span class="section-num">4</span> 具体细节</h2>
<p>下面我们来讨论一下各种不可变容器的具体使用细节.</p>
<h3 id="构造不可变容器"><span class="section-num">4.1</span> 构造不可变容器</h3>
<p>关于如何构造一个不可变容器, Guava提供的手段是多种多样的:</p>
<ol>
<li>使用<code>copyOf</code>静态方法, 例如<code>ImmutableSet.copyOf(set)</code>,
这种构造方法与JDK不可变容器的构造方式类似<code>Collections.unmodifiableXXX(mutableXXX)</code></li>
<li>使用<code>of</code>静态方法,
例如<code>ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code>或者<code>ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2)</code>,
前文已经介绍过, 在此就不赘言</li>
<li>使用<code>Builder</code>构造不可变容器, 例如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span> <span class="n">GOOGLE_COLORS</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">ImmutableSet</span><span class="o">.&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">WEBSAFE_COLORS</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Color</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">191</span><span class="o">,</span> <span class="mi">255</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过某些不可变容器的builder方法废弃了,
如<code>ImmutableSortedSet</code>的<code>builder</code>方法就被替换成了<code>naturalOrder</code>.</p>
<p>此外, 对于有序容器(sorted collections)而言,
容器内的元素的顺序是按照构造时元素的插入顺序排列的, 例如如下代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">alphaTable</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;d&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">alphaTable</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果为 a b c d
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="aslist-函数"><span class="section-num">4.2</span> <code>asList</code>函数</h3>
<p>所有的不可变容器都提供了一个<code>asList</code>方法来返回一个不可变列表<code>ImmutableList</code>,
所以即使你把数据存在一个不可变有序集合<code>ImmutableSortedSet</code>,
你也可以通过下标索引获取最小的元素或者第n小的元素, 如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">numberSet</span> <span class="o">=</span> <span class="n">ImmutableSortedSet</span><span class="o">.&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="n">naturalOrder</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">numberSet</span><span class="o">.</span><span class="na">asList</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">#</span> <span class="err">结果为</span><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="智能的-copyof-函数"><span class="section-num">4.3</span> 智能的<code>copyOf</code>函数</h3>
<p>前文提到,
不可变容器都提供了一个<code>copyOf</code>方法用于从另外一个容器构造出一个不可变容器.
值得指出的是不可变容器的<code>copyOf</code>方法在不需要拷贝数据的时候就会尽量避免拷贝数据,
但这是什么意思呢? 假如有如下的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">foobar</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">,</span> <span class="s">&#34;bar&#34;</span><span class="o">,</span> <span class="s">&#34;baz&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">thingamajig</span><span class="o">(</span><span class="n">foobar</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thingamajig</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">defensiveCopy</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">collection</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的代码调用<code>ImmutableList.copyOf(foobar)</code>函数的时候,
函数的内部实现不会逐个拷贝,
而会直接通过<code>foobar.asList()</code>函数返回一个不可变值列表,
这样实现的算法时间复杂度就是<code>O(1)</code>, 而不是<code>O(n)</code>, 实现性能消耗的最小化,
这也就是小标题智能指的意思.</p>
<p>但是需要注意的是,
并不是所有的不可变容器之间的转换都能实现<code>O(1)</code>时间复杂度,
例如<code>ImmutableSet.copyOf(ImmutableList)</code>就只能逐个元素拷贝,
时间复杂度退化到<code>O(n)</code>.</p>
<h2 id="jdk容器与guava不可变容器"><span class="section-num">5</span> JDK容器与Guava不可变容器</h2>
<p>对于JDK提供的标准容器, Guava提供了相应的不可变容器实现,
对于Guava自家的容器, Guava也提供了对应的不可变容器, 具体实现对比如下:</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>JDK or Guava?</th>
<th>Immutable Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Collection</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableCollection.html"><code>ImmutableCollection</code></a></td>
</tr>
<tr>
<td><code>List</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableList.html"><code>ImmutableList</code></a></td>
</tr>
<tr>
<td><code>Set</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSet.html"><code>ImmutableSet</code></a></td>
</tr>
<tr>
<td><code>SortedSet=/=NavigableSet</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedSet.html"><code>ImmutableSortedSet</code></a></td>
</tr>
<tr>
<td><code>Map</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMap.html"><code>ImmutableMap</code></a></td>
</tr>
<tr>
<td><code>SortedMap</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedMap.html"><code>ImmutableSortedMap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#Multiset"><code>Multiset</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultiset.html"><code>ImmutableMultiset</code></a></td>
</tr>
<tr>
<td><code>SortedMultiset</code></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/12.0/api/docs/com/google/common/collect/ImmutableSortedMultiset.html"><code>ImmutableSortedMultiset</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#Multimap"><code>Multimap</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultimap.html"><code>ImmutableMultimap</code></a></td>
</tr>
<tr>
<td><code>ListMultimap</code></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableListMultimap.html"><code>ImmutableListMultimap</code></a></td>
</tr>
<tr>
<td><code>SetMultimap</code></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSetMultimap.html"><code>ImmutableSetMultimap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#BiMap"><code>BiMap</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableBiMap.html"><code>ImmutableBiMap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#ClassToInstanceMap"><code>ClassToInstanceMap</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableClassToInstanceMap.html"><code>ImmutableClassToInstanceMap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#Table"><code>Table</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableTable.html"><code>ImmutableTable</code></a></td>
</tr>
</tbody>
</table>
<h2 id="总结"><span class="section-num">6</span> 总结</h2>
<p>因为不可变容器不会在运行时改变他们的内部状态, 所以他们是线程安全和无副作用的.</p>
<p>因为这些属性, 不可变容器在多线程环境就会变得特别有用, 可以安全地传递数据. 总而言之,
生活和工作或许可以多拥抱变化, 对于代码, 最好还是多保持不变地好.</p>
<h2 id="参考"><span class="section-num">7</span> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/ImmutableCollectionsExplained">Immutable
Collections</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Guava探究系列之二: 优雅校验数据</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%98%E9%9B%85%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 04 Jul 2019 10:16:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%98%E9%9B%85%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE/</guid>
      <description>1 前言 根据防御式编程的要求, 在日常的开发中, 总少不了对函数的各种入参做校验, 以便保证函数能按照预期的流程执行下去. 比如各种费率的值就没可能是</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>根据防御式编程的要求, 在日常的开发中, 总少不了对函数的各种入参做校验,
以便保证函数能按照预期的流程执行下去.</p>
<p>比如各种费率的值就没可能是负数, 如果费率出现负数, 所以数据有问题,
我们需要做的事情就是把这些有问题的数据挑出来.
自己手写这些校验函数未免过于繁琐, 所幸的是我们需要的函数已经有现成的:</p>
<p>Guava 提供了一系列的静态方法用于校验函数和类的构造器是否符合预期,
并称其为前置条件(preconditions). 如果前置条件校验失败,
就会抛出一个指定的异常.</p>
<h2 id="前置函数特征"><span class="section-num">2</span> 前置函数特征</h2>
<p>目前的前置校验方法有如下特征: 须需要, 下面例子中的<code>checkArgument</code>函数可以替换成任何一个前置条件校验函数</p>
<ol>
<li>这些前置方法一般接受一个布尔表达式作为入参，并判断表达是否为<code>true</code>,
格式如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果表达式为false, 抛出IllegalArgumentException
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>除了用于判断的布尔表达式之外,
前置方法可以接受一个额外的<code>Object</code>作为入参, 在抛出异常的时候,
把<code>Object.toString()</code>作为异常信息, 如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">enum</span> <span class="n">ErrorDetail</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SC_NOT_FOUND</span><span class="o">(</span><span class="s">&#34;404&#34;</span><span class="o">,</span> <span class="s">&#34;Resource could not be fount&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略部分内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;ErrorDetail{&#34;</span> <span class="o">+</span> <span class="s">&#34;code=&#39;&#34;</span> <span class="o">+</span> <span class="n">code</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span> <span class="s">&#34;, description=&#39;&#34;</span> <span class="o">+</span> <span class="n">description</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span> <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCheckArgument</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">ErrorDetail</span><span class="o">.</span><span class="na">SC_NOT_FOUND</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结果如下:
</span></span></span><span class="line"><span class="cl"><span class="c1">// java.lang.IllegalArgumentException: ErrorDetail{code=&#39;404&#39;, description=&#39;Resource could not be fount&#39;}
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Guava的前置表达式还支持类似<code>printf</code>函数那样的格式化输出错误信息,
只不过出于兼容性和性能的考虑, 只支持使用<code>%s</code>指示符格式化字符串,
不支持其他类型. 如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">checkArgument</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&#34;Argument was %s but expected nonnegative&#34;</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果如下:
</span></span></span><span class="line"><span class="cl"><span class="c1">// java.lang.IllegalArgumentException: Argument was -1 but expected nonnegative
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="前置条件函数介绍"><span class="section-num">3</span> 前置条件函数介绍</h2>
<p>须注意的是, 下面介绍的<code>checkArgument</code>, <code>checkArgument</code>,
<code>checkState</code>函数都有三个对应的重载函数，分别对应前文所述的三种特征,
下文不会三种函数都介绍, 只介绍标准格式的前置条件函数.
以<code>checkArgument</code>函数为例, 三个重载函数分别是(忽略函数体):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">Object</span> <span class="n">errorMessage</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span><span class="nd">@Nullable</span> <span class="n">String</span> <span class="n">errorMessageTemplate</span><span class="o">,</span><span class="nd">@Nullable</span> <span class="n">Object</span><span class="o">...</span> <span class="n">errorMessageArgs</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkargument"><span class="section-num">3.1</span> checkArgument</h3>
<p>函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>入参是一个布尔表达式, 函数校验这个表达式是否为<code>true</code>, 如果为<code>false</code>,
抛出<code>IllegalArgumentException</code>. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCheckArgument</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checknotnull"><span class="section-num">3.2</span> checkNotNull</h3>
<p>这是个泛型函数, 函数签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">checkNotNull</span><span class="o">(</span><span class="n">T</span> <span class="n">reference</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>入参是个任意类型的对象, 函数校验这个对象是否为<code>null</code>, 如果为空,
抛出<code>NullPointerException</code>, 否则直接返回该对象,
所以<code>checkNotNull</code>的用法就比较有趣, 可以在调用<code>setter</code>方法前作前置校验.
例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">PreconditionTest</span> <span class="n">caller</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PreconditionTest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">caller</span><span class="o">.</span><span class="na">setErrorDetail</span><span class="o">(</span><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">ErrorDetail</span><span class="o">.</span><span class="na">SC_INTERNAL_SERVER_ERROR</span><span class="o">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkstate"><span class="section-num">3.3</span> checkState</h3>
<p>函数签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkState</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看着这个函数, 我个人感觉很奇怪:
这个函数和<code>checkNotNull</code>函数功能非常相似, 实现也基本一样,
都是判断表达式是否为<code>true</code>, 只是抛出的异常不一样而已,
是否有必要开发这个函数. 两个函数的实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(!</span><span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkState</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(!</span><span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此外, 因为这两个函数相当类似, 就不展示相应例子了.</p>
<h3 id="checkelementindex"><span class="section-num">3.4</span> checkElementIndex</h3>
<p>函数签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">checkElementIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数用于判断指定数组, 列表, 字符串的下标是否越界, <code>index</code>是下标,
<code>size</code>是数组, 列表或字符串的长度, 下标的有效范围是<code>[0,数组长度)</code> 即
<code>0&lt;=index&lt;size</code>. 如果数组下标越界(即<code>index=&lt;0 或者 =index=&gt;==size</code>),
那么抛出<code>IndexOutOfBoundsException</code>异常, 否则返回数组的下标,
也就是<code>index</code>. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkElementIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: index (4) must be less than size (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkElementIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 通过
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="checkpositionindex"><span class="section-num">4</span> checkPositionIndex</h2>
<p>函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">checkPositionIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数和<code>checkElementIndex</code>非常类似, 连Guava wiki的说明也基本一致(只有一个单词不同).</p>
<p>除了一点, <code>checkElementIndex</code>函数的下标有效范围是<code>[0, 数组长度)</code>, 而<code>checkPositionIndex</code>函数的下标有有效范围是<code>[0, 数组长度]</code>,
即<code>0&lt;=index&lt;=size</code>. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 通过
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkpositionindexes"><span class="section-num">4.1</span> checkPositionIndexes</h3>
<p>函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkPositionIndexes</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数是用于判断<code>[start,end]</code>这个范围是否是个有效范围, 即<code>[start, end]</code> 是否在<code>[0, size]</code> 范围内(如果<code>[start, end]</code>
和<code>[0, size]</code>相同, 也认为在范围内), 如果不在, 则抛出<code>IndexOutOfBoundsException</code>异常. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndexes</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: end index (3) must not be greater than size (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndexes</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 校验通过
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="前置条件在实际项目的应用"><span class="section-num">5</span> 前置条件在实际项目的应用</h2>
<p>前置条件在检验条件不成交的时候抛的异常类型虽说是合情合理(比如,
<code>checkArgument</code>函数抛出<code>IllegalArgumentException</code>),</p>
<p>但是对于业务系统来说, 你抛出个<code>IllegalArgumentException</code>或者<code>NullPointerException</code>, 接口调用方对于这个异常摸不着头脑, 虽说只是正常的数据问题,
还是很容易觉得接口提供方服务出了问题, 甚至还会被质疑技术不过硬.</p>
<p>咱们又不是底层组件, 抛个<code>NPE</code>, 着实是不成体统. 基于各种有的没的的原因,
我们的业务系统在使用前置条件的时候进行了封装,
将前置条件抛出的异常进行了转换, 换成正常的业务异常, 提供完整的异常信息,
代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 封装代码:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">AssertUtils</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检查条件表达式是否为真
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param expression 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param errDetailEnum 错误码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param msgTemplate 错误消息模板
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param vars 占位符对应变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws BkmpException 条件表达式结果为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span> <span class="n">ErrDetailEnum</span> <span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">String</span> <span class="n">msgTemplate</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				     <span class="n">Object</span><span class="o">...</span> <span class="n">vars</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="n">expression</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">throw</span> <span class="k">new</span> <span class="n">BkmpException</span><span class="o">(</span><span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">msgTemplate</span><span class="o">,</span> <span class="n">vars</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检查条件表达式是否为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param expression 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param errDetailEnum 错误码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param msgTemplate 错误消息模板
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param vars 占位符对应变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws BkmpException 条件表达式结果为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgumentNotTrue</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span> <span class="n">ErrDetailEnum</span> <span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">String</span> <span class="n">msgTemplate</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">					    <span class="n">Object</span><span class="o">...</span> <span class="n">vars</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(!</span><span class="n">expression</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">throw</span> <span class="k">new</span> <span class="n">BkmpException</span><span class="o">(</span><span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">msgTemplate</span><span class="o">,</span> <span class="n">vars</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 省略其他部分的封装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 调用例子:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">AssertUtils</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="n">merchantEntity</span><span class="o">.</span><span class="na">exist</span><span class="o">(),</span> <span class="n">ErrDetailEnum</span><span class="o">.</span><span class="na">DATA_NOT_EXIT</span><span class="o">,</span> <span class="s">&#34;商户不存在&#34;</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="guava-precondition-vs-apache-common-validate"><span class="section-num">6</span> Guava Precondition vs Apache Common Validate</h2>
<p>自古文无第一, 武无第二, 文人之间的口水战总是少不了的.</p>
<p>没想到这不是国人的专利, 原来国外也有文人相轻的风气: Guava wiki
在介绍完preconditions之后, 还踩了一波竞品Apache Common Validate,
认为Guava的preconditions 比Apache Common 更加清晰明了, 也更加美观,</p>
<p>我个人对Apache Common Validate 了解不深, 也不好随意置喙. 除了踩竞品之外,
Guava wiki 还提了两点最佳实践(best practice):</p>
<ol>
<li>使用前置条件校验的时候, 推荐每个校验条件单独一行, 这样即更了然,
出问题也更方便调试.</li>
<li>使用前置条件校验的时候, 尽量提供有用的错误信息,
这样可以更快地定位问题.</li>
</ol>
<h2 id="总结"><span class="section-num">7</span> 总结</h2>
<p>代码大全一书有一章是关于防御式编程的, 用于提高程序的健壮性, 主要思想是子程序应该不因传入错误数据而被破坏，要保护程序免遭非法输入数据的破坏.</p>
<p>而Guava的preconditions 就是实现防御式编程的有力工具呢. oh yeah!</p>
<h2 id="参考"><span class="section-num">8</span> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/PreconditionsExplained">PreconditionsExplained</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Guava探究系列之一: 使用和避免使用空指针</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 02 Jul 2019 19:25:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8C%87%E9%92%88/</guid>
      <description>1 前言 To be, or not to be, that is the question: 先来看看奆佬们关于空指针的看法: Null sucks - Doug Lea(JCP,Java并发编程实战作者, Java巨佬) I call it my billion-dollar mistake. - Sir C.</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<blockquote>
<p>To be, or not to be, that is the question:</p>
</blockquote>
<p>先来看看奆佬们关于空指针的看法:</p>
<blockquote>
<p>Null sucks - <a href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a>(JCP,Java并发编程实战作者, Java巨佬)</p>
<p>I call it my billion-dollar mistake. - <a href="https://en.wikipedia.org/wiki/C._A._R._Hoare">Sir C. A. R. Hoare</a>, 空指针的发明者</p>
</blockquote>
<p>按照Guava wiki的说法,
大部分的Google代码都是不支持使用空指针(下文用<code>null</code>表示空指针)的,</p>
<p>如接近95%的集合类都不支持使用<code>null</code>作为集合元素.
像Google这样的大公司明确不建议使用<code>null</code>自然是有其原由的, 不会无的放矢.
那具体原因是什么呢？待下文为你细细道来;</p>
<h2 id="空指针的问题"><span class="section-num">2</span> 空指针的问题</h2>
<h3 id="空指针语意隐晦不明"><span class="section-num">2.1</span> 空指针语意隐晦不明</h3>
<p><code>null</code>的语意并不了然明确, 即当一个函数返回<code>null</code>, 我们并不知道<code>null</code>的意思是指返回结果理应为空? 还是指函数没有达到预期结果, 返回<code>null</code>表示失败?</p>
<p>举个常见的例子, 当调用<code>Map.get(key)</code>获取key对应的value的时候, 返回结果为<code>null</code>; <code>null</code>是指找不到这个key对应的value?
还是说这个key对应的value本身就是<code>null</code>, 原来是通过<code>Map.put(key,value)</code>赋值的呢? <code>null</code>甚至可以是代表其他东西!</p>
<p>老实说, 当我们获得一个<code>null</code>, 我们并不清楚它究竟指的是啥,
除非有对应的javadoc 进行了说明.</p>
<h3 id="空指针-暗藏杀机"><span class="section-num">2.2</span> 空指针”暗藏杀机”</h3>
<p><code>null</code>除了语意不明外, 还非常容易在不经意间挖坑坑人. 例如有下面的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="n">String</span> <span class="nf">testNull</span><span class="o">(</span><span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">input</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">useNull</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">testNull</span><span class="o">(</span><span class="s">&#34;foo#bar&#34;</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="s">&#34;#&#34;</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">testNull</span><span class="o">(</span><span class="s">&#34;foo#bar&#34;</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="s">&#34;#&#34;</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可能你会说，这样的明显有坑的代码, 程序员理所当然会注意,
并对<code>null</code>指针进行校验的.</p>
<p>但事实并非如此, 因为<code>null</code>是一个特殊类型,
它可以表示一切的类型, 所以上面的代码是肯定可以编译通过的.
没有了编译器的约束, 只要使用<code>testNull</code>函数的时候没有查看源码,
或者源码非常复杂, 一下子理不清思路, 防御式编程落实不到,
就会忽略了<code>null</code>, 运行时就有可能抛出<code>NullPointException</code>, 导致程序crash.
这种情况真的防不胜防.</p>
<h2 id="guava对于空指针的态度"><span class="section-num">3</span> Guava对于空指针的态度</h2>
<p>因为上文提到或者隐藏但没提到的种种问题,
Guava的诸多类库在设计时就不支持<code>null</code>.</p>
<p>如果检测到<code>null</code>的存在, Guava的类库就会快速失败(fail fast),一般的处理策略是抛出异常.
虽说<code>null</code>存在种种的坑, 但<code>null</code>依旧是Java的一项关键特性,
因此Guava的类库也不能将<code>null</code>彻底拒之门外.</p>
<p>此外, Guava秉承既然不能消灭<code>null</code>, 那就把<code>null</code>建设得更好用的理念,
除了提供了一些工具可以让开发者避免使用<code>null</code>,
还提供了可以让开发者更易于使用<code>null</code>的工具.</p>
<h2 id="optional"><span class="section-num">4</span> Optional</h2>
<p>在很多情况下, 程序员使用<code>null</code>是为了表示有些值可能存在或者不存在.
我们又可以用熟悉的<code>Map.get(key)</code>函数来举例,
如果规定<code>null</code>不能作为<code>value</code>值使用(但事实并非如此),
那么当这个函数返回<code>null</code>时就代表没有找到这个<code>key</code>对应的<code>value</code>.</p>
<p>为了应对这种使用<code>null</code>的情况, Guava团队参考其他语言(例如Scala)应对<code>null</code>的实践, 开发了<code>Optional&lt;T&gt;</code>类.
<code>Optional</code>类表示那些可能为空的值, 一个<code>Optional</code>类要不包含一个非空的<code>T</code>类型的对象引用(这种情况下,
我们称引用对象是存在的-&ldquo;present&rdquo;), 要不什么东西都不包含(这种情况被, 我们说引用对象是不存在的-&ldquo;absent&rdquo;), 除此之外, <code>Optional</code>不存在其他情况, 更没有可能是<code>null</code>.</p>
<h3 id="java8的optional"><span class="section-num">4.1</span> Java8的Optional</h3>
<p>鉴于我对<code>Optional</code>类的兴趣,
我用下面这条命令找了一个Guava库<code>Optional</code>开发的最初提交历史:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">find guava/ -name <span class="s2">&#34;Optional.java&#34;</span> -print <span class="p">|</span> xargs -I <span class="s1">&#39;{}&#39;</span> git log --pretty<span class="o">=</span>tformat:%cd-%aN-%s --date<span class="o">=</span>iso <span class="p">|</span>tail -n2
</span></span><span class="line"><span class="cl"><span class="c1"># 结果如下</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2009-09-15 19:50:59 +0000-kevinb@google.com-Initial code dump: version 9.09.15</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2009-06-18 18:11:55 +0000-(no author)-Initial directory structure.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从Guava的commit历史中, 我们可以知道<code>Optional</code>最开始是在2009年开始开发的,
而10年前还是Java6的时代, Java7都尚未发布.</p>
<p>在那个”远古年代”, 是Guava的<code>Optional</code>一直引领着Java的抗击<code>null</code>重任,
为众多的蒙受”空指针之苦”的Java的程序员带来希望之光.</p>
<p>而当时光的脚步终于来到2014年3月18号, 在这一天, Java程序员迎来了Java8,
这是自Java5发布以来最激动人心的发布. 这天之后, 尘埃落定, <code>Optional</code>,
<code>Stream</code>, <code>Lambda</code>等诸多令人期待已久的特性终于成为Java的标准库的一部分,
而这也意味, Guava的<code>Optional</code>已经完成了自己的使命, 成为历史.</p>
<p>Guava的<code>Optional</code>类与JDK的<code>Optional</code>功能类似,
既然JDK的<code>Optional</code>已成为正统,
那么下面我就不再介绍Guava的<code>Optional=(Guava的wiki本来是有较大篇幅介绍自家的=Optional</code>,
个人感觉已经意义不大), 转而介绍JDK的<code>Optional=(下文通称为=Optional</code>).</p>
<h3 id="optional构造方式"><span class="section-num">4.2</span> Optional构造方式</h3>
<p>在使用<code>Optional</code>之前, 首先需要了解如果构造<code>Optional</code>对象,
方式有如下几种:</p>
<h4 id="声明一个空的-optional-对象"><span class="section-num">4.2.1</span> 声明一个空的<code>Optional</code>对象</h4>
<p>可以通过静态工厂方法<code>Optional.empty</code>, 创建一个空的<code>Optional</code>对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">optional</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="根据一个非空值创建optional"><span class="section-num">4.2.2</span> 根据一个非空值创建Optional</h4>
<p>还可以使用静态工厂方法<code>Optional.of</code>,
依据一个非空值创建一个<code>Optional</code>对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">optional</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">objectT</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是, 按照<code>Optional</code>的源码声明, 如果传入的<code>objectT</code>为<code>null</code>,
那么<code>Optional</code>就会立刻抛出<code>NullPointException=(这就是快速失败-fail fast), 而还是等到访问=optional</code>属性时才返回一个错误.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Returns an {@code Optional} with the specified present non-null value.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param &lt;T&gt; the class of the value
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param value the value to be present, which must be non-null
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return an {@code Optional} with the value present
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws NullPointerException if value is null
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">Optional</span><span class="o">&lt;&gt;(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="可接受null的optional"><span class="section-num">4.2.3</span> 可接受null的Optional</h4>
<p>最后, 使用静态工厂方法<code>Optional.ofNullable</code>,
我们可以创建一个允许<code>null</code>的<code>Optional</code>的对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">optional</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">objectT</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果<code>objectT</code>为<code>null</code>, 那么得到的<code>Optional</code>对象就是个空对象.</p>
<h3 id="optional的消费方式"><span class="section-num">4.3</span> Optional的消费方式</h3>
<h4 id="optional与stream的邂逅"><span class="section-num">4.3.1</span> Optional与Stream的邂逅</h4>
<p>既然<code>Optional</code>在Oracle的文档中被定性为一个容器(container),</p>
<p>那么对于一个容器,
我们关注的点无非是这个容器如何<strong>存*(对于<code>Optional</code>来说是构造)和如何</strong>取*这两件事而已(也就是消费).
在谈<code>Optional</code>的消费接口之前,
先来回顾一下Java8引进的<code>Stream</code>操作(关于Java8
<code>Stream</code>操作的说明已经汗牛充栋了, 既然珠玉在前, 我就不赘言了),
常用的<code>Stream</code>操作函数有如下几个:</p>
<ul>
<li>filter</li>
<li>map</li>
<li>flatmap</li>
<li>peek</li>
<li>reduce</li>
<li>更多的函数可以参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Oracle文档</a></li>
</ul>
<p>因为前文已经说过<code>Optional</code>是容器类, 那么按理来说,
正常容器类支持的<code>Stream</code>操作, <code>Optional</code>也支持.</p>
<p>只不过在Java8的时候, <code>Optional</code>只支持<code>filter</code>,=map=和<code>flatmap</code>这三个<code>Stream</code>操作.</p>
<p>可能是因为Java委员会的奆佬们也觉得<code>Optional</code>身为一个容器类只支持三个<code>Stream</code>操作有点丢人,
所以在Java9,
<code>Optional</code>增加了一个<code>Optional.stream()</code>这样一个可以返回<code>Stream</code>对象的函数,
让<code>Optional</code>拥有了容器类操作<code>Stream</code>的所有能力,
重振了身为一个容器的荣光. <code>Optional</code>与<code>Stream</code>结合使用的示例如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">String</span> <span class="nf">getCarInsuranceName</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">person</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">Person</span><span class="o">::</span><span class="n">getCar</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">car</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;Spaceship&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">Car</span><span class="o">::</span><span class="n">getInsurance</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">Insurance</span><span class="o">::</span><span class="n">getName</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">&#34;Unknown&#34;</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="默认行为及解引用optional对象"><span class="section-num">4.3.2</span> 默认行为及解引用Optional对象</h4>
<p>除了使用<code>Stream</code>来消费<code>Optional</code>对象,
还可以使用解引用读取<code>Optional</code>实例中的变量值以及定义默认行为,
具体函数说明如下:</p>
<ol>
<li><code>get()</code>是这些方法中最简单但又最不安全的方法. 如果变量存在,
它直接返回封闭的变量值. 否则就抛出一个<code>NoSuchElementException</code>异常.
所以, 除非是非常确定<code>Optional</code>变量一定包含值,
否则使用这个函数就相当容易踩坑. 此外,
使用这个函数和直接进行<code>null</code>检查差别并不大.</li>
<li><code>orElse(T other)</code>
该函数允许在<code>Optional</code>对象不存在的时候提供一个默认值(也是我个人最常用的使用方式之一)</li>
<li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>是<code>orElse</code>函数的延迟调用版,
<code>Supplier</code>方法只有在<code>Optional</code>对象不含值的时候才执行.
如果创建默认值是件耗时操作, 那么可以使用这种方式来提升性能,
又或者某个函数仅在<code>Optional</code>为空的时候才调用, 也可以使用这种方式</li>
<li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>
和<code>get</code>方法非常类似, 这两个函数都会在<code>Optional</code>对象为空时, 抛出异常,
但差别在于<code>orElseThrow</code>可以指定抛出的异常类型</li>
<li><code>ifPresent(Consumer&lt;? super T&gt;)</code>和<code>orElseGet</code>函数类似,
可以在变量存在的时候执行传入的函数, 否则就不进行任何操作.</li>
</ol>
<h4 id="optional-实战示例"><span class="section-num">4.3.3</span> Optional 实战示例</h4>
<p>在啰啰嗦嗦介绍了一系列<code>Optional</code>的概念之后,
是时候来看一下<code>Option</code>的实例了. 现存的Java
API几乎都是通过返回一个null的方式表示所需的值的缺失,
或者由于某些原因计算无法得到所需的值.</p>
<p>在上文, 我们已经给<code>null</code>盖棺定论了, <code>null</code>是有坑的, 甚至是有害的,
所以要尽量少用<code>null</code>. 而现存的海量Java API都已经使用<code>null</code>作为返回结果,
我们没可能把这些API都重构成返回一个<code>Optional</code>对象的, 但眼看着<code>Optional</code>这样一个设计更完善无法在已有的Java API中使用未免令人心有不甘.</p>
<p>现实中, 可能我们无法修改这些API的签名, 但是我们却可以很轻易地用<code>Optional</code>对象对这些API的返回值进行封装.
现在还是用熟悉的<code>Map</code>举例, 假设有一个<code>Map&lt;String, Object&gt;</code>的对象, 在查询<code>key</code>对应的<code>value</code>时, 如果<code>value</code>不存在,
那么调用<code>Map.get(key)</code>就会返回一个<code>null</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在, 每次使用<code>value</code>都需要进行空指针判断, 着实是太繁琐.
为了解决这个问题, 可以使用<code>Optional.ofNullable</code>函数进行优化:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></span><span class="line"><span class="cl"><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">,</span> <span class="s">&#34;bar&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">)).</span><span class="na">map</span><span class="o">(</span><span class="n">Object</span><span class="o">::</span><span class="n">toString</span><span class="o">).</span><span class="na">orElse</span><span class="o">(</span><span class="s">&#34;helloworld&#34;</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样, 每次使用<code>value</code>都不会再有<code>NullPointException</code>的忧虑.</p>
<h2 id="结语"><span class="section-num">5</span> 结语</h2>
<p>本文最开始只是想阐述Guava类库使用空指针和避免使用空指针的设计理念,
只是因为Guava大部分类库都是不支持<code>null</code>,
因此使用Guava自家的<code>Optional</code>类来代替<code>null</code>的大部分应用场景,
而Guava自家的<code>Optional</code>无可避免地被JDK的<code>Optional</code>取代,</p>
<p>所以本文大部份的内容也变成对JDK的<code>Optional</code>的探讨.
相信下篇文章会有所改观, 总不可能Guava所有的工具类, 都有JDK对应的竞品,
如果真是这样的话, JDK应该改名为GDK :)</p>
<h2 id="参考"><span class="section-num">6</span> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained">Using and avoiding</a></li>
<li><a href="https://book.douban.com/subject/25912747/">Java8 in Action</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Oracle java doc about Optional</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>一条经典面试题的错误答案引发的思考</title>
      <link>https://ramsayleung.github.io/zh/post/2019/%E4%B8%80%E6%9D%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Thu, 21 Mar 2019 11:04:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/%E4%B8%80%E6%9D%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>浅谈Java公平锁与内存模型 1 前言 春天来了，春招还会远么? 又到了春招的季节，随之而来的是各种的面试题。今天就看到组内大佬面试实习生的一道Ja</description>
      <content:encoded><![CDATA[<p>浅谈Java公平锁与内存模型</p>
<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>春天来了，春招还会远么? 又到了春招的季节，随之而来的是各种的面试题。今天就看到组内大佬面试实习生的一道Java题目:</p>
<blockquote>
<p>编写一个程序，开启 3 个线程A,B,C，这三个线程的输出分别为
A、B、C，每个线程将自己的 输出在屏幕上打印 10
遍，要求输出的结果必须按顺序显示。如：ABCABCABC&hellip;.</p>
</blockquote>
<h2 id="经过"><span class="section-num">2</span> 经过</h2>
<p>出于好奇的心态，我花了点时间来尝试解决这个问题, 主要的难点是让线程顺序地如何顺序地输出，线程之间如何交换。</p>
<p>很快就按着思路写出了一个版本，用Lock 来控制线程的顺序，A,B,C线程依次启动，因为A线程先启动，所以A线程会最先拿到锁，B,C阻塞；但是A输出完字符串，释放锁，B 线程获得锁，C,A线程阻塞; 依此循环:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">Test</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Integer</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testLock</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="n">work</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="n">work</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;B&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">Thread</span> <span class="n">threadC</span> <span class="o">=</span> <span class="n">work</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;C&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">threadC</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Thread</span> <span class="nf">work</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">condition</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">		    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">index</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">function</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">index</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">		    <span class="o">}</span>
</span></span><span class="line"><span class="cl">		    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">});</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>输入结果如我预期那般，ABCABC交替输出，也成功输出了10次，奇怪的是A,B却多输出了一次？
<img loading="lazy" src="https://imgur.com/3lolbwK.png" alt=""  />
</p>
<p>为什么会多输出一次，不是应该恰好是输出30次么, 为什么会多输出一次A,B
真的百思不得其解. 所以我把<code>index</code> 也打印出来查看, 结果相当奇怪:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">....</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为什么A 会是30, B会是31, 不是有(index.intvalue&lt;30) 的条件判断么,
为什么还会出现这样的数据？灵异事件? <img loading="lazy" src="https://imgur.com/fhurKt5.png" alt=""  />
</p>
<h2 id="解惑"><span class="section-num">3</span> 解惑</h2>
<p>灵异事件自然是不存在的，仔细分析了一番代码之后，发现了问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">while</span> <span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">intValue</span><span class="o">()))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">function</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">index</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将1，2行的操作做了这三件事，如下:</p>
<ol>
<li><strong>线程读取index的值</strong></li>
<li>比较index的值是否大于30 3. 如果小于30, 尝试获取锁</li>
</ol>
<p>换言之，当index=29时，线程C持有锁，但是锁只能阻止线程A,线程B修改index的值，并不能阻止线程A,线程B在获取锁之前读取index的值，所以线程A读取index=29,并把值保持到线程的内部，如下图:</p>
<figure>
    <img loading="lazy" src="https://imgur.com/tI8NTgO.png"/> 
</figure>

<p><strong>当线程C执行完，还没释放锁的时候，线程A的index值为29；当线程C释放锁，线程A获取锁，进入同步块的时候，因为 <a href="https://en.wikipedia.org/wiki/Memory_barrier#Multithreaded_programming_and_memory_visibility">Java内存模型有内存可见性的要求</a>, 兼之Lock的实现类实现了<a href="https://stackoverflow.com/questions/12429818/does-explicit-lock-automatically-provide-memory-visibility">内存可见</a>，所以线程A的index值会变成30</strong>,</p>
<p>这就解析了为什么线程A index=30的时候能跳过<code>(index.intValue&lt;30)</code>的判断条件，因为执行这个判断条件的时候线程A index=29, 进入同步块之后变成了30:</p>
<figure>
    <img loading="lazy" src="https://imgur.com/xaA4Q0y.png"/> 
</figure>

<p>把问题剖析清楚之后，解决方案就呼之欲出了:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">while</span> <span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="o">(</span><span class="n">index</span><span class="o">&gt;=</span><span class="mi">30</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">intValue</span><span class="o">()))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">function</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">index</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种解决方法不禁让我想起单例模式里面的双重校验:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getSingleton</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>                         <span class="c1">//Single Checked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">synchronized</span> <span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>                 <span class="c1">//Double Checked
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">instance</span> <span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>只是当时并不清楚Double Checked的作用，究竟解决了什么问题？</p>
<p>只是知道不加这条语句就会造成初始化多个示例，的确是需要<strong>知其然知其所以然</strong>.</p>
<h2 id="公平锁问题"><span class="section-num">4</span> 公平锁问题</h2>
<p>前文说到，</p>
<blockquote>
<p>这个程序是用Lock 来控制线程的顺序，A,B,C线程依次启动，因为A线程先启动，所以A线程会最先拿到锁，B,C阻塞；</p>
<p>但是A输出完字符串，释放锁，B 线程获得锁，C,A线程阻塞; 依此循环。</p>
</blockquote>
<p>粗看似乎没什么问题, 但是这里是存在着一个问题: 当线程A释放锁的时候，获取锁的是否一定是线程B, 而不是线程C,
线程C是否能够”插队”抢占锁?</p>
<p>这个就涉及到了公平锁和非公平锁的定义了:</p>
<ul>
<li>
<p>公平锁: 线程C不能抢占，只能排队等待线程B 获取并释放锁</p>
</li>
<li>
<p>非公平锁：线程C能抢占，抢到锁之后线程B只能继续等(有点惨!)</p>
<p>而ReentrantLock默认恰好是非公平锁, 查看源码可知:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">​ * Creates an instance of {@code ReentrantLock}.
</span></span></span><span class="line"><span class="cl"><span class="cm">​ * This is equivalent to using {@code ReentrantLock(false)}.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此为了规避非公平锁抢占的问题, 上述的代码在同步块增加了判断条件:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">index</span><span class="o">.</span><span class="na">intValue</span><span class="o">()))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">....</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>只有符合条件的线程才能进行操作，否则就是线程自旋.(但是加锁+自旋实现起来，效率不会太高效!)</p>
</li>
</ul>
<h2 id="小结"><span class="section-num">5</span> 小结</h2>
<p>写一条面试题的答案都写得是问题多多的，不禁令人沮丧，说明自己对Java的并发模型理解还有很大的提高。
不过在排查问题的过程中，通过实践有体感地理解了Java的内存模型，发现Java内存模型并不是那么地曲高和寡，在日常的开发中也是很常见的.</p>
<p>费了一番工夫排查之后，终究是有新的收获的</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>How to fool the Jacoco ◜◡‾</title>
      <link>https://ramsayleung.github.io/zh/post/2019/%E5%A6%82%E4%BD%95%E5%88%B7pojo%E7%B1%BB%E7%9A%84%E5%8F%98%E6%9B%B4%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87/</link>
      <pubDate>Thu, 14 Mar 2019 11:14:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/%E5%A6%82%E4%BD%95%E5%88%B7pojo%E7%B1%BB%E7%9A%84%E5%8F%98%E6%9B%B4%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87/</guid>
      <description>刷POJO类的变更行覆盖率 1 反射大法好 1.1 背景 众所周知，蚂蚁对代码质量要求很高，质量红线其中一项指标就是变更行覆盖率。如果你的变更行覆盖率没有</description>
      <content:encoded><![CDATA[<p>刷POJO类的变更行覆盖率</p>
<h2 id="反射大法好"><span class="section-num">1</span> 反射大法好</h2>
<h3 id="背景"><span class="section-num">1.1</span> 背景</h3>
<p>众所周知，蚂蚁对代码质量要求很高，质量红线其中一项指标就是变更行覆盖率。如果你的变更行覆盖率没有达到80%，测试同学是不会允许你上测试环境的（如果对此有所不满，测试同学就会过来捶你)。
为了提高代码质量，这项要求倒是无可厚非，变更的代码逻辑需要充分的测试；但是如果我新增了一堆的POJO类，只是为了逻辑模型，变更行也会变得非常可观。为了覆盖这些POJO类的变更，你免不了会测试一堆的Getter/Setter
方法：</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191104102036.png"
         alt="Figure 1: getter/setter"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>getter/setter</p>
        </figcaption>
</figure>

<p>(红色是指没有覆盖到的变更行)</p>
<h3 id="反射"><span class="section-num">1.2</span> 反射</h3>
<p>如果为了变更行覆盖了，我要写上一堆的Getter/Setter 方法测试用例，测试用例也只是单纯调用一下方法，未免过于痛苦，能否偷个懒，解决覆盖率问题，也不需手写这些没啥用的测试用例.</p>
<p>但是一时间没有想到解决方法，我就一边写这些没啥用的用例，一边思考，突然发现了规律：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">SomeType</span> <span class="nf">getXxxx</span><span class="o">(){}</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setXxxx</span><span class="o">(</span><span class="n">SomeType</span> <span class="n">Xxx</span><span class="o">){}</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">SomeType</span> <span class="nf">getYyy</span><span class="o">(){}</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setYyyy</span><span class="o">(</span><span class="n">SomeType</span> <span class="n">Yyyy</span><span class="o">){}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所有这些方法都是的前缀都是 <code>set/get</code> (真.废话)，如果我能获取一个Pojo类所有的方法，然后循环执行所有以<code>get/set</code>开头的方法，不就不用手动写方法了么?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MerchantBusiModelTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">LOGGER</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">ModelUtils</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * get类型方法的前缀
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">GET_METHOD_PREFIX</span> <span class="o">=</span> <span class="s">&#34;get&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * set类型方法的前缀
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">SET_METHOD_PREFIX</span> <span class="o">=</span> <span class="s">&#34;set&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MerchantBusiModel</span> <span class="n">merchantBusiModel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MerchantBusiModel</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testModel</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">merchantBusiModel</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">if</span> <span class="o">(</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">		<span class="o">&amp;&amp;</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="n">GET_METHOD_PREFIX</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Object</span><span class="o">[]</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">method</span><span class="o">.</span><span class="na">getParameterCount</span><span class="o">()];</span>
</span></span><span class="line"><span class="cl">		<span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">merchantBusiModel</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		    <span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法, method: {}.{}&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				    <span class="n">merchantBusiModel</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">				    <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法异常, method: {}.{}&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				    <span class="n">merchantBusiModel</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">				    <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法异常, method: {}.{}&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				    <span class="n">merchantBusiModel</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">				    <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样很快就把<code>MerchantBusiModel</code>所有的get方法执行了(set
方法也同理啦)，调用结果如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632162,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getMcc]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632256,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getOutMerchantId]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632256,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getMerchantName]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632256,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getMerhantType]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632256,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getDealType]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632257,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getAlias]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632257,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getLegalPerson]
</span></span><span class="line"><span class="cl">19/03/14 10:46:32 WARN util.ModelUtils: (,N,20190314104632257,-,,,-,-,-,)[调用方法, method: MerchantBusiModel.getPrincipalCertType]
</span></span><span class="line"><span class="cl">省略一大片类似的输出，省点篇幅
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="org-dot-reflections-dot-reflections"><span class="section-num">1.3</span> org.reflections.Reflections</h3>
<p>通过反射，就很完美地解决了POJO类的变更行覆盖率问题了，反正POJO类都是Getter/Setter 方法，我的反射方法能把它们全覆盖上啦 (๑&gt;◡&lt;๑) .</p>
<p>很快，我就遇到了另外的一个问题:
像<code>MerchantBusiModel</code>这样的Model类有十几二十个，难道每个Model我都需要写一个<code>XxxModelTest</code>的测试类么？也实在是太痛苦了，也太不优雅了(其实是我懒)，能不能自动把所有的Model类扫出来，然后循环执行每个Model的Getter/Setter方法呢？</p>
<p>因为这些Model都是继承一个统一的基类<code>BaseBusiModel</code>, 能否把这个基类的所有子类搞出来，这样就可以开心地用反射解决问题了.</p>
<p>调研一番之后发现，Jdk 的反射方式不支持遍历父类所有子类的方法，这做法行不通阿!!!</p>
<p>在我都几乎要放弃，要手写所有ModelTest的时候，我在StackOverFlow上面找到了 <a href="https://github.com/ronmamo/reflections">reflections</a> 这第三方包，发现这个包非常强大(niubility), 可以获取基类的子类或者接口的实现类:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Reflections</span> <span class="n">reflections</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Reflections</span><span class="o">(</span><span class="s">&#34;my.project&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Set</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">SomeType</span><span class="o">&gt;&gt;</span> <span class="n">subTypes</span> <span class="o">=</span> <span class="n">reflections</span><span class="o">.</span><span class="na">getSubTypesOf</span><span class="o">(</span><span class="n">SomeType</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>简直了。在这”牛包”的帮助下，成功实现了扫描某个package下面所有基类的实现类的方法, 我的用例有救了:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ModelTest</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">LOGGER</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">ConvertorTest</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PACKAGE_NAME</span> <span class="o">=</span> <span class="s">&#34;xxx.xxx.core.service.v1.busimodel&#34;</span><span class="o">;</span> <span class="c1">// model所有的包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Test</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testModel</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Reflections</span> <span class="n">reflections</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Reflections</span><span class="o">(</span><span class="n">PACKAGE_NAME</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Set</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">BaseBusiModel</span><span class="o">&gt;&gt;</span> <span class="n">classes</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">	    <span class="n">reflections</span><span class="o">.</span><span class="na">getSubTypesOf</span><span class="o">(</span><span class="n">BaseBusiModel</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">BaseBusiModel</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">:</span> <span class="n">classes</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">if</span> <span class="o">(</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isAbstract</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">continue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl">	    <span class="n">BaseBusiModel</span> <span class="n">modelInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	    <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">modelInstance</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法IllegalAccessException异常, clazz: {}&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				<span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InstantiationException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法InstantiationExceptionn异常, clazz: {}&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				<span class="n">clazz</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl">	    <span class="n">ModelUtils</span><span class="o">.</span><span class="na">invokeGetAndSetMethod</span><span class="o">(</span><span class="n">modelInstance</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>ModelUtils.invokeGetAndSetMethod(modelInstance);</code> 这个静态方法就是上一节反射方法的完整可用版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ModelUtils</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">protected</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">LOGGER</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">ModelUtils</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * get类型方法的前缀
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">GET_METHOD_PREFIX</span> <span class="o">=</span> <span class="s">&#34;get&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * get类型方法的前缀
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">SET_METHOD_PREFIX</span> <span class="o">=</span> <span class="s">&#34;set&#34;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 调用clazz 对象的所有get, set方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param clazz
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeGetAndSetMethod</span><span class="o">(</span><span class="n">Object</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">invokeMethodWithPrefix</span><span class="o">(</span><span class="n">GET_METHOD_PREFIX</span><span class="o">,</span> <span class="n">clazz</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">invokeMethodWithPrefix</span><span class="o">(</span><span class="n">SET_METHOD_PREFIX</span><span class="o">,</span> <span class="n">clazz</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 通过方法前缀调用方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param prefix
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param instance
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">invokeMethodWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">Object</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">if</span> <span class="o">(</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">())</span>
</span></span><span class="line"><span class="cl">		<span class="o">&amp;&amp;</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="n">prefix</span><span class="o">))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Object</span><span class="o">[]</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">method</span><span class="o">.</span><span class="na">getParameterCount</span><span class="o">()];</span>
</span></span><span class="line"><span class="cl">		<span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法异常, method: {}.{}&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				    <span class="n">instance</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		    <span class="n">LoggerUtil</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="n">LOGGER</span><span class="o">,</span> <span class="s">&#34;调用方法异常, method: {}.{}&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				    <span class="n">instance</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="总结"><span class="section-num">1.4</span> 总结</h3>
<ol>
<li>Reflections 包是真的强，有空要去看一下源码</li>
<li>懒惰是程序员的第一生产力, 这话真不是我编的，是Perl 语言之父 Larry
Wall 说的</li>
<li>加了其他两个类似功能的反射测试类，我的变更行覆盖率暴增30%
(可以看出我这次的变更主要是新增模型和工具类，这样反射才能调用规律性代码)</li>
<li>Java大法好，Java世界那么大，还需要我好好探索.</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Maven 小记</title>
      <link>https://ramsayleung.github.io/zh/post/2018/maven%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Tue, 23 Oct 2018 12:15:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2018/maven%E5%B0%8F%E8%AE%B0/</guid>
      <description>Maven 在工作中的经验以及《Maven 实战》读后感 1 前言 蚂蚁金服的伯岩大大曾经说 Java 生态都太重量级，连Maven 都是怪兽级的构建工具，需要整整一本书</description>
      <content:encoded><![CDATA[<p>Maven 在工作中的经验以及《Maven 实战》读后感</p>
<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>蚂蚁金服的伯岩大大曾经说 <a href="http://blog.fnil.net/index.php/archives/70/">Java 生态都太重量级，连Maven 都是怪兽级的构建工具，需要整整一本书来讲解</a>. 平心而论，Maven 的确如此, 但是无论是怪兽级，还是迪迦级的工具，只要能把事情做好了就是好工具, 而 Maven 恰恰就是这样的工具</p>
<h2 id="配置文件"><span class="section-num">2</span> 配置文件</h2>
<h3 id="pom-dot-xml"><span class="section-num">2.1</span> pom.xml</h3>
<p>就好像 Unix 平台的 Make 对应的 <code>MakeFile</code>，Cmake对应的 <code>CmakeFile.txt</code>, Maven 项目的核心是 <code>pom.xml</code>, POM(Project Object Model,项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等等，可以 pom.xml 是 Maven 一切实践的基础</p>
<h2 id="依赖管理"><span class="section-num">3</span> 依赖管理</h2>
<h3 id="坐标"><span class="section-num">3.1</span> 坐标</h3>
<p>Maven 仓库中有成千上万个构件（jar，war 等文件），Maven 如何精确地找到用户所需的构件呢，用的就是坐标。说起坐标，可能第一反映是平面几何中的 x，y坐标，通过 x，y坐标来唯一确认平面中的一个点，而Maven 的坐标就是用来唯一标识一个构件。</p>
<p>Maven 通过坐标为构件引入了秩序，任何一个构件都需要明确定义自己的坐标，而坐标是由以下元素组成：<code>groupId</code>, <code>artifactId</code>, <code>version</code>, <code>packaging</code>, <code>classifier</code>, <code>scope</code>, <code>exclusions</code>等。一个典型的Maven 坐标：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;groupId&gt;</span>springframework<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;artifactId&gt;</span>spring-beans<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;version&gt;</span>1.2.6<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>坐标元素详解:</p>
<ul>
<li>groupId(必填): 定义当前Maven 项目隶属的实际项目, 一般是域名的方向定义</li>
<li>artifactId(必填): 定义实际项目中的一个Maven 项目，推荐的做法是使用实际项目名称作为 <code>artifactId</code> 的前缀, 比如上例的 <code>artifactId</code> 是 spring-beans，使用了实际项目名 spring 作为前缀</li>
<li>version(必填): 定义了Maven 项目当前所处的版本，如上例版本是 1.2.6</li>
<li>packaging(选填): 定义了Maven 项目的打包方式。打包方式和所生成的构建的文件扩展名对应，如果上例增加了<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code>元素，最终的文件名为spring-beans-1.2.6.jar(Maven 打包方式默认是 jar)，如果是 web 构件，打包方式就是 <code>war</code>，生成的构件将会以<code>.war</code> 结尾</li>
<li>classifier: 用来帮助定义构建输出的一些附属构件. 附属构建和主构件对应，如上例的主构件是<code>spring-beans-1.2.6.jar</code>, 这个项目还会通过使用一些插件生成`=spring-beans-1.2.6-doc.jar=, <code>spring-beans-1.2.6-source.jar</code>, 其中包含文档和源码</li>
<li>exclusions: 用来排除依赖</li>
<li>scope: 定义了依赖范围，例如 <code>junit</code> 常见的scope 就是<code>&lt;scope&gt;test&lt;/scope&gt;</code>, 表示这个依赖只对测试生效</li>
</ul>
<h3 id="依赖范围"><span class="section-num">3.2</span> 依赖范围</h3>
<p>上文提到，JUnit 依赖的测试范围是test，测试范围用元素scope 表示。首先需要知道，Maven 在编译项目主代码的时候需要使用一套classpath，上例在编译项目主代码的时候就会用到<code>spring-beans</code>，该文件以依赖的方式呗引入到classpath 中。</p>
<p>其次，Maven 在执行测试时候会使用另外一套 classpath。如上文提到的 JUnit 就是以依赖的方式引入到测试使用的 classpath，需注意的是这里的依赖范围是<code>test</code>. 最后，项目在运行的时候，又会使用另外一套的 classpath，上例的<code>spring-beans</code>就是在该classpath里，而JUnit 则不需要。</p>
<p>简而言之，依赖范围就是用来控制依赖与这是那种 classpath (编译classpath, 测试 classpath, 运行 classpath 的关系，Maven 有以下几种依赖范围:</p>
<ul>
<li>compile: 编译依赖范围，如果没有显式指定<code>scope</code>, 那么<code>compile</code>就是默认依赖范围，使用此依赖范围的Maven 依赖，对于编译，测试，运行三种 classpath 都是有效的</li>
<li>test: 测试依赖范围，指定了该范围的依赖，只对测试 classpath 有效，在编译或者运行项目的时候，无法使用该依赖；典型例子就是 JUnit</li>
<li>provided: 已提供依赖范围。使用此依赖范围的 Maven 依赖，对于编译和测试classpath 有效，但在运行时无效</li>
<li>runtime：运行时依赖范围。使用此依赖范围的 Maven 依赖，对于测试和运行的classpath 有效，但在编译主代码时无效</li>
<li>import: 导入依赖范围，该依赖范围不会对三种 classpath 产生实际的影响</li>
<li>system: 系统依赖方位。与 provided 依赖范围完全一致, 即只对编译和测试的classpath有效，对运行时的 classpath 无效. 但是，使用system 范围的依赖必须通过systemPath 元素显式地指定依赖文件的路径 如：</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;groupId&gt;</span>javax.sql<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;artifactId&gt;</span>jdbc-stdext<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;version&gt;</span>2.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;scope&gt;</span>system<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;systemPath&gt;</span>${java.home}/lib/rt.jar<span class="nt">&lt;/systemPath&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>由于此类依赖不是通过Maven 仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用</strong>
上述除import 以外的各种依赖范围与三种classpath 的关系如下:</p>
<table>
<thead>
<tr>
<th>依赖范围 scope</th>
<th>对于编译classpath有效</th>
<th>对于测试classpath 有效</th>
<th>对于运行时classpath有效</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>&ndash;</td>
<td>Y</td>
<td>&ndash;</td>
<td>JUnit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>&ndash;</td>
<td>servlet-apt</td>
</tr>
<tr>
<td>runtime</td>
<td>&ndash;</td>
<td>Y</td>
<td>Y</td>
<td>JDBC 驱动实现</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>&ndash;</td>
<td>本地的，java类库以外的文件</td>
</tr>
</tbody>
</table>
<h2 id="仓库"><span class="section-num">4</span> 仓库</h2>
<p>上文提及了依赖管理，通过声明的方式指定所需的构件，那么是从哪里获取所需的构件的呢？答案是 Maven 仓库，Maven 仓库可以分为两类: 本地仓库和远程仓库。</p>
<p>当 Maven 需要根据坐标寻找构件的时候，它首先会查找本地仓库，如果本地仓库存在该构件，则直接使用，如果本地不存在该构件，或者需要查看是否有更新的构件版本，Maven 聚会去远程仓库查找，发现需要的构件之后，下载到本地仓库在使用.</p>
<p>如果本地和远程仓库都没有所需要的构件，那么 Maven 就会报错。如果需要细化远程仓库的类型，还可以分成中央仓库，私服和其他公共库。</p>
<ul>
<li>中央仓库：Maven 核心自带的的远程仓库，它包含了绝大部分开源的构件。在默认的配置下，当本地仓库没有 Maven 需要的构件的时候，它就会尝试从中央仓库下载。</li>
<li>私服：为了节省带宽和时间，可以在内网假设一个特殊的仓库服务器，用来代理所有的外部的远程仓库</li>
</ul>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191104112131.png"
         alt="Figure 1: repo"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>repo</p>
        </figcaption>
</figure>

<h3 id="snapshot"><span class="section-num">4.1</span> SNAPSHOT</h3>
<p>在Maven 的世界中，任何一个项目或者构件都必须有自己的版本，版本可能是 <code>1.0.0</code>, <code>1.0-alpha-4,2.1-SNAPSHOT</code> 或者 <code>2.1-20181028-11</code>, 其中 <code>1.0.0</code>, <code>1.0-alpha-4</code> 是稳定的发布版本，而 <code>2.1-SNAPSHOT</code> 或者 <code>2.1-20181028-11</code> 是稳定的快照版本。</p>
<p>Maven 为什么要区分快照版本和发布版本呢？难道1.0.0 不能解决么？为什么需要2.0-SNAPSHOT。</p>
<p>我对此 <code>SNAPSHOT</code> 这个特性印象非常深刻，在蚂蚁金服的新人培训中，其中就有一项是大家协作完成一个 Mini Alipay，一个 Mini Alipay 分成三个应用<code>bkonebusiness</code>, <code>bkoneuser</code>, <code>bkoneacccount</code>，以SOA 的架构进行拆分，应用之间相互依赖。</p>
<p>在开发过程中，<code>bkoneuser</code> 经常需要将最新的构件共享 <code>bkonebusiness</code>, 以供他们进行测试和开发。</p>
<p>因为<code>bkoneuser</code>本身也在快速迭代中，为了让<code>bkonebusiness</code> 用到最新的代码，我们不断地变更版本，<code>1.0.1</code>, <code>1.0.2</code>, <code>1.0.3</code>,&hellip; <code>bkoneuser</code> 不断发版本，<code>bkonebusiness</code> 不断升版本，甚至有一次<code>bkoneuser</code> 在没有更新版本号的情况下发布了最新代码，而 <code>bkonebusiness</code> 已经有原来版本的 jar 包，所以就没有去远程仓库拉取最新的代码，就出问题了&hellip;.</p>
<p>其实 Maven 快照版本就是为了解决这种问题，防止滥用版本号和及时拉取最新代码。</p>
<p>bkoneuser 只需将版本指定为<code>1.0.1-SNAPSHOT</code>, 然后发布到远程服务器，在发布的工程中，Maven 会自动为构件打上时间戳，比如 <code>1.0.1-20181028.120112-13</code> 表示 2018年10月28号的12点01分12秒的13次快照，有了时间戳，Maven 就能随时找到仓库中该构件<code>1.0.1-SNAPSHOT</code>版本的最新文件。</p>
<p>这是，<code>bkonebusiness</code>对于 <code>bkoneuser</code>的依赖，只要构建<code>bkonebusiness</code>，Maven就会自动从仓库中检查 <code>bkoneuser</code>的罪行构建，发现有更新便进行下载。</p>
<p>基于快照版本，<code>bkonebusiness</code> 可以完全不用考虑 <code>bkoneuser</code> 的构建，因为它总是拉取最新版本的 <code>bkoneuser</code>,这个是 Maven 的快照机制进行保证。</p>
<p>如果到了 release，就要及时将 <code>1.0.1-SNAPSHOT</code>, 否则 <code>bkonebusiness</code> 在构建发布版本的时候可能拉取到最新的有问题的版本.</p>
<h3 id="仓库搜索服务"><span class="section-num">4.2</span> 仓库搜索服务</h3>
<p>在公司开发的时候有私服，但是在开发自己项目的时候，我一般到 <a href="https://repository.sonatype.org/">SnoaType Nexus</a> 找对应的构件</p>
<h2 id="插件与生命周期"><span class="section-num">5</span> 插件与生命周期</h2>
<h3 id="何为生命周期"><span class="section-num">5.1</span> 何为生命周期</h3>
<p>在有关 Maven 的日常使用中，命令行的输入往往就对应了生命周期，如 <code>mvn package</code> 就表示执行默认的生命周期阶段 <code>package</code>.</p>
<p>Maven 的生命周期是抽象的，其实际行为都由插件来完成，如<code>package</code> 阶段的任务就会有<code>maven-jar-plugin</code> 完成。</p>
<p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一，包括项目的清理，初始化，编译，测试，打包，集成测试，验证，部署等几乎所有的构建步骤。</p>
<p>需要注意的是 <strong>Maven 的生命周期是抽象的，这意味着生命周期本身不作任何实际的工作，实际的任务(如编译源代码)都交由插件来完成. 每个步骤都可以绑定一个或者多个插件行为，而且Maven 为大多数构建步骤编写并绑定了默认的插件</strong></p>
<p>例如：针对编码的插件有 <code>maven-compiler-plugin</code>,针对测试的插件有<code>maven-surefire-plugin</code> 等，用户几乎不会察觉插件的存在</p>
<h3 id="三套生命周期"><span class="section-num">5.2</span> 三套生命周期</h3>
<p>Maven 有用三套相互独立的生命周期，它们分别是<code>clean</code>, <code>default</code> , <code>site</code>. <code>clean</code> 生命周期的目的是清理项目，<code>default</code> 生命周期的目的是构件项目，而 <code>site</code> 生命周期的目的是建立项目站点</p>
<h4 id="clean-生命周期"><span class="section-num">5.2.1</span> clean 生命周期</h4>
<p>clean 生命周期主要是清理项目，它包含三个阶段:</p>
<ol>
<li>pre-clean: 执行一些清理前需要完成的工作</li>
<li>clean 清理上一次构造生成的文件</li>
<li>post-clean 执行一些清理后需要完成的工作</li>
</ol>
<h4 id="default-生命周期"><span class="section-num">5.2.2</span> default 生命周期</h4>
<p>default 生命周期奠定了真正构件时所需要执行的所有步骤，它是所有生命周期最核心的部分，其包含的阶段如下：</p>
<ul>
<li>validate</li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources 处理项目主资源文件。一般来说，是对src/main/resources 目录内的内容进行变量替换的工作后，复制到项目输出的主classpath 目录中</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile 编译项目的主源码，一般来说，是编译 src/main/java 目录下的java 文件至项目输出的主 classpath 目录中</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources 处理项目测试资源文件。一般来说，是对src/test/resources 目录的内容进行变量替换等工作后，复制到项目输出的测试classpath 目录中</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile 编码项目的测试代码。一般来说，是编译 src/test/java 目录下的java 文件至项目输出的测试classpath 目录中</li>
<li>process-test-classes</li>
<li>test 使用单元测试框架运行测试，测试代码不会被打包或部署</li>
<li>prepare-packae</li>
<li>package 接受编译好的代码，打包或可发布的格式，如 jar</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>vertify</li>
<li>install 将包安装到Maven 本地仓库，供本地其他Maven 项目使用</li>
<li>deploy 将最终的包复制到远程仓库，共其他开发人员和Maven 项目使用</li>
</ul>
<h4 id="site-生命周期"><span class="section-num">5.2.3</span> site 生命周期</h4>
<p>site 生命周期的目的是建立和发布项目站点，生命周期包含如下阶段</p>
<ul>
<li>pre-site 执行一些在生成项目站点前需要完成的工作</li>
<li>site 生成项目站点文档</li>
<li>post-site 执行一些在生成项目站点之后需要完成的工作</li>
<li>site-deploy 将生成的项目站点发布到服务器上</li>
</ul>
<h4 id="命令行和生命周期"><span class="section-num">5.2.4</span> 命令行和生命周期</h4>
<p>从命令行执行Maven 任务的最主要方式就是调用 Maven的生命周期阶段。需要注意的是，各个生命周期是相互独立的，而一个生命周期的阶段是有前后依赖关系的。</p>
<p>下面以一些常见的Maven 命令为例，解释其执行的生命周期阶段:</p>
<ul>
<li>mvn clean: 该命令调用clean 生命周期的clean 阶段。实际执行的阶段为clean 生命周期的pre-clean 和clean 阶段</li>
<li>mvn test: 该命令调用default 生命周期的test 阶段。实际执行的阶段是 default 生命周期的 validate, initialize, 直到 test 的所有阶段。这也解释了为什么在测试的时候，项目的代码能够自动得以编译</li>
<li>mvn clean install: 该命令调用 clean 生命周期的clean 阶段和default 生命周期的 install 阶段。实际执行的阶段为 clean 生命周期的 pre-clean, clean 阶段，以及default 生命周期的从validate 到 install 的所有阶段。该命令结合了两个生命周期，在执行真正的项目构建之前清理项目是一个很好的实践</li>
</ul>
<h2 id="继承"><span class="section-num">6</span> 继承</h2>
<p>如bkoneuser 的项目结构所示:</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191104112215.png"
         alt="Figure 2: bkoneuser 的项目结构"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>bkoneuser 的项目结构</p>
        </figcaption>
</figure>

<p>按照 DDD(Domain Driven Design) 的驱动，<code>bkoneuser</code> 下有多个对应的子模块，每个模块也是一个 Maven 项目，每个模块里面可能有相同的依赖，如 <code>SpringFramework</code> 的 <code>spring-core</code>, <code>spring-beans</code>, <code>spring-context</code> 等。</p>
<p>如果每个子模块都维护一份大致相同的依赖，那么就有10几份相同的依赖，这还会随着子模块的增多而变得庞大。</p>
<p>如果我们工程师的嗅觉, 会发现有很多的重复依赖，面对重复应该怎么办？通过抽象来减少重复代码和配置，而 Maven 提供的抽象机制就是继承(还有聚合，只是个人觉得不如继承常用).</p>
<p>在 OOP 中，工程师可以建立一种类的父子结构，然后在父类中声明一些字段供子类继承，这样就可以做到“一处声明，多处使用”, 类似地，我们需要创建 POM 的父子结构，然后在父POM 中声明一些供子 POM 继承，以实现“一处声明，多处使用”</p>
<h3 id="配置示例"><span class="section-num">6.1</span> 配置示例</h3>
<p>parent 的配置如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;groupId&gt;</span>com.minialipay<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;artifactId&gt;</span>bkgponeuser-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;version&gt;</span>1.0.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;bkgponeaccount.common.service.facade.version&gt;</span>1.1.0.20180919<span class="nt">&lt;/bkgponeaccount.common.service.facade.version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/properties&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;modules&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/core/service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/core/model<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/biz/shared<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/biz/service-impl<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/util<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/service/facade<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/service/integration<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/dal<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/test<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/modules&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要主要的关键点是parent 的 <code>packaging</code> 值必须是 <code>pom</code>, 而不是默认的 <code>jar</code>, 否则则无法进行构件.</p>
<p>而 <code>modules</code> 元素则是实现继承最核心的配置，通过在打包方式为 pom 的Maven 项目中声明任意数量的 <code>module</code> 来实现模块的继承, 每个 <code>module</code>的值都是一个当前POM 的相对目录，比如 <code>app/core/service</code> 就是说子模块的POM在 parent 目录的下的 <code>app/core/service</code>目录</p>
<h3 id="子模块配置示例"><span class="section-num">6.2</span> 子模块配置示例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;groupId&gt;</span>com.minialipay<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;artifactId&gt;</span>bkgponeuser-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;version&gt;</span>1.0.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;relativePath&gt;</span>../../../pom.xml<span class="nt">&lt;/relativePath&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;artifactId&gt;</span>bkgponeuser-core-service<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;packaging&gt;</span>jar<span class="nt">&lt;/packaging&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述pom 中使用 <code>parent</code> 元素来声明父模块，<code>parent</code> 下元素groupid， artifactId 和 version 指定了父模块的坐标，这三个元素是必须。</p>
<p>元素 <code>relativePath</code> 表示父模块POM的相对路径, <code>../../../pom.xml</code> 指父POM的位置在三级父目录上</p>
<h3 id="可继承的pom-元素"><span class="section-num">6.3</span> 可继承的POM 元素</h3>
<p>可继承元素列表及简短说明:</p>
<ul>
<li>groupId: 项目Id, 坐标的核心元素</li>
<li>version：项目版本, 坐标的核心元素</li>
<li>description: 项目的描述信息</li>
<li>organization: 项目的组织信息</li>
<li>inceptionYear: 项目的创始年份</li>
<li>url: 项目的url 地址</li>
<li>developers: 项目的开发者信息</li>
<li>contributors: 项目的贡献者信息</li>
<li>distributionManagement：项目的部署配置</li>
<li>issueManagement: 项目的缺陷跟踪系统信息</li>
<li>ciManagement: 项目的持续继承系统信息</li>
<li>scm: 项目的版本控制系统信息</li>
<li>mailingLists: 项目的邮件列表信息</li>
<li>properties: 自定义的Maven 属性</li>
<li>dependencies: 项目的依赖配置</li>
<li>dependencieyManagemant: 项目的依赖管理配置</li>
<li>repositories: 项目的仓库配置</li>
<li>build: 包括项目的源码目录配置，输出目录配置，插件配置，插件管理配置等</li>
<li>reporting: 包括项目的报告输出目录配置，报告插件配置等</li>
</ul>
<h3 id="dependencymanagement-依赖管理"><span class="section-num">6.4</span> dependencyManagement 依赖管理</h3>
<p>可继承列表包含了 <code>dependencies</code> 元素，说明是会被继承的，这是我们就会很容易想到将这一特性应用到 <code>bkoneuser-parent</code> 中。子模块同时依赖 <code>spring-beans</code>,=spring-context=,=fastjson= 等, 因此可以将这些依赖配置放到父模块 <code>bkoneuser-parent</code> 中，子模块就能移除这些依赖，简化配置.</p>
<p>这种做法可行，但是存在问题，我们可以确定现有的子模块都是需要 <code>spring-beans</code>, <code>spring-context</code> 这几个模块的，但是我们无法确定将来添加的子模块就一定需要这四个依赖.</p>
<p>假设将来项目中要加入一个<code>app/biz/product</code>, 但是这个模块不需要 <code>spring-beans</code>, <code>spring-context</code>, 只需要 <code>fastjson</code>, 那么继承 <code>bkoneuser</code> 就会引入不需要的依赖，这样是非常不利于项目维护的！</p>
<p>Maven 提供的 <code>dependencyManagement</code> 元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。在 <code>dependencyManagement</code> 元素下的依赖声明不会引入实际的依赖，不过它能够约束 <code>dependencies</code> 下的依赖使用。</p>
<p>例如在 <code>bkoneuser-parent</code> 用 <code>dependencyManagement</code>声明依赖:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependencyManagement&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;groupId&gt;</span>com.alibaba<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;artifactId&gt;</span>fastjson<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;version&gt;</span>1.1.33<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;version&gt;</span>4.7<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependencyManagement&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>app/core/service</code> 子模块进行引用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>fastjson<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependencies&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>子模块的<code>fastjson</code> 依赖只配置了 <code>groupId</code> 和 <code>artifactId</code>, 省去了 <code>version</code> , 而 <code>junit</code> 依赖 不仅省去了<code>version</code>, 连<code>scope</code> 都省去了。</p>
<p>《Maven 实战》作者强烈推荐使用这种方式，其主要原因在与在父POM 中使用 <code>dependencyManagement</code> 声明依赖能够统一规范依赖的版本，当依赖版本在父POM中声明之后，子模块在使用依赖的时候就无须声明版本，也就不会发生多个子模块使用依赖版本不一致的情况</p>
<h2 id="依赖冲突"><span class="section-num">7</span> 依赖冲突</h2>
<p>在Java 项目中，随着项目代码量的增长，各种问题就会接踵而至，jar 包冲突就是其中一个最常见的问题. jar 冲突常见的异常: <code>NoSuchMethodError</code>, <code>NoClassDefFoundError</code></p>
<h3 id="成因"><span class="section-num">7.1</span> 成因</h3>
<p>当Maven根据pom文件作依赖分析, 发现通过直接依赖或者间接依赖, 有多个相同<code>groupId</code>, <code>artifactId</code>, 不同 <code>version</code> 的依赖时, 它会根据两点原则来筛选出唯一的一个依赖, 并最终把相应的jar包放到 classpath下:</p>
<ol>
<li>依赖路径长度: 比如应用的pom里直接依赖了A, 而A又依赖了B, 那么B对于应用来说, 就是间接依赖, 它的依赖路径长度就是2. 长度越短, 优先级越高. 当出现不同版本的依赖时, maven优先选择依赖路径短的依赖.</li>
<li>依赖声明顺序: 当依赖路径长度相同时, POM 里谁的声明在上面, Maven 就选择谁.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span> <span class="o">=</span><span class="k">new</span> <span class="n">B</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_a</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">b</span><span class="o">.</span><span class="na">func_b</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 来自b-1.0.jar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span><span class="o">=</span><span class="k">new</span> <span class="n">C</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_b</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">c</span><span class="o">.</span><span class="na">func_c</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 来自c-1.0.jar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_xxx</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_c</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 来自c-1.1.jar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_xxx</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_c1</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// d.1.0.jar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">D</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 来自c-1.1.jar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">func_d</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">	    <span class="n">c</span><span class="o">.</span><span class="na">func_xxx</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyMain</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">new</span> <span class="n">A</span><span class="o">().</span><span class="na">func_a</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">	    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>应用程序里有个A类, 里面含有一个属性B, 这个B类来自 <code>b-1.0.jar</code> 包. A类有个 <code>func_a()</code> 方法, 里面会调用b类的 <code>func_b</code> 方法.B类含有一个属性C, 这个C类来自<code>c-1.0.jar</code>. B类还提供一个方法 <code>func_b()</code>, 里面调用C类的 <code>func_c()</code> 方法.</p>
<p>这时, 应用程序的主POM里间接依赖了 <code>c-1.1.jar</code> 包, 但是这个jar里的C类中已经把 <code>func_c()</code> 删除了.</p>
<p>这样由于B类使用的 <code>c-1.0.jar</code> 对于应用程序来说, 是间接依赖, 依赖路径长度是2 (A -&gt; B -&gt; C), 比应用程序主pom中间接依赖的 <code>c-1.1.jar</code> 路径(D-&gt;C)长, 最后就会被maven排掉了 (也就是应用程序的 classpath 下, 最终会保留 <code>c-1.1.jar</code>).</p>
<p>最后执行main函数时, 就会报 <code>NoSuchMethodError</code>, 也就是找不到C类中 <code>func_c()</code> 方法.</p>
<h3 id="解决方案"><span class="section-num">7.2</span> 解决方案</h3>
<p>强制Maven 使用<code>c-1.0.jar</code>, 也就是将<code>c-1.1.jar</code>排除掉:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.d<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>d<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;exclusions&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;exclusion&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;groupId&gt;</span>com.c<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;artifactId&gt;</span>c<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/exclusion&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/exclusions&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependencies&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>d.1.0.jar</code> 的依赖排除 <code>c.1.1.jar</code> 的时候，不需要指定版本, 因为这个时候<code>d.1.0.jar</code> 的依赖的版本一定是 <code>c.1.1.jar</code>. 需要注意的是，如果 <code>d</code> 使用了<code>c.1.1.jar</code> 的 <code>func_c1()</code>，排掉 <code>c.1.1.jar</code> 是会报错的，因为满足了B类的 <code>func_c()</code> 就无法满足 D 类的 <code>func_c1()</code>, 这个就是著名的“菱形依赖问题”(diamond dependency problem)。</p>
<p>不得不说，入职的时候，遇上了各种jar 包冲突的问题，排包都排出心得. 在此推荐个排包神器, Intellij Idea 的插件：<a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">maven helper</a>, 比手动<code>-verbose:class</code> + <code>mvn dependency:tree</code>排包方便多了</p>
<h2 id="总结"><span class="section-num">8</span> 总结</h2>
<p>的确，写到这里，必须再次承认 Maven 是怪兽级的 构建工具，但是同样无可否认的是，它出色的构建和依赖管理功能。写go 语言的时候，我多希望有个 Maven 可以用呢 ╥﹏╥&hellip;</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Rust的错误处理(二)</title>
      <link>https://ramsayleung.github.io/zh/post/2018/error_handle_in_rust_2/</link>
      <pubDate>Thu, 08 Feb 2018 22:01:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2018/error_handle_in_rust_2/</guid>
      <description>自定义错误和error_chain 库 1 前言 上一篇文章聊到 Rust 的错误处理机制，以及和 Java 的简单比较，现在就来聊一下如何在 Rust 自定义错误，以及引入 er</description>
      <content:encoded><![CDATA[<p>自定义错误和<code>error_chain</code> 库</p>
<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>上一篇文章聊到 Rust 的错误处理机制，以及和 Java 的简单比较，现在就来聊一下如何在 Rust 自定义错误，以及引入 <code>error_chain</code>这个库来优雅地进行错误处理。</p>
<p>还有，少不了用 Java 来做对比咯:)</p>
<h3 id="java-自定义异常"><span class="section-num">1.1</span> Java 自定义异常</h3>
<p>前文简单提到 Java 的错误和异常但是继承自一个 <code>Throwable</code>的父类，既然异常是继承自异常父类的，我们自定义异常的时候，
也可以模仿JDK, 继承一个异常类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">MyException</span><span class="o">(</span><span class="n">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样就定义了属于自己的异常. 只需要继承 <code>Exception</code>,然后调用父类的构造方法。</p>
<p>不过 对于那些复杂的项目，这样的例子未免过于简单。现在就来看一个我项目的中的一个异常类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">public</span><span class="w"> </span><span class="kr">final</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="n">extends</span><span class="w"> </span><span class="n">RuntimeException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/**
</span></span></span><span class="line"><span class="cl"><span class="sd">     *
</span></span></span><span class="line"><span class="cl"><span class="sd">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kr">final</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">serialVersionUID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">L</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">boolean</span><span class="w"> </span><span class="n">isFillStack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">httpStatusCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">code</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="n">message</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="n">MyError</span><span class="p">(</span><span class="n">int</span><span class="w"> </span><span class="n">httpStatusCode</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">super</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">null</span><span class="p">,</span><span class="w"> </span><span class="n">isFillStack</span><span class="p">,</span><span class="w"> </span><span class="n">isFillStack</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">this</span><span class="p">.</span><span class="n">httpStatusCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">httpStatusCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">this</span><span class="p">.</span><span class="n">code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">code</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">this</span><span class="p">.</span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">message</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="n">MyError</span><span class="p">(</span><span class="n">MyErrorCode</span><span class="w"> </span><span class="n">myErrorCode</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">messageArgs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">this</span><span class="p">(</span><span class="n">myErrorCode</span><span class="p">.</span><span class="n">getHttpStatusCode</span><span class="p">(),</span><span class="w"> </span><span class="n">myErrorCode</span><span class="p">.</span><span class="n">getErrorCode</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	     </span><span class="n">MessageFormat</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">myErrorCode</span><span class="p">.</span><span class="n">getMessagePattern</span><span class="p">(),</span><span class="w"> </span><span class="n">messageArgs</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="n">throwError</span><span class="p">(</span><span class="n">MyErrorCode</span><span class="w"> </span><span class="n">myErrorCode</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">messageArgs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyError</span><span class="p">(</span><span class="n">myErrorCode</span><span class="p">,</span><span class="w"> </span><span class="n">messageArgs</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="n">internalServerError</span><span class="p">(</span><span class="nb">String</span><span class="w"> </span><span class="n">logId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyError</span><span class="p">(</span><span class="n">MyErrorCode</span><span class="p">.</span><span class="n">INTERNAL_SERVER_ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">logId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="n">DataError</span><span class="p">(</span><span class="nb">String</span><span class="w"> </span><span class="n">logId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyError</span><span class="p">(</span><span class="n">MyErrorCode</span><span class="p">.</span><span class="n">DATA_ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">logId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="n">BadParameterError</span><span class="p">(</span><span class="nb">String</span><span class="w"> </span><span class="n">logId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyError</span><span class="p">(</span><span class="n">MyErrorCode</span><span class="p">.</span><span class="n">BAD_PARAMETER_ERROR</span><span class="p">,</span><span class="w"> </span><span class="n">logId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这是我去掉了多余方法和变量的简化版，但是也足以一叶知秋了。</p>
<p><code>MyError</code>这个异常类是 继承于 <code>RuntimeException</code>的，并调用了 <code>RuntimeException</code>的构造方法。</p>
<p>因为我的项目是 WEB 服务的业务层，要处理大量的逻辑，难免会出现异常.</p>
<p>比如说可能调用方调用接口 的时候，入参不符合规范，我就抛出一个经过包装的 <code>BadParameterError</code> 异常，对于接 口调用方，这样会比一个单纯的 400 错误要友好，其他的异常也是同理。</p>
<h3 id="rust-自定义错误"><span class="section-num">1.2</span> Rust 自定义错误</h3>
<p>对于习惯了 OOP 编程的同学来说，Java 的异常是很容易理解，但是回到 Rust 身上，Rust是没有父类一说的，显然，Rust 是没可能套用 Java 的自定义异常的方式的。</p>
<p>Rust 用的是 <code>trait</code>, <code>trait</code>就有点类似 Java 的 =interface=(只是类似，不是等同!).</p>
<p>按照 Rust 的规范，Rust 允许开发者定义自己的错误，设计良好的错误应该包含以下的特性：</p>
<ol>
<li>使用相同的类型(type)来表示不同的错误</li>
<li>错误中包含对用户友好的提示(我也在上面提到的)</li>
<li>能便捷地与其他类型比较，例如：
<ul>
<li>Good: <code>Err(EmptyVec)</code></li>
<li>Bad: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>包含与错误相关的信息，例如：
<ul>
<li>Good: <code>Err(BadChar(c, position))</code></li>
<li>Bad: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>可以很方便地与其他错误结合</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">DoubleError</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug, Clone)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 自定义错误类型。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">DoubleError</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 不同的错误需要展示的信息也不一样，这个就要视情况而定，因为 DoubleError 没有定义额外的字段来保存错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1">// 所以就现在就简单打印错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DoubleError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="fm">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;invalid first item to double&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 实现 error::Error 这个 trait, 对DoubleError 进行包装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DoubleError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="s">&#34;invalid first item to double&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="c1">// Generic error, underlying cause isn&#39;t tracked.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="nb">None</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">double_first</span><span class="p">(</span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">first</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Change the error to our new type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">DoubleError</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		  </span><span class="c1">// Update to the new error type here also.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">		  </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">DoubleError</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		  </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="n">result</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w">  </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The first doubled is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;42&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;93&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;18&#34;</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;tofu&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;93&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;18&#34;</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">double_first</span><span class="p">(</span><span class="n">numbers</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">double_first</span><span class="p">(</span><span class="n">empty</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">double_first</span><span class="p">(</span><span class="n">strings</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码的运行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">The first doubled is 84
</span></span><span class="line"><span class="cl">Error: invalid first item to double
</span></span><span class="line"><span class="cl">Error: invalid first item to double
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="error-chain"><span class="section-num">1.3</span> error_chain</h3>
<p>虽说 Rust 自定义错误很灵活和方便，但是如果每次定义异常都需要实现 <code>Display</code> 和 <code>Error</code>, 未免过于繁琐，现在来介绍
<a href="https://github.com/rust-lang-nursery/error-chain">error_chain</a> 这个类库。</p>
<p><code>error_chain</code> 是由 Rust 项目组的 leader&ndash;<a href="https://brson.github.io/">Brian Anderson</a> 编写的异常处理库，可以让你更舒心<del>简单不粗 暴</del>地定义错误。</p>
<hr>
<h4 id="error-chain示例"><span class="section-num">1.3.1</span> error_chain示例</h4>
<p>以上面的 <code>DoubleError</code>为例，并改写 error_chain 的官方<a href="https://github.com/rust-lang-nursery/error-chain/blob/master/examples/quickstart.rs">例子</a> 以实现相同的效果，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// `error_chain!` 的递归深度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#![recursion_limit = </span><span class="s">&#34;1024&#34;</span><span class="cp">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//引出 error_chain 和相应的宏
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#[macro_use]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">error_chain</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//将跟错误有关的内容放入 errors module, 其他需要用到这个错误module 的模块就通过
</span></span></span><span class="line"><span class="cl"><span class="c1">// use errors::* 来引入所有内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">mod</span> <span class="nn">errors</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Create the Error, ErrorKind, ResultExt, and Result types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">error_chain</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">errors</span><span class="p">{</span><span class="n">Double</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="n">description</span><span class="p">(</span><span class="s">&#34;invalid first item to double&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">display</span><span class="p">(</span><span class="s">&#34;invalid first item to double&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">errors</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>::<span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorKind</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;42&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;93&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;18&#34;</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="s">&#34;tofu&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;93&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;18&#34;</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">double_first</span><span class="p">(</span><span class="n">numbers</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">double_first</span><span class="p">(</span><span class="n">empty</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">double_first</span><span class="p">(</span><span class="n">strings</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">double_first</span><span class="p">(</span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">first</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Change the error to our new type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ErrorKind</span>::<span class="n">Double</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		  </span><span class="c1">// Update to the new error type here also.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">		  </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">ErrorKind</span>::<span class="n">Double</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		  </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="n">result</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The first doubled is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>运行这代码可以得到和上面小节同样的输出。</p>
<h4 id="error-chain-详解"><span class="section-num">1.3.2</span> error_chain 详解</h4>
<p>刚刚就先目睹了一下 <code>error_chain</code> 的芳容了，现在是时候来解剖一下 <code>error_chain</code>, 这次就以 <code>error_chain</code>的 <a href="https://github.com/rust-lang-nursery/error-chain/blob/master/examples/quickstart.rs">example</a>来解释</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// Simple and robust error handling with error-chain!
</span></span></span><span class="line"><span class="cl"><span class="c1">// Use this as a template for new projects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// `error_chain!` can recurse deeply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#![recursion_limit = </span><span class="s">&#34;1024&#34;</span><span class="cp">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Import the macro. Don&#39;t forget to add `error-chain` in your
</span></span></span><span class="line"><span class="cl"><span class="c1">// `Cargo.toml`!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#[macro_use]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">error_chain</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// We&#39;ll put our errors in an `errors` module, and other modules in
</span></span></span><span class="line"><span class="cl"><span class="c1">// this crate will `use errors::*;` to get access to everything
</span></span></span><span class="line"><span class="cl"><span class="c1">// `error_chain!` creates.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">mod</span> <span class="nn">errors</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Create the Error, ErrorKind, ResultExt, and Result types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">error_chain</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">errors</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;caused by: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="c1">// The backtrace is not always generated. Try to run this example
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="c1">// with `RUST_BACKTRACE=1`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">backtrace</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">backtrace</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;backtrace: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">backtrace</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span>::<span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Most functions will return the `Result` type, imported from the
</span></span></span><span class="line"><span class="cl"><span class="c1">// `errors` module. It is a typedef of the standard `Result` type
</span></span></span><span class="line"><span class="cl"><span class="c1">// for which the error type is always our own `Error`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">run</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// This operation will fail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;contacts&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">.</span><span class="n">chain_err</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="s">&#34;unable to open contacts file&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>重要的信息例子已经作了注释，现在就来看看用法。首先来看看 main 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;caused by: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="c1">// The backtrace is not always generated. Try to run this example
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="c1">// with `RUST_BACKTRACE=1`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">backtrace</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">backtrace</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;backtrace: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">backtrace</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span>::<span class="n">std</span>::<span class="n">process</span>::<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出，这个函数的大部份逻辑是进行错误处理，例如返回自定义的 <code>Result</code>和 <code>Error</code>, 然后处理这些错误。上面的处理流程显示了 <code>error_chain</code> 从某个错误继承而来的三样信息：最近出现的错误(即<code>e</code>)，导致错误的调用链，原来错误的堆栈信息 (<code>e.backtrace()</code>)</p>
<h2 id="小结"><span class="section-num">2</span> 小结</h2>
<p>刚刚的例子只是 <code>error_chain</code> 小试了一波牛刀，如果想要了解更多关于 Rust 异常处理 的细节，就需要看看 Rust 的文档咯</p>
<h2 id="参考"><span class="section-num">3</span> 参考</h2>
<ul>
<li><a href="https://rustbyexample.com/error.html">rust by example</a></li>
<li><a href="https://brson.github.io/2016/11/30/starting-with-error-chain">starting with error chain</a></li>
<li><a href="http://siciarz.net/24-days-rust-error_chain/">24-days-rust-error_chain/</a></li>
<li><a href="https://vincent.is/handling-errors-in-rust/">handling errors in rust</a></li>
<li><a href="https://docs.rs/error-chain">error chain</a></li>
<li><a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">error handle</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Rust的错误处理(一)</title>
      <link>https://ramsayleung.github.io/zh/post/2018/error_handle_in_rust_1/</link>
      <pubDate>Mon, 05 Feb 2018 20:35:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2018/error_handle_in_rust_1/</guid>
      <description>拉上Java 来谈谈 Rust的错误处理 1 前言 每个语言都会有异常处理机制（没有异常处理机制的语言估计也没有人会用了），Rust 自然也不例外，所以</description>
      <content:encoded><![CDATA[<p>拉上Java 来谈谈 Rust的错误处理</p>
<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>每个语言都会有异常处理机制（没有异常处理机制的语言估计也没有人会用了），Rust 自然也不例外，所以今天我就来谈Rust 的异常处理，因为 Rust 的异常处理跟常见的语言 （Java/Python 等）的处理机制差异略大，所以打算拉个上个语言，对比着解释. 没错，这 个光荣的任务就落到了 Java 身上</p>
<h2 id="java-的异常处理"><span class="section-num">2</span> Java 的异常处理</h2>
<p>在谈 Rust 的异常处理之前，为了把它们之前的差异讲清楚，先来聊一下 Java 的异常处理。</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/java_exception_hierarchy.png"
         alt="Figure 1: Java exception hierarchy"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>Java exception hierarchy</p>
        </figcaption>
</figure>

<p>如上面的简易图所示， Java 的异常都是继承于 <code>Throwable</code> 这个分类的，而异常又是分 成不同的类型： <code>Error</code>, <code>Exception</code>;
<code>Exception</code> 又分成 <code>Checked Exception</code> 和 <code>RuntimeException</code>.</p>
<p><code>Error</code> 一般都是了出现严重的问题，按照JDK 注释的说法，都是不应该 <code>try-catch</code>的：</p>
<blockquote>
<p>An {() Error} is a subclass of {() Throwable}
that indicates serious problems that a reasonable application should
not try to catch. Most such errors are abnormal conditions.</p>
</blockquote>
<p>比如虚拟机挂了，或者JRE 出了问题就可能是 <code>Error</code>，前几天我就遇到一个JRE 的 Bug, 整个项目都挂 了：</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191104104407.png"
         alt="Figure 2: JRE fatal error"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>JRE fatal error</p>
        </figcaption>
</figure>

<p>我还顺便给 Oracle 报了个<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8196769">Bug</a> :)</p>
<p>至于<code>RuntimeException</code> 就是类似数组越界，空指针这些异常，即无法在程序编译时发现，只有在运行的时候才会出 现的问题，所以叫做运行时异常(<code>RuntimeException</code>).</p>
<h2 id="checked-exception"><span class="section-num">3</span> Checked Exception</h2>
<p>Java的<code>Checked Exception</code>, 也就是Java 要求你必须在函数的类型里面声明或处理它可能抛出的异常。比如，你的函数如果是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">string</span> <span class="n">filename</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">filename</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="n">file</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">st</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">((</span><span class="n">st</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">st</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Java 要求你必须在函数头部写上 <code>throws IOException</code> 或者是必须用 <code>try-catch</code>处理这个异常，因为<code>readline()</code> 的方法签名是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="nf">readLine</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">ignoreLF</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以编译器要求必须要处理这个异常，否则它就不能编译。</p>
<p>同理，在使用 <code>foo()</code>这个函数 的时候，可能会抛出 <code>IOException</code> 这个异常，由于编译器看到了这个声明，它会严格检 查你对 <code>foo</code>
函数的用法。</p>
<p>在我看来，<code>CheckedException</code>是Java 优良的设计之一，正因 为<code>Checked Exception</code>的存在，会更容易编写出正确处理错误的程序，更健壮的程序</p>
<h2 id="rust-的异常处理"><span class="section-num">4</span> Rust 的异常处理</h2>
<p>Rust 是一个注重安全（Safety）的语言，而错误处理也是 Rust关注的要点之一。</p>
<p>Rust 主要是将错误划分成两种类型，分别是可恢复的错误(recoverable error) 和不可恢复错误 (unrecoverable error).</p>
<p>出现可恢复的错误的原因多种多样，例如打开文件的时候，文件找不到或者没有读权限等，开发者就应该对这种可能出现的错误进行处理；</p>
<p>而不可恢复的错误就可能是Bug 引起的，比如数组越界等。而其他常见的语言一般是没有没有区分 <code>recoverable error</code>和 <code>unrecoverable error</code>的. 比如 Python, 用的就是 <code>Exception</code>.</p>
<p>而Rust 是没有 <code>Exception</code>, Rust 用 <code>Result&lt;T, E&gt;</code> 表示可恢复错误， 用 <code>panic!()</code> 来表示出现错误，并且中断程序的执行并退出(不可恢复错误)。</p>
<p><code>Result</code> 是Rust 标准库的枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>T</code>和<code>E</code>都是泛型，<code>T</code>表示程序执行正常的时候的返回值，那<code>E</code>自然是程序出错时的返回 值。以标准库的打开文件的函数为例， <code>std::io::File</code> 的 <code>open()</code> 函数的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">open</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">OpenOptions</span>::<span class="n">new</span><span class="p">().</span><span class="n">read</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">as_ref</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>忽略这个方法的参数，只看返回值类型：<code>io::Result&lt;File&gt;</code>, 又因为有 <code>type Result&lt;T&gt;</code> Result&lt;T, Error&gt;;=</p>
<p>这个 <code>typedef</code> 语句，所以返回值的完整版本时<code>io::Result&lt;File,io::Error&gt;</code>, 即调用 <code>open</code> 这个函数的时候，可能出现错误，出现错误时候返回一个 <code>io::Error</code>, 如果调用<code>open</code>没有问题的话，就会返回一个 <code>File</code> 的结构体，所以这个就类似 Java 的<code>CheckedException</code>,</p>
<p>只要声明了函数可能出现问题，在调用函数的时候就必须处理可能出现的错误，不然编译器就不会让你通过(Rust 的编译器就像位父亲那样对开发者耳提面命), 例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">cache_path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="n">file</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">why</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;couldn&#39;t open {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">why</span><span class="p">.</span><span class="n">description</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="java-的异常传递"><span class="section-num">5</span> Java 的异常传递</h2>
<p>在程序中，总会有一些错误需要处理，但是却不应该在错误出现的函数进行处理的情况(或者是，你很懒惰，只想应付一下编译器，不想处理出现的异常 :)</p>
<p>比如你正在编写一个类 库，里面有很多的IO 操作，有IO 操作的地方就有可能出现<code>IOException</code>. 如果出现异常，
你不应该自己在类库把异常给 <code>try-catch</code>了，如果这样，使用你类库的开发者就没办法知 道程序出现了异常，异常的堆栈也丢了。</p>
<p>比较合理的做法是，把<code>IOException</code>捕捉了，然后对 <code>IOException</code> 做一层包装，然后再抛给类库的调用者，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">WrappingException</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">doSomethingThatCanThrowException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SomeException</span> <span class="n">e</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">e</span><span class="o">.</span><span class="na">addContextInformation</span><span class="o">(</span><span class="s">&#34;there is something happen in doSomething() function, `Some Exception` is raised, balabala&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//throw e;  //throw e, or wrap it  see next line.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">throw</span> <span class="k">new</span> <span class="n">WrappingException</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">more</span> <span class="n">information</span> <span class="n">about</span> <span class="n">Some</span> <span class="n">Exception</span><span class="o">,</span> <span class="n">balabala</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//clean up close open resources etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，你也可以在添加了额外的信息之后，直接把原来的异常抛出来</p>
<h2 id="rust-的异常传递"><span class="section-num">6</span> Rust 的异常传递</h2>
<p>刚刚谈了 Java 的异常传递，现在轮到 Rust 的异常传递了，既然Rust 没有 <code>Exception</code>一说，那 Rust 传递的自然也是 <code>Result&lt;T,E&gt;</code>
这个枚举类型(这里针对的是 可恢复错误，不可恢复错误出现错误的时候，会返回错误并弹出程序，自然不存在异常传递).</p>
<p>先来看看 Rust 的异常传递的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">use std::io;
</span></span><span class="line"><span class="cl">use std::io::Read;
</span></span><span class="line"><span class="cl">use std::fs::File;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
</span></span><span class="line"><span class="cl">    let f = File::open(&#34;hello.txt&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    let mut f = match f {
</span></span><span class="line"><span class="cl">	Ok(file) =&gt; file,
</span></span><span class="line"><span class="cl">	Err(e) =&gt; return Err(e),
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    let mut s = String::new();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    match f.read_to_string(&amp;mut s) {
</span></span><span class="line"><span class="cl">	Ok(_) =&gt; Ok(s),
</span></span><span class="line"><span class="cl">	Err(e) =&gt; Err(e),
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>例子来自 Rust Book</p>
<p>先来看看函数的返回值 <code>Result&lt;String,io::Error&gt;</code>, 也就是说， <code>read_username_from_file</code> 正确执行的时候返回是 <code>String</code>,
错误的时候，返回的是 <code>io::Error</code>. 这里的异常传递是在出现 <code>io::Error</code>的时候，将错误原样返回，不然就是返
回函数执行成功的结果。</p>
<p>就异常传递的方式而言，Rust 和 Java 是大同小异：声明可能抛出的异常和成功时返回的结果，然后在遇到错误的时候，直接（或者包装一下）返回错误。</p>
<h3 id="关键字"><span class="section-num">6.1</span> ? 关键字</h3>
<p>虽说 Rust 的异常处理很清晰，但是每次都要 <code>match</code> 然后返回未免太繁琐了，所以 Rust 提供了一个语法糖来显示繁琐的异常传递：用
&ldquo;?&rdquo; 关键字进行异常传递：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>同样的功能，但是模板代码却减少了很多 :)</p>
<h3 id="unwrap-和-expect"><span class="section-num">6.2</span> unwrap 和 expect</h3>
<p>虽说 Rust 的可恢复错误设计得很优雅，但是每次遇到可能出现错误得地方都要显示地进行 处理，不免让人觉得繁琐.</p>
<p>Rust 也考虑到这种情况了，提供了 <code>unwrap()</code> 和 <code>expect()</code>让你舒心<del>简单粗暴</del>地处理错误：在函数调用成功的时候返回正确的结果，在 出现错误地时候直接 <code>panic!()</code>,并退出程序</p>
<h4 id="unwrap"><span class="section-num">6.2.1</span> unwrap</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>打开 <code>hello.txt</code>这个文件，能打开就返回文件 <code>f</code>,不能打开就 <code>panic!()</code> 然后退出程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="n">thread</span><span class="w"> </span><span class="s1">&#39;main&#39;</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="s1">&#39;called `Result::unwrap()` on an `Err` value: Error {
</span></span></span><span class="line"><span class="cl"><span class="s1">repr: Os { code: 2, message: &#34;No such file or directory&#34; } }&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">/</span><span class="n">stable</span><span class="o">-</span><span class="n">dist</span><span class="o">-</span><span class="n">rustc</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">libcore</span><span class="o">/</span><span class="n">result</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">868</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="expect"><span class="section-num">6.2.2</span> expect</h4>
<p><code>expect()</code>和 <code>unwrap()</code>类似，只不过 <code>expect()</code>可以加上额外的信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Failed to open hello.txt&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>出现错误的时候，除了显示应有的错误信息之外，还会显示你自定义的错误信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">thread &#39;main&#39; panicked at &#39;Failed to open hello.txt: Error { repr: Os { code:
</span></span><span class="line"><span class="cl">2, message: &#34;No such file or directory&#34; } }&#39;,
</span></span><span class="line"><span class="cl">/stable-dist-rustc/build/src/libcore/result.rs:868
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码来自 <a href="https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html">Rust book</a></p>
<h2 id="结语"><span class="section-num">7</span> 结语</h2>
<p>以上只是浅谈了 Rust 的错误处理，以及和 Java 的异常处理机制的简单比较，接下来我会 谈谈如何自定义<code>Error</code>以及使用
<code>erro_chain</code> 这个库来优雅地进行错误处理 :)</p>
<p>如果想了解更多关于 Rust 异常处理的内容，可以查阅 Rust book <a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">Error handle</a></p>
<h2 id="参考"><span class="section-num">8</span> 参考</h2>
<ul>
<li><a href="http://tutorials.jenkov.com/exception-handling-strategies/propagating-exceptions.html">propagating exceptions</a></li>
<li><a href="https://doc.rust-lang.org/book/second-edition/">Rust book</a></li>
<li><a href="https://doc.rust-lang.org/stable/std/io/type.Result.html">IO Result</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
