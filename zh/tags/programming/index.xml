<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming on 菠萝油与天光墟</title>
    <link>https://ramsayleung.github.io/zh/tags/programming/</link>
    <description>Recent content in Programming on 菠萝油与天光墟</description>
    <image>
      <title>菠萝油与天光墟</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.146.7</generator>
    <language>zh</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 ·</copyright>
    <lastBuildDate>Sun, 15 Jun 2025 17:54:34 -0700</lastBuildDate>
    <atom:link href="https://ramsayleung.github.io/zh/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从在加拿大退货失败的一件小事思考系统设计</title>
      <link>https://ramsayleung.github.io/zh/post/2025/%E4%BB%8E%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E9%80%80%E8%B4%A7%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%80%E4%BB%B6%E5%B0%8F%E4%BA%8B%E6%80%9D%E8%80%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 31 May 2025 11:00:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2025/%E4%BB%8E%E5%9C%A8%E5%8A%A0%E6%8B%BF%E5%A4%A7%E9%80%80%E8%B4%A7%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%80%E4%BB%B6%E5%B0%8F%E4%BA%8B%E6%80%9D%E8%80%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;&lt;span class=&#34;section-num&#34;&gt;1&lt;/span&gt; 前言&lt;/h2&gt;
&lt;p&gt;前天刚写完《&lt;a href=&#34;https://ramsayleung.github.io/zh/post/2025/a_philosophy_of_software_design/&#34;&gt;软件设计的哲学&lt;/a&gt;》，满脑子还萦绕着模块耦合和接口抽象，
结果昨天就撞上一个现实中的“设计陷阱”——一次耗时数小时却无解的「退货」噩梦。&lt;/p&gt;
&lt;p&gt;今天趁着周末，决定把这场荒诞遭遇拆解出来，既当吐槽，也当案例分析.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>前天刚写完《<a href="https://ramsayleung.github.io/zh/post/2025/a_philosophy_of_software_design/">软件设计的哲学</a>》，满脑子还萦绕着模块耦合和接口抽象，
结果昨天就撞上一个现实中的“设计陷阱”——一次耗时数小时却无解的「退货」噩梦。</p>
<p>今天趁着周末，决定把这场荒诞遭遇拆解出来，既当吐槽，也当案例分析.</p>
<h2 id="来龙去脉"><span class="section-num">2</span> 来龙去脉</h2>
<p>前段时间搬了家，自然就需要重新办理宽带，一直用的是 <a href="https://www.telus.com/">Telus</a> 家的家庭宽带服务，他们家的宽带服务也支持从一个住址迁移到另外一个住址, 就预约了 Telus 技术人员上门安装。</p>
<p>技术人员上门安装完宽带之后，就需要测试一下 WI-FI 能否正常使用，就问我们的路由器在哪，他接上处理一下。</p>
<p>问题就来了：</p>
<p>我们的路由器之前是舍友设置的，还不是常见的一体路由器，而是分体式路由器，有三个不同的组件。</p>
<p>而舍友在搬完家后就回国休假了，我还真不知道怎么搞这路由器，各个接口尝试了小半个小时也没反应，师傅也没见识过，自然也不晓得弄。</p>
<p>这个又是一个非常经典的软件开发问题：</p>
<p>「在我的机器上能跑，换个环境就挂了」</p>
<p>但是一直没网也不是办法，然后师傅建议我可以把他随身带的 Telus 路由器买下来，等我舍友回来后把网络设置好，再把路由器还回来，Telus支持30天无理由退货。</p>
<p>听起来也只能这么搞了。</p>
<p>舍友休了几周假回来之后，几分钟不到，很快就把这个路由器就设置起来了:</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-1ade0" hidden>
    <label for="zoomCheck-1ade0">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/mesh_router.jpg"/> 
    
    
    </label>
</figure>

<p>剩下的就是把路由器还给 Telus, 已经过了几周，30天的免责退货时间所剩不多了。</p>
<h2 id="退货流程"><span class="section-num">3</span> 退货流程</h2>
<p>因为设备不是通过网购买的，没法直接在网上退单，也不是门店买的，无法直接拿去门店退，退货的流程是打电话给 Telus 的客服，问他们要退货指引。</p>
<p>我就给 Telus 的客服打电话，解释清楚情况后，客服说给我账户对应的邮箱发个邮件，里面有指引和退货码，我需要去 Canada Post（加拿大邮政）把路由器寄回去。</p>
<p>电话里客服说已经给我发邮件了，但是我说没有收到（此处为后面埋下伏笔），于是我提供另外一个邮箱，成功收到了。</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-77eeb" hidden>
    <label for="zoomCheck-77eeb">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/telus_return_equipment_instruction.jpg"/> 
    
    
    </label>
</figure>

<p>因为 Canada Post 最近在为涨薪闹罢工，客服提到我需要去另外一家快递公司 Purolator 寄快递。</p>
<p>剩下要做就是把路由器打包，然后寄出来(这么容易就好了), 再把快递单号告知 Telus, 退货流程就算结束了。</p>
<h2 id="坑来了"><span class="section-num">4</span> 坑来了</h2>
<h3 id="邮政罢工"><span class="section-num">4.1</span> 邮政罢工</h3>
<p>因为加拿大邮政罢工，所以只能去 Purolator 寄，但是去到 Purolator后，人家反馈:</p>
<blockquote>
<p>你这个退货码是给加拿大邮政的，我们不认哦，你要给个我们家的退货码。</p></blockquote>
<p>我只能去再打电话给 Telus 客服要退货码，花费了15分钟，终于打通了，解释完一番之后，他们说给我的邮箱发了新的 Puralator 退货码，我等了一分钟，说没有收到，然后让给我另外的一个邮箱也发一次指引，还是没有收到，然后客服说邮件会在24-48小时内到达..</p>
<p>但挂电话后再等了一个小时还是没有收到.</p>
<h3 id="邮箱收不到email"><span class="section-num">4.2</span> 邮箱收不到email</h3>
<p>只能再打电话给 Telus 的客服，又等了10几分钟终于接通了，这次换了个客服，这位客服说我们不支持 Purolator，你可以等加拿大邮政罢工结束之后再寄。</p>
<p>我也很无语，怎么你们的回复还不一致的，就和客服说，我怎么知道罢工什么时候结束呢，30天马上就要到了嘛。</p>
<p>客服说，的确很有道理，这样吧，你可以去尝试使用用加拿大邮政寄下，然后我把情况记录一下，到时超过30天也可以免责退款。</p>
<p>然后我追问到，那罢工结束时退货也是用相同的退货码么？这个退货码有过期时间么？邮件没写哦。</p>
<p>客服说，那以防万一，我再给你邮箱发个新的退货码吧。</p>
<p>我着实是怕了，不知道为什么一直没有收到邮件，就让客服把我账号对应的邮箱地址读出来, 客服就把我邮箱的逐个地址读出来。</p>
<p>前面部分听着没问题嘛，我还在寻思是什么问题，只是听着听着，怎么我邮箱还有我不认识的部分，就打开 Telus 的APP 修改, 然后被气得差点要吐血了:</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-53734" hidden>
    <label for="zoomCheck-53734">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/telus_email_address.jpg"/> 
    
    
    </label>
</figure>

<p>我的邮箱地址是 <code>ramsayleung@gmail.com</code>, 然后为了标记不同的公司，我用了<a href="https://ramsayleung.github.io/zh/post/2023/gmail%E5%9C%B0%E5%9D%80%E7%9A%84%E9%9A%90%E8%97%8F%E6%8A%80%E5%B7%A7/">《两个鲜为人知的Gmail地址技巧》</a> 提到的加号技巧来注册 Telus 账号:</p>
<p><code>ramsayleung+telus@gmail.com</code></p>
<p>之前用了一年多还是好好的，不然我也无法注册和验证邮箱成功。</p>
<p>但是现在 Telus 作了变更，直接把邮箱地址中的加号去掉了，变成了 <code>ramsayleungtelus@gmail.com</code>, 变成一个完全不同的邮箱, 肯定是不可能收到邮件的。</p>
<p>花费了近一下午，打了5-6次电话，和不同的客服沟通和练习口语，最后的结果就是隔天再去加拿大邮政试试，不行就等他们罢工结束再寄。</p>
<h2 id="糟糕设计的代价"><span class="section-num">5</span> 糟糕设计的代价</h2>
<p>这次经历虽然令人沮丧，但也印证了软件工程的一条铁律：</p>
<p><strong><strong>糟糕的设计最终会让所有人付出代价——无论是用户还是开发者。</strong></strong></p>
<p>讽刺的是，人们总希望通过「学习别人的错误」来避免踩坑，但现实中，我们往往被迫为别人的设计缺陷买单。</p>
<h3 id="单点故障与-happy-path-陷阱"><span class="section-num">5.1</span> 单点故障与「Happy Path」陷阱</h3>
<p>电话退货这个操作虽然看似落后，但是总体来说还是可以用的，在不出问题的前提下。</p>
<p>Telus 的退货流程设计暴露了一个典型的系统脆弱性：</p>
<p><strong><strong>强依赖单一服务提供商（Canada Post）</strong></strong> ，且未设计降级方案（如备用物流或线下门店退货）。</p>
<p>这种「Happy Path Only」的思维，本质上是对分布式系统设计原则的违背：</p>
<p><strong><strong>任何外部服务都可能失败，而系统必须对此容错。</strong></strong></p>
<p>让快递直接成为业务系统的「单点」故障，只考虑 Happy Path, 没有考虑异常场景，甚至发过来的退货邮件指引，都可以看出他们是把 <strong><strong>Canada Post</strong></strong> 写死在邮件。</p>
<h3 id="向后兼容性-一个被忽视的底线"><span class="section-num">5.2</span> 向后兼容性：一个被忽视的底线</h3>
<p>退货强依赖加拿大邮政这个还可以说成是产品设计的问题，但是直接把我邮箱地址给改掉这个，就一定是程序员的锅了。</p>
<p>此外，我的邮箱地址在 APP 中显示的是 <code>ramsayleung@gmail.com</code>, 只有在修改邮箱地址的时候，才会显示出 <code>ramsayleungtelus@gmail.com</code> 这也是我一直没有发现的原因。</p>
<p>但最令人匪夷所思的是邮箱地址的非兼容性变更：系统直接静默移除了存量用户邮箱中的加号:</p>
<p><code>ramsayleung+telus@gmail.com</code> -&gt; <code>ramsayleungtelus@gmail.com</code> ，导致邮件发送失败。</p>
<p>这种粗暴的修改方式违反了最基本的向后兼容性原则，而问题的暴露方式（APP显示与修改界面不一致）进一步说明：</p>
<p>其系统内部还存在的数据状态不一致性问题</p>
<p>合理的变更方式应该是：</p>
<ol>
<li>增量控制：
<ul>
<li>禁止新用户注册或修改时使用特殊符号，但保留存量数据, 保证增量用户地址正确</li>
<li>存量用户修改邮箱地址时，禁止使用带特殊符号的邮箱地址</li>
</ul>
</li>
<li>存量迁移：
<ul>
<li>通过离线数仓，查询出所有带特殊符号的邮箱地址，通过异步任务批量通知受影响用户（避免阻塞主流程）</li>
<li>提供自动清理特殊符号的“一键修复”功能（需用户确认）。</li>
</ul>
</li>
<li>监控兜底：
<ul>
<li>建立异常邮箱地址的监控或者报表，直到存量问题归零。</li>
</ul>
</li>
</ol>
<p>虽然这做法非常繁琐，但是却可以保证系统升级绝对不影响用户。</p>
<p>系统设计与维护就是如此：开始做的时候成本很低，越到后期成本越高。</p>
<h2 id="个人感悟"><span class="section-num">6</span> 个人感悟</h2>
<p>除去别人的设计错误之外，我还有些额外的个人感悟:</p>
<p>虽然 Gmail 支持邮箱地址中增加一个 <code>+</code> 这样的功能，但是并不是所有的公司都支持这特性的，重要的邮件还是不能使用这个「奇技淫巧」。</p>
<p>此外，我另外提供的邮箱也无法收到邮件，可能是我的邮箱太长了，导致客服没有拼对我的邮箱，所以最好还是准备一个短的，包含数字的备用邮箱地址，方便电话沟通时提供给对方。</p>
<p>整个故事再次印证了《<a href="https://ramsayleung.github.io/zh/post/2025/a_philosophy_of_software_design/">软件设计的哲学</a>》中的道理：</p>
<p><strong><strong>所有偷懒的设计，终将以更高的成本偿还</strong></strong></p>
<p>当然, 谁来还就是后话了</p>
<div class="qr-container" center>
<img src="/ox-hugo/qrcode_gh_e06d750e626f_1.jpg" alt="qrcode_gh_e06d750e626f_1.jpg" class="qr-container" width="160px" height="160px" center="t" />
公号同步更新，欢迎关注👻
</div>
]]></content:encoded>
    </item>
    <item>
      <title>软件设计的哲学</title>
      <link>https://ramsayleung.github.io/zh/post/2025/a_philosophy_of_software_design/</link>
      <pubDate>Fri, 30 May 2025 00:39:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2025/a_philosophy_of_software_design/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;&lt;span class=&#34;section-num&#34;&gt;1&lt;/span&gt; 前言&lt;/h2&gt;
&lt;p&gt;知道这本书是因为在 Hacker News 上有人提问：&lt;a href=&#34;https://news.ycombinator.com/item?id=31713756&#34;&gt;你读过最好的技术书是什么&lt;/a&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;?&lt;/p&gt;
&lt;p&gt;最高赞的书是 Design Data Intensive Application(DDIA, 即《&lt;a href=&#34;https://book.douban.com/subject/30329536/&#34;&gt;数据密集型应用系统设计&lt;/a&gt;》&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;), 我觉得 DDIA 也担得起这个赞誉，然后最高赞的回答顺势提到了 &lt;a href=&#34;https://book.douban.com/subject/30218046/&#34;&gt;A Philosophy Of Software Design&lt;/a&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, 想来能与 DDIA 齐名的书，肯定不会差得哪里去。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>知道这本书是因为在 Hacker News 上有人提问：<a href="https://news.ycombinator.com/item?id=31713756">你读过最好的技术书是什么</a> <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>?</p>
<p>最高赞的书是 Design Data Intensive Application(DDIA, 即《<a href="https://book.douban.com/subject/30329536/">数据密集型应用系统设计</a>》<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>), 我觉得 DDIA 也担得起这个赞誉，然后最高赞的回答顺势提到了 <a href="https://book.douban.com/subject/30218046/">A Philosophy Of Software Design</a> <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, 想来能与 DDIA 齐名的书，肯定不会差得哪里去。</p>
<p>作者是 John Ousterhout, 斯坦福大学的教授，TCL 编程语言的创造者(Redis 的初始化版本就是用 TCL 写的)，共识算法 Raft 的作者之一.</p>
<p>这本书并不厚，全书只有200多页，读起来也并不费劲。</p>
<p>而这本书的主旨，开篇就点出来了:</p>
<blockquote>
<p>This book is about how to design software systems to minimize their complexity.</p>
<p>本书讲述如何设计软件系统以最小化其复杂度</p></blockquote>
<p>而软件工程的本质就是如何管理复杂度，全书围绕如何降低软件复杂性提出的思考和解决方案，
主要围绕抽象，异常，文档，一致性，设计原则这五个方向。</p>
<p>许多原则我看着都深有共鸣，尤其在设计过相当多的系统之后，犯过许多错误之后，才会意识到这些原则的重要之处。</p>
<p>很多原则看上去说的和没说一样，但只有踩过坑，实践起来都知道是金科玉律, 除了道出「软件设计」的真谛之外, 这本书其他论点也可谓字字珠玑.</p>
<p>关于谨慎暴露过多的配置给用户，尽量让程序动态计算各种参数值，尽量提供默认参数。</p>
<blockquote>
<p>开发软件时，开发者主动承担一些额外痛苦，从而减少用户的痛苦。</p>
<p>When developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.</p></blockquote>
<p>关于接口设计的原则:</p>
<blockquote>
<p>模块拥有简单的接口比简单的实现更重要。</p>
<p>it&rsquo;s more important for a module to have simple interface than a simple implementation</p></blockquote>
<p>关于异常处理的洞见:</p>
<blockquote>
<p>解决问题的最好方式是避免出现问题。</p>
<p>The best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: <strong><strong>define errors out of existence</strong></strong></p>
<p>归根结底，减少 Bug 的最佳方法是让软件更简单(少即是多)</p>
<p><strong><strong>Overall, the best way to reduce bugs is to make software simpler.</strong></strong></p></blockquote>
<h2 id="抽象"><span class="section-num">2</span> 抽象</h2>
<p>所谓的抽象，用我自己的话来说的就是把复杂的东西简单地呈现出来。</p>
<h3 id="模块深度"><span class="section-num">2.1</span> 模块深度</h3>
<p>为了直观地感受一个模块设计是否足够抽象，作者提出一个模块深度的概念:</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-ff3dd" hidden>
    <label for="zoomCheck-ff3dd">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/deep_module.jpg"/> 
    
    
    </label>
</figure>

<p>矩形的表层长度即是接口的复杂程度，而矩形的面积代表模块实现的功能，好的模块应该是深的(deep), 这意味着它有简单的接口，但是内部有复杂且丰富的实现.</p>
<p>例如 Unix 的文件读写接口:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">permissions</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">referencePosition</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口非常简单，但是其内部的实现可能需要成千上万行的代码，
需要支持文件目录的读写，文件权限，读写缓冲区，磁盘读写等等功能，这就是「深的」模块。</p>
<p>与其相反的就是浅的模块(shallow), 接口很复杂，但是功能却很简单。</p>
<h3 id="信息的漏与藏"><span class="section-num">2.2</span> 信息的漏与藏</h3>
<p>实现抽象的关键手段就是辨别出信息的重要程度，对于不重要的信息，就要对用户隐藏起来，关键的信息，就要暴露给用户, 实现「去粗存精，开箱即用」。</p>
<p>一个典型的例子就是参数配置，把参数暴露给用户，除非用户非常熟悉这个系统，不然他也不知道怎么算，
不需要用户关注的参数就提供默认值，能程序动态计算就由程序自己来算.</p>
<p>我很反感的一种设计就是引入一个配置系统，系统的运行参数都要由工程师配置，美其名是提供灵活度。</p>
<p>但这不仅引入额外的系统依赖（须知复杂度的根源就来自依赖与不明确），还大大增加了的运维成本，
更何况这样的配置还无法自适应，换种机型又要重新配置，导致配置越来越复杂。</p>
<p>除非是业务的黑名单或者白名单，系统的运行参数能用默认的就用默认，能动态计算就动态计算。</p>
<p>想想TCP/IP 的重试延迟时长如果不是动态计算，那么配置什么值比较合适，网络畅通和网络延迟又该是什么值，
开始恢复时和开始堵塞时又应该是什么值的呢?</p>
<h2 id="异常"><span class="section-num">3</span> 异常</h2>
<p>异常处理是系统复杂度的关键来源之一，异常就是一种特殊的分支，系统为了处理特殊 case难免需要写很多额外的逻辑。</p>
<p>而作者提出的降低异常处理来系统复杂度影响的方法，就是优化设计，减少必须处理异常的地方。</p>
<p>解决一个问题最好的方法是避免其发生，听起来很空洞或者是很不可思议，作者举出来的例子就是 Java 的 <code>substring(int beginIndex, int endIndex)</code> 用于截取子字符串的接口, 如果 <code>endIndex</code> 超出字符长度，Java 就会抛出一个 <code>IndexOutOfBoundException</code>, 调用方就是需要考虑越界的问题。</p>
<p>但是如果 Java 的 <code>substring</code> 接口本身可以像 Python 那样支持越界，返回一个空字符串，那么调用方就完全不需要考虑越界导致的异常</p>
<p>另外一个例子是作者设计的TCL脚本中的 <code>unset</code> 指令，原意是用来删除一个变量，因为他最初的设想是变量如果不存在，用户不可能调用 <code>unset</code> 的，那么当 <code>unset</code> 操作的变量不存在，那么就会抛出异常。</p>
<p>但是很多用户就是用 <code>unset</code> 来清理可能被初始化或者未初始化的变量，现在的设计就意味用户还需要包一层 <code>try/catch</code> 才能使用 <code>unset</code>.</p>
<p>意识到这个设计错误之后，作者对 <code>unset</code> 的语义作了稍微的修正，用 <code>unset</code> 来确保指定的变量不再存在(如果变量本身不存在，那么它什么都不需要做)</p>
<p>更经典的例子就是 Windows 下面删除一个文件，相信使用过 Windows 的朋友尝试删除文件时都会遇到这样的弹窗：「文件已被打开，无法删除，请重试」</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-bbb1b" hidden>
    <label for="zoomCheck-bbb1b">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/windows_delete_opening_file.png"/> 
    
    
    </label>
</figure>

<p>用户只能费尽心思去找打开这个文件的进程，然后把它杀掉再尝试删除，甚至只能通过关机重启来尝试删除文件。</p>
<p>但是 Unix 的处理方式就更优雅，它允许用户删除已经被其他进程打开的文件，它会对该文件做标记，让用户看来它已经被删除了，但是在打开它的进程结束前文件对应的数据都会一直存在。</p>
<p>只有在进程结束后，文件数据才会被删除掉，这样用户在删除文件时就不需要担心文件是否被使用。</p>
<p>通过优化以上的设计，减少需要用户处理的异常，这也是一个「去粗留精」的过程, 减少用户需要感知的内容。</p>
<h2 id="注释"><span class="section-num">4</span> 注释</h2>
<p>本书用了好几个章节来介绍文档与注释的重要性，命名的重要性，如何写好注释和起好名字。</p>
<p>好的文档可以大幅改善一个系统的设计，因为文档的作用就是把「对用户重要的，但是无法直接从代码中得知的关键信息告知用户」, 相当于帮用户把一个系统的关键信息给找出来。</p>
<p>不是有这么一句话： <strong><strong>程序员都讨厌写文档，但是更痛恨其他程序员不写文档。</strong></strong></p>
<p><strong><strong>而注释就是离源码最近的文档.</strong></strong></p>
<p>程序员不写注释的借口大概有这么几个（可惜它们都是不成立的）, 常见的借口与它们不成立的原因可见:</p>
<h3 id="好的代码是自解释的"><span class="section-num">4.1</span> 好的代码是自解释的</h3>
<p>如果用户必须阅读方法源码才能使用它，那就没有抽象，你相当于把实现的所有复杂度都直接暴露给用户。</p>
<p>若想通过抽象隐藏复杂性，注释必不可少</p>
<h3 id="我没有时间写注释"><span class="section-num">4.2</span> 我没有时间写注释</h3>
<p>如果你一直把写代码的优先级置于写注释之上，那么你会一直没有时间写注释，
因为一个项目结束之后总会有新的项目到来，如果你一直把写注释的优先级放在代码之后，那么你永远都不会去写注释。</p>
<p>写注释实际并不需要那么多的时间</p>
<h3 id="注释都会过期的啦"><span class="section-num">4.3</span> 注释都会过期的啦</h3>
<p>注释虽然难免会过期，但是保持与代码一致也并不会花费太多时间。</p>
<p>只有大幅需要修改代码时才需要更新注释，更何况，只有每次都不更新注释，注释才会难免过期</p>
<h3 id="我见过的注释都很烂-我为啥还要写"><span class="section-num">4.4</span> 我见过的注释都很烂，我为啥还要写</h3>
<p>别人的注释写得不好，那不正说明你可以写出好的注释嘛。</p>
<p>不能用别人的低标准来要求自己嘛。</p>
<h3 id="注释的原则"><span class="section-num">4.5</span> 注释的原则</h3>
<p>说起接口注释和文档，我一直觉得我描述下接口功能和使用场景，已经比绝大多数的同行做得好了。</p>
<p>在和现在的 L7 大佬一起工作之后，着实被他的文档所震撼。</p>
<p>不知道是因为其对代码质量和文档都有非常高的要求，还是读博士时训练出来的写作能力，
其对接口的功能，使用场景以及异常的描述都非常详尽，甚至包括代码使用示例，质量与 JDK 源码的注释不相上下, 原来真的有程序员花这么多精力写代码注释的。</p>
<h4 id="注释应当描述代码中不明显的内容"><span class="section-num">4.5.1</span> 注释应当描述代码中不明显的内容</h4>
<p><strong><strong>注释应当描述代码中不明显的内容</strong></strong>,</p>
<p>简单来说，就是要描述代码为什么要这么做，而不是描述代码是怎么做的，这相当于是把代码换成注释再写一次。</p>
<h4 id="注释先行"><span class="section-num">4.5.2</span> 注释先行</h4>
<p>很多程序员都习惯在写完代码之后才写注释，作者反其道而行， 作者推荐在定义完函数或者模块接口之后，不要马上动手写实现，
而是在这个时候在接口上把接口注释写下来，这相当于是在脑海把模块的设计再过一次。</p>
<p>写完代码再写注释，设计思路已经记不大清了，脑中更多的是实现细节，既容易把实现写成注释，又容易陷入「写完代码就不写注释」的陷阱。</p>
<h2 id="一致性"><span class="section-num">5</span> 一致性</h2>
<p>前文提到，系统的复杂度来自于两个方面「依赖」与「不明确」，
而「一致性」就是让系统的行为更加清晰明确。</p>
<p><strong><strong>它意味着相似的事情以相似的方式处理，不同的事情以不同的方式处理。</strong></strong></p>
<p>即所谓的「规圆矩方」，通过规范约束降低随意性，以及「一法通，万法通」，统一模式提升可维护性，让行为可预期。</p>
<p>一个系统的一致性一般体现在以下方面：</p>
<ol>
<li>命名(驼峰还是下划线)</li>
<li>代码风格(缩进，空格还是tab)</li>
<li>设计模式(使用特定的设计模式解决特定的问题)</li>
</ol>
<p>当然，还有通过「一致性」降低系统复杂度，走得比较极端的:</p>
<p>之前还在微信支付的时候，除上述的要求外，还要求后端只能使用一种语言(C++, Golang/JavaScript就别想了), 存储组件只能使用微信内部研发的KV(使用MySql需要向总经理申请)等等的要求.</p>
<h2 id="设计原则"><span class="section-num">6</span> 设计原则</h2>
<h3 id="通用设计"><span class="section-num">6.1</span> 通用设计</h3>
<p>好的设计应该是通用的，优先采用通用设计而非特殊场景的定制化方案，这个是减少复杂度和改善软件系统的根本原则。</p>
<p>过度定制通常是成为软件复杂度增加的首要诱因。</p>
<p>通用设计可以降低系统的整体复杂度(更少处理特殊分支的逻辑), 更深的模块(接口简单，功能丰富), 隐藏非关键信息.</p>
<p>文中提到的例子就是文本编辑器的文字插入与删除操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 反例：过度定制（绑定特殊场景）, 实现删除键功能</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">TextEditor</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">handleBackspaceKey</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 耦合UI事件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cursorPosition</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">text</span><span class="p">.</span><span class="na">deleteCharAt</span><span class="p">(</span><span class="n">cursorPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cursorPosition</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 正例：通用设计（解耦核心逻辑）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">Text</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 纯文本操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">content</span><span class="p">.</span><span class="na">delete</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">UI</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">onBackspacePressed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">text</span><span class="p">.</span><span class="na">delete</span><span class="p">(</span><span class="n">cursor</span><span class="p">.</span><span class="na">position</span><span class="p">(),</span><span class="w"> </span><span class="n">cursor</span><span class="p">.</span><span class="na">position</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 调用通用API</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cursor</span><span class="p">.</span><span class="na">moveLeft</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>delete(int start, int end)</code> 既可以实现删除键功能，也可以实现选中并删除的功能。</p>
<h3 id="性能"><span class="section-num">6.2</span> 性能</h3>
<p>在设计系统的时候，一般不需要太多地考虑性能的问题，因为简单，通用的系统要做性能优化通常都是比较容易；
相反而言，深度定制的系统因为耦合了定义逻辑，要优化性能并没有那么容易。</p>
<h3 id="设计两次"><span class="section-num">6.3</span> 设计两次</h3>
<p>Design it twice</p>
<p>因为很难一次就把事情做到极致, 那就再来一次, 设计时把能想到的选项都列下来.</p>
<p>反直觉的是，第一直觉通常不是最优的, 所以不要只考虑一种设计方案，无论它看起来多么合理，多对比下其他方案总没有害处的。</p>
<p>只用第一直觉的方案，其实你是在低估自己的潜力，你错失了找到更好方案的机会。</p>
<p>这也是我在写设计方案时候的做法，把自己能想到的，和同事讨论出来的所有方案都写上，然后分析各种方案的优劣, 最好的方案可能并不在原有方案列表里面，而是其中几个方案的合体。</p>
<h3 id="大局观"><span class="section-num">6.4</span> 大局观</h3>
<p>做任何事都要有大局观, 编程也不例外，战略编程优于战术编程(Strategic Programming over Tactical Programming);</p>
<p>虽然我们一直说「又不是不能跑」，但是我们对代码的要求，不能是「能跑就行啦」.</p>
<p>再者就是要和扁鹊他大哥治病一样，把功夫都做在前期，防范于未然，修补错误成本往往也越往后越高，病入膏肓之后，扁鹊来了也要提桶跑路:</p>
<blockquote>
<p>治不了，等死吧，告辞</p></blockquote>
<h2 id="代码整洁之道vs软件设计哲学"><span class="section-num">7</span> 代码整洁之道vs软件设计哲学</h2>
<p>本书的作者对<a href="https://book.douban.com/subject/34986245/">《代码整洁之道》</a>(Clean Code)<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> 的作者(Robert C. Martin, 即 Uncle Bob)的诸多观点作了反驳</p>
<h3 id="函数拆分"><span class="section-num">7.1</span> 函数拆分</h3>
<p>比如关于什么时候应该拆分一个函数，Uncle Bob 的观点是，基于函数的代码行数，一个函数需要相当短，甚至10行都有太长了。</p>
<p>Uncle Bob 原话:</p>
<blockquote>
<p>In the book Clean Code1, Robert Martin argues that functions should be broken up on length alone. He says that functions should be extremely short, and that even 10 lines is too long.</p></blockquote>
<p>而本书作者 John 的观点是: <strong><strong>每个函数应只做一件事，并完整地做好</strong></strong></p>
<p>函数的接口应当简洁，这样调用者无需记住大量信息就能正确使用它。</p>
<p>函数应当具备深度：其接口应远比实现更简单。如果一个函数满足以上所有特性，那么它的长度通常并不重要。</p>
<p><strong><strong>除非能让整个系统更简单，否则不应拆分函数</strong></strong></p>
<h3 id="文档注释"><span class="section-num">7.2</span> 文档注释</h3>
<p>Uncle Bob 认为需要给函数「注释始终是一种失败(<strong><strong>Comments are always failures</strong></strong>)」</p>
<p>如果我们的编程语言足够富有表现力，或者如果我们有能力用好这些语言来传达意图，那么我们就不太需要注释——甚至可能完全不需要.</p>
<p><strong><strong>注释的正确用途，是弥补我们无法用代码清晰表达的缺陷……注释始终是一种失败</strong></strong></p>
<blockquote>
<p>If our programming languages were expressive enough, or if we had the talent to subtly wield those languages to express our intent, we would not need comments very much — perhaps not at all.</p>
<p>he proper use of comments is to compensate for our failure to express ourselves in code&hellip;. Comments are always failures.</p></blockquote>
<p>而 John 的观点是</p>
<p>但注释并非失败的表现。</p>
<p><strong><strong>它们提供的信息与代码截然不同，而这些信息目前无法通过代码本身来表达。</strong></strong></p>
<p><strong><strong>注释的作用之一，正是让人无需阅读代码即可理解其含义</strong></strong></p>
<p>甚至直接反驳其观点:</p>
<blockquote>
<p>I worry that Martin’s philosophy encourages a bad attitude in programmers, where they avoid comments so as not to seem like failures.</p></blockquote>
<h3 id="网上对线"><span class="section-num">7.3</span> 网上对线</h3>
<p>所以也难怪 Uncle Bob 和 John Ousterhout 几个月前直接在网上论坛来了一次 <del>对线</del> (<a href="https://news.ycombinator.com/item?id=43166362">辩论)</a> <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></p>
<p>然后有看热闹不嫌事大的播主，把两人邀请到直播上，让他们直接面对面再来了一次对线</p>
<p>对应的Youtube视频: <a href="https://www.youtube.com/watch?v=3Vlk6hCWBw0">https://www.youtube.com/watch?v=3Vlk6hCWBw0</a></p>
<p>两位的书我都看过，我个人的感觉是《代码整洁之道》更适合入门的工程师，它可以教你如何写出好的「代码片段」；
而《软件设计的哲学》更适合需要做系统设计的工程师，它指导你如何设计好的「软件」。</p>
<p>考虑到两位作者的背景和作品，我可以说两位的差别可以说是 <strong><strong>以编程为生的人与以写编程相关的东西为生的人</strong></strong></p>
<h2 id="总结"><span class="section-num">8</span> 总结</h2>
<p>全书读完，我觉得《软件设计的哲学》绝对是配得上最好的技术书籍之一的赞誉。</p>
<p>但是不同的人读起来可能会有不同的感觉，其中的许多原则真的是做过设计，踩过坑才会有所共鸣, 否则会觉得其泛泛其谈。</p>
<p>当然，我也不是完全同意书中的所有观点的。</p>
<p>比如书中提到的会导致代码意图不「明显」的其中一种做法是声明的类型与初始化的类型不一致的情况:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="w"> </span><span class="n">incomingMessageList</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">incomingMessageList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面声明的是 <code>List&lt;Message&gt;</code>, 实际使用的 <code>ArrayList&lt;Message&gt;</code>, 这可能会误导用户，因为意图不清晰，阅读代码的人可能不确定是否需要使用 <code>List</code> 或者 <code>ArrayList</code>, 最好是声明和初始化都换成相同的类型。</p>
<p>但是 <code>List</code> 是接口, <code>ArrayList</code> 是接口的具体实现，这个就是非常标准的面向对象编程中的多态，这并不什么问题。</p>
<p>但瑕不掩瑜，全书读完，把书盖上后，我有种齿颊留香, 余音绕梁的感觉，书里有很多「熟悉的味道」，总是让我想起经手过的项目中种种的好代码和「坏」代码.</p>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li>旅加经历
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E8%BF%99%E4%BA%9B%E5%B9%B4%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF_%E4%BB%8E%E5%B9%BF%E5%B7%9E%E5%88%B0%E6%B8%A9%E5%93%A5%E5%8D%8E/">这些年走过的路：从广州到温哥华</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/">加拿大之初体验</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/">登陆加拿大一年后的体会</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E5%A4%8F%E6%97%A5%E6%8D%95%E8%9F%B9%E8%AE%B0/">夏日捕蟹记</a></li>
</ul>
</li>
<li>历史思考
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/">为什么梦想买不起，故乡回不去</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E9%97%B2%E8%81%8A%E5%86%99%E4%BD%9C/">闲聊写作的好处</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E9%87%91%E6%A6%9C%E9%A2%98%E5%90%8D%E4%B9%8B%E5%90%8E/">金榜题名之后</a></li>
</ul>
</li>
<li>工具流分享
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E7%AE%80%E6%98%8E%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/">简明写作指南</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%88%91%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/">我的写作流</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%88%91%E7%9A%84%E7%94%BB%E5%9B%BE%E6%B5%81/">我的画图流：画图工具与技巧分享</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%88%91%E7%9A%84%E6%90%9C%E7%B4%A2%E6%B5%81/">我的搜索流：高效搜索经验分享</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2022/feynman_technique/">最好的学习方式：费曼学习法(Feynman Technique)</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2021/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/">系统思考：既见树木，又见森林</a></li>
</ul>
</li>
<li>职场思考
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E7%BC%96%E7%A8%8B%E5%8D%81%E5%B9%B4%E7%9A%84%E6%84%9F%E6%82%9F/">编程十年的感悟</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E4%BB%8E%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%A6%BB%E7%BA%BF_%E6%88%91%E5%B8%A6%E8%B5%B0%E4%BA%86%E4%BB%80%E4%B9%88/">那些年，我从微信支付学到的东西</a></li>
</ul>
</li>
<li>软件工程
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%B8%80_%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E8%AE%A4%E7%9F%A5/">测试技能进阶(一): 软件质量认知</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%BA%8C_parameterized_tests/">测试技能进阶(二): Parameterized Tests</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%B8%89_property_based_testing/">测试技能进阶(三): Property Based Testing</a></li>
</ul>
</li>
</ul>
<div class="qr-container" center>
<img src="/ox-hugo/qrcode_gh_e06d750e626f_1.jpg" alt="qrcode_gh_e06d750e626f_1.jpg" class="qr-container" width="160px" height="160px" center="t" />
公号同步更新，欢迎关注👻
</div>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://news.ycombinator.com/item?id=31713756">https://news.ycombinator.com/item?id=31713756</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://book.douban.com/subject/30329536/">https://book.douban.com/subject/30329536/</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://book.douban.com/subject/30218046/">https://book.douban.com/subject/30218046/</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://book.douban.com/subject/34986245/">https://book.douban.com/subject/34986245/</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://news.ycombinator.com/item?id=43166362">https://news.ycombinator.com/item?id=43166362</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>编程十年的感悟</title>
      <link>https://ramsayleung.github.io/zh/post/2024/%E7%BC%96%E7%A8%8B%E5%8D%81%E5%B9%B4%E7%9A%84%E6%84%9F%E6%82%9F/</link>
      <pubDate>Sun, 15 Dec 2024 21:09:00 -0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2024/%E7%BC%96%E7%A8%8B%E5%8D%81%E5%B9%B4%E7%9A%84%E6%84%9F%E6%82%9F/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;&lt;span class=&#34;section-num&#34;&gt;1&lt;/span&gt; 前言&lt;/h2&gt;
&lt;p&gt;马尔科姆·格拉德威尔的“一万小时定律”指出，持续投入一万小时的努力，足以使人在某个领域达到专家水平。
按照每周20小时的练习量计算，每天大约需要投入3小时，十年左右才能达成这一目标。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>马尔科姆·格拉德威尔的“一万小时定律”指出，持续投入一万小时的努力，足以使人在某个领域达到专家水平。
按照每周20小时的练习量计算，每天大约需要投入3小时，十年左右才能达成这一目标。</p>
<p>从我写下第一行C代码算起，至今已超过十年。
期间，我编写了超过三十万行代码，其中一部分在微信编写的代码，曾服务过超过一亿的用户。</p>
<p>尽管写了这么多代码，我仍不敢自诩为专家。
但多年的“打工”生涯，日复一日地敲代码，也让我积累了不少感悟。
“工多艺熟”，这些感悟既是对编程技术的思考，更是对职场人生的体味。
毕竟，除了最初在学校学习的几年，我的编程生涯几乎都伴随着“打工”的酸甜苦辣(多是苦辣)。</p>
<h2 id="持续学习"><span class="section-num">2</span> 持续学习</h2>
<p>虽然大学是从C语言入门编程的，但是我在大学时主修的语言是Java
，毕竟Java是门非常成熟的工业语言，有非常丰富的框架，在国内的企业非常受欢迎，工作岗位也多。</p>
<p>我当时从Java Servlets入门Web开发，再学习了非常流行的JavaEE 企业开发框架SSH, 即 <a href="https://struts.apache.org/">Structs2</a> <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>+ <a href="https://spring.io/projects/spring-framework">Spring</a> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>+ <a href="https://hibernate.org/">Hibernate</a> <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, Struct2 负责控制逻辑关系，Spring 负责解耦, Hibernate 负责操作数据库.</p>
<p>而到我开始找工作时，SSH的概念就变了, Struct2 被<a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">SpringMVC</a> <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>所取代, SSH 变成了 SpringMVC + Spring + Hibernate.</p>
<p>到我实习入职蚂蚁金服的时候，发现组里代码库操作数据库的ORM框架用的并不是Hibernate，而是 <a href="https://ibatis.apache.org/">Ibatis</a> <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>, 后面又切换成了新的 <a href="https://mybatis.org/mybatis-3/">MyBatis</a> <sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></p>
<p>而蚂蚁金服内部使用的也并不是Spring/SpringMVC, 而是自主研发出发的 <a href="https://github.com/sofastack/sofa-rpc">Sofa框架</a> <sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>, Spring 社区后来觉得Spring框架过于重量级，不利于快速开发，又开发了更轻量级的 <a href="https://spring.io/projects/spring-boot">SpringBoot </a><sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>, 而蚂蚁内部又推出了Sofa版本的 <a href="https://github.com/sofastack/sofa-boot">Sofaboot</a> <sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup></p>
<p>去了微信支付后，前期都是在写C++, 使用微信内部自研的svrkit 框架，到后期因为负责数据治理相关项目的缘故，开始使用 Spark + Python + Hive SQL</p>
<p>现在在AWS S3, 因为业务对性能和资源使用有非常高的要求，又开始使用Rust, 而历史业务又是使用Java, 兜兜转转之后，又回到Java的路子上。</p>
<p>细数下来, 这些年来，我写过Java,C++,Python,Rust,Javascript/Typescript 这些语言的生产代码.</p>
<p>除去工作之外, 我还因为学习SICP 学习了Scheme, 因为使用Emacs 而学习了Emacs Lisp, 想做独立开发赚钱学习了Swift, 想感受Ruby on Rails的魅力而学习的Ruby, 还有以前为了压测写的Golang, 还有各种语言对应的框架和库.</p>
<p>自我学习编程以来，学过的编程语言没有10种也有半打了.</p>
<p>我也从来不会把自己定义为某门语言的程序员，如Java程序员,C++程序员等等, 我只叫自己做Software Development Engineer. 语言从来只是工具，只要你持续学习，遇到新的场景，自然就会学习新的编程语言了.</p>
<p>计算机的世界日新月异，可能几个月就会出个新框架，几年又会流行一门新语言，只有持续学习，才能持续保持自己的竞争力。</p>
<h2 id="学好英语"><span class="section-num">3</span> 学好英语</h2>
<p>领袖常说，「东升西降」，虽然不知道此种变化何时才能实现，但起码说明，目前是「西尚在上，东尚在下」，在计算机领域，尤其如此。</p>
<p>最前沿的技术都是英文资料，英语又是世界通行的语言，来自不同国家的开发者又会不约而同地使用英语来交流，
因此学好英语既可以了解最新的技术潮流，又可以融入社区，建立自己的影响力。</p>
<p>疫情之后，越来越多的公司都开始推行远程办公，从全世界招聘开发者.
这就意味着如果你英文过硬，甚至可以离开一线城市，避免高额的生活开销，在老家工作，陪伴在父母身边，同时赚取外汇；这对于饱受996困扰的程序员来说，未尝不是一条出路.</p>
<p>于我个人而言，坚持学习英语可能是我收获最大的投资之一。</p>
<p>熟悉我的朋友，尤其是我的高中同学可能知道，十年以前，我的英文可以说着实挺烂的:
满分150分的英语，只考个及格的90分可谓是家常便饭，后来也只会笨学英语，到高三的时候能考个120分已经是巅峰水平。</p>
<p>但上大学之后，我也没有就此懈怠放下英语，大一还每天去晨读英语。</p>
<p>没有口语交流的条件，就自己创造，去网上找人聊天, 当时还在一个叫 <a href="https://www.interpals.net/">Interpals</a> <sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup> 聊天网站认识了全世界好多的人, 其中还有一个是年龄相仿的土耳其女孩，我们还加了Facebook, 经常用Skype 视频聊天.</p>
<p>大学毕业后就没有那么多的时间闲聊后就断了联系, 最近看Facebook的动态，看她也穿上婚纱了.</p>
<p>工作后也一直阅读英文的技术文章，用英文搜索内容，在Stackoverflow 和 GitHub 用英文回答问题，在Discord 的英语学习频道找人聊天, 把电脑和手机系统语言都换成英文的，从学习英语变成用英语。</p>
<p>后来在<a href="https://ramsayleung.github.io/zh/post/2023/%E8%BF%99%E4%BA%9B%E5%B9%B4%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF_%E4%BB%8E%E5%B9%BF%E5%B7%9E%E5%88%B0%E6%B8%A9%E5%93%A5%E5%8D%8E/">机缘巧合之下</a>，从国内找到了加拿大AWS的工作，幸而有机会来加.</p>
<p>人们常说，路应该要越走越宽，而不是越走越窄；</p>
<p>而在我看来，英语就是夜里走路时手上拿着的手电筒，可以让我们走自己的路的同时，
扫一下旁边那条道的情况，需要时及时转向，不至于一条路走到黑.</p>
<h2 id="独立思考"><span class="section-num">4</span> 独立思考</h2>
<p>微信以前一直有发最新iPhone手机的传统，但是那已经是4年前的美好时光了。</p>
<p>记得2021年是小龙明确年会不会发手机的第一年，他当时透露，那一年会发个铝片。</p>
<p>当时同事之间还在讨论，iPhone也是一块铝片冲压而成的嘛，那发的是否还是iPhone呢，不发手机只是烟雾弹?</p>
<p>拆开年会礼物之后发现，的确是一块铝片，上面写着「2022保持独立思考」.</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-e312c" hidden>
    <label for="zoomCheck-e312c">
    
    
    <img class="zoomCheck" loading="lazy" src="/ox-hugo/think_independently.jpg"/> 
    
    
    </label>
</figure>

<p>小龙一直强调「独立思考」对微信的重要性，认为如果要选择一个最重要的品质，他会选择「独立思考」。</p>
<p>上级说的不一定是对的，老师说的不一定是对，学术机构说的也不一定是对，媒体说的也不一定是对，声音大的更不一定是对，毕竟有理不在言高。</p>
<p>比如微服务架构非常流行，许多公司都在搞微服务，那么单体架构是否就应该不使用？</p>
<p>作为初创公司或小团队，新业务是否要上微服务架构呢？还是先使用单体架构，业务发展起来再迁移到服务呢？</p>
<p>开发过程免不了要做各种决策，比如技术选型，针对你的需求，你可能会找到一打「看似」符合要求的组件，
可能还会去网上找找对各个组件的评价，会发现众说纷纭，就需要自己独立对每个组件做出分析，找出其优劣，再结合自身团队的特点，做出决策.</p>
<p>关于独立思考，我最喜欢的是一句话是HBO出品短剧《切尔诺贝利》里面，
科学家瓦列里·列加索夫希望克格勃释放调查真相同事乌拉娜·霍缪克的要求，说可以保证她是没问题的，克格勃头子回答的那句话:</p>
<blockquote>
<p>Trust, but verify.(相信，但要核实)</p></blockquote>
<h2 id="先跑起来再说"><span class="section-num">5</span> 先跑起来再说</h2>
<p>这句话还有一个广为人知的变种：「又不是不能用」</p>
<p>很多的程序员都是完美主义者，尤其是读过《重构》和《设计模式》的程序员，会倾向于把很多时间来优化代码，做重构。</p>
<p>以前的我也会有类似的冲动，总会想时间去优化代码, 但是项目肝多了之后，有种强烈的感觉，还是先把MVP上线，及早让用户体验。</p>
<p>如果没有用户使用，再好再漂亮的代码也没有任何意义了。</p>
<p>所以经常看到社区有人问做副业的时候，应该用什么语言和框架，PHP/Python/Ruby 会不会太慢，我的观点一直都是，先做个原型跑起来，先找到第一个用户再说。</p>
<p>当运行速度成为瓶颈时, 你的业务已经非常大，肯定有足够的钱可以招一打的程序员把你的项目换成Golang/Java了。</p>
<p>对此，我很赞同坐我旁边大佬关于代码质量的说法：</p>
<blockquote>
<p>make it run, make it fast, make it beautiful.</p></blockquote>
<p>最近在做副业的尝试，有个深刻的体会，技术可能是商业里面最不重要的。</p>
<p>从零把产品做出来，推广给用户，用户只会关注你的产品是否好用，能否解决他们的问题.</p>
<p>他们既不会关注你是用C++/Java还是Javascript 写的,也不会关注你代码写得是否优雅，与其执着于技术选型，不如先把产品干出来让用户试用。</p>
<h2 id="顺手的才是最好的"><span class="section-num">6</span> 顺手的才是最好的</h2>
<p>经常会看到有人在社区提问，什么语言最好，什么框架最好，什么编辑器最好，什么操作系统最好。</p>
<p>「最好」是个相当主观的结论，也并没有针对所有场景的「最好」的解决方案, 但是经常能看到社区有人因为哪个语言更好而吵起来.</p>
<p>或者有人在分享A的时候，有人会在下面回复B/C/D更好, 然后又争吵起来.</p>
<p>让不禁让我想起《社会性动物》这本著名的社会心理学著作里面提到的团队认同现象，
当球迷与某支球队产生强烈的认同感后，会将球队视为自我认同的一部分，这里他们会：</p>
<ol>
<li>用「我们」而不是「他们」来称呼球队</li>
<li>将球队的成功视为个人的成功</li>
<li>对批评球队的言论产生防御性反应，将这些批评视为对自我的攻击</li>
</ol>
<p>如果有人问我这个问题，我会回答「你顺手熟悉的工具的最好」。</p>
<p>即使是出于乐趣，编程的目的还是利用计算机解决问题，而解决问题最好的工具就是你最熟悉的工具。</p>
<p>除非你了解的工具不适用于你的问题，那么自然就需要一个新工具，也不要削足适履，矫枉过正。</p>
<p>当然，如果是为了满足求知欲而想去学习一个新的语言，那选择你感兴趣的就可以了。</p>
<p>当初在2017年学习Rust, 也只是因为大四没有课，时间充裕, 想学点有趣的新东西，那时候Rust1.0才发布2年, 可没指望能靠Rust找到工作</p>
<p>记不清在哪里看过的一段话：</p>
<blockquote>
<p>我也曾问过自己类似的问题:</p>
<ol>
<li>是不是好的东西就能流行？不一定</li>
<li>是不是我喜欢的东西就是好的东西？不一定</li>
<li>我会不会花时间精力在一个不一定会流行但是我喜欢的东西上？会</li>
</ol></blockquote>
<h2 id="多与人交流"><span class="section-num">7</span> 多与人交流</h2>
<p>程序员固然是和机器打交道，但是本质解决的还是人的问题.</p>
<p>当初学习编程的时候，曾经有个误区，认为自己只要把技术搞好，就可以不去关心什么「人情世故」。</p>
<p>因此初入职场之后，我既是这么持有这样的想法，又是这样行动的，虽然不至于对其他人冷脸相对，但是难免会如好友形容那般：「孤傲」</p>
<p>但是被毒打时间久了才会发现，无论是在国内或国外，都难免会有「人情世故」，用英文来说，那叫 network and connection.</p>
<p>即使我技术能力过硬，也需要被人见到才行，和同事领导相处关系好，才可以在做出成绩的时候，「花花轿子被众人抬」。</p>
<p>所以我现在都是有事没事都和同事们聊天，既可以提升下熟悉度，也可以了解到许多部门八卦，
还可以从同事们抱怨中找到潜在优化点，践行自己「Work hard and be nice to people」的理念.</p>
<p>这行做久了，会发现软件工程其实说到底，就是人的系统工程。</p>
<h2 id="代码不是万能的"><span class="section-num">8</span> 代码不是万能的</h2>
<p>程序写多了之后就会有种幻觉，就是觉得什么事情都可以用代码来解决。</p>
<p>手里拿着锤子的时候，把什么都当成钉子来砸。</p>
<p>被毒打多才认清的事实就是，有很多事情是无法用代码来解决，代码只是个工具，只能在个合适的场景使用, 避免路径依赖.</p>
<p>酒香也怕巷子深，只会写代码没啥用，还要写文章，在公司内部做分享，让别人能「看到你」。</p>
<p>编程肝项目的专业能力固然重要，但是也要有营销自己的软实力，就像一位长者说的那样: 两手抓，两手都要硬.</p>
<p>不知道是中国人讲究谦虚内敛的品质，还是程序员「木讷呆板」的刻板印象，导致大家都不怎么营销自己。</p>
<p>有事没事和老板聊下天，增进下交流，经常露个脸，可能比肝十个项目还有用。</p>
<h2 id="与优秀的人共事"><span class="section-num">9</span> 与优秀的人共事</h2>
<p>从业多年，去过蚂蚁金服，微信支付和AWS 搬砖, 和各种各样的同事都共事过，有个越发强烈的感悟：</p>
<p><strong><strong>要与优秀的人共事</strong></strong></p>
<p>不仅能从他们身上学到非常到的优点，提升技术能力，可以学到最佳实践和工程经验，在Code Review 的时候可以学到更好的编程方式，遇到问题时又有靠谱的队友帮忙和指导。</p>
<p>由优秀的程序员开发出来的系统的独特之处，知道什么叫简单好用的系统，形成自己的技术品味。</p>
<p>品味与美感这个词是很抽象，但是用过了好用的系统，自然就不会对那些粗制滥造，还靠老板背书强行推广的系统感兴趣。</p>
<p>而提高技术品味在提高我们的技术认知的前提下，又能反过来帮我们提高设计能力.</p>
<p>和优秀的同事共事的另外一个好处是可以建立高质量的人脉网络，利于职业发展，跳槽换赛道也多个选择。</p>
<p>虽然初始公司也有优秀的开发者，但是平均而言，大公司优秀程序员的比例会更高，毕竟他们更有竞争力的薪资福利，自然也有更高的招聘门槛。</p>
<p>比如微信就有所谓的面试委员会，除了招聘部门的面试官之外，还要通过面委面试官的考核，避免为了快速招人而降低标准。</p>
<p>所以个人建议应届毕业生，有机会还是去大公司，见识下。</p>
<p>虽然离职微信快两年了，我仍然想念当初同组共事的同事们，他们真的是技术过硬，人又超nice, 还乐于帮忙.</p>
<p>正如孔子所言：与善人居，如入兰芷之室，久而不闻其香，则与之化矣；与恶人居，如入鲍鱼之肆，久而不闻其臭，亦与之化矣</p>
<h2 id="身体是一切的本钱"><span class="section-num">10</span> 身体是一切的本钱</h2>
<p>编程这么多年，落下一堆的职业病。</p>
<p>大学时候就有的鼠标手(腱鞘炎), 工作几年之后「喜提」腰椎间盘突出，久坐下半身会麻痹，还有我曾经浓密黝黑的头发，现在也日渐凋零。</p>
<p>因为腾讯总部有免费的健身房，所以我基本工作日都会去健身房薅公司羊毛，2天有氧慢跑，2天无氧器械，坚持了快3年。
也开始注意自己的饮食，尽量少油少糖不喝酒。</p>
<p>健身虽然不是包治百病，但是起码人显得有精神了，也有精力应付高强度的工作了。</p>
<p>只有失去才会懂得珍惜，也真的只有在开始吃药，去医院复诊，才会开始注意身体。</p>
<p>虽然编程很有趣，虽然养家很重要，但是还是要注意身体，毕竟身体是一切的本钱，垮就没有其他的精彩故事了。</p>
<h2 id="总结"><span class="section-num">11</span> 总结</h2>
<p>无论是编程，还是其他的技能，我感觉都是「马太效应」，你学得越多，你懂得越多，再学新的东西，你就会学得越快。</p>
<p>代码写多了才意识到，程序员的竞争力并不是写代码，也并不是哪门语言或者框架，
其核心竞争力是通过技术解决问题的能力，又何必再去拘泥于哪门具体的编程语言或技术呢。</p>
<p>希望编程十年只是个起点，十年后可以再写一篇「编程二十年的感悟」</p>
<h3 id="推荐阅读">推荐阅读</h3>
<ul>
<li>旅加经历
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E8%BF%99%E4%BA%9B%E5%B9%B4%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF_%E4%BB%8E%E5%B9%BF%E5%B7%9E%E5%88%B0%E6%B8%A9%E5%93%A5%E5%8D%8E/">这些年走过的路：从广州到温哥华</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/">加拿大之初体验</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E5%8A%A0%E6%8B%BF%E5%A4%A7%E8%80%83%E9%A9%BE%E7%85%A7%E7%9A%84%E7%BB%8F%E5%8E%86/">加拿大考驾照的经历</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/">登陆加拿大一年后的体会</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%97%81%E8%A7%82%E8%80%85%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8A%A0%E6%8B%BF%E5%A4%A7%E7%9C%81%E8%AE%AE%E4%BC%9A%E9%80%89%E4%B8%BE/">旁观者眼中的加拿大省议会选举</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E5%A4%8F%E6%97%A5%E6%8D%95%E8%9F%B9%E8%AE%B0/">夏日捕蟹记</a></li>
</ul>
</li>
<li>历史思考
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/">为什么梦想买不起，故乡回不去</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%B6%A6%E5%90%91%E4%BD%95%E6%96%B9_%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%82%89%E8%BA%AB%E7%BF%BB%E5%A2%99%E6%8C%87%E5%8C%97/">润向何方：不完全肉身翻墙指北</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E7%9A%87%E5%B8%9D%E4%B8%8E%E5%AE%98%E5%83%9A/">皇帝与官僚：「上面」与「下面」</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E9%97%B2%E8%81%8A%E5%86%99%E4%BD%9C/">闲聊写作的好处</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E9%87%91%E6%A6%9C%E9%A2%98%E5%90%8D%E4%B9%8B%E5%90%8E/">金榜题名之后</a></li>
</ul>
</li>
<li>工具流分享
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E7%AE%80%E6%98%8E%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/">简明写作指南</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%88%91%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/">我的写作流</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%88%91%E7%9A%84%E7%94%BB%E5%9B%BE%E6%B5%81/">我的画图流：画图工具与技巧分享</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E6%88%91%E7%9A%84%E6%90%9C%E7%B4%A2%E6%B5%81/">我的搜索流：高效搜索经验分享</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2022/feynman_technique/">最好的学习方式：费曼学习法(Feynman Technique)</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2021/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/">系统思考：既见树木，又见森林</a></li>
</ul>
</li>
<li>职场思考
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2023/%E4%BB%8E%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%A6%BB%E7%BA%BF_%E6%88%91%E5%B8%A6%E8%B5%B0%E4%BA%86%E4%BB%80%E4%B9%88/">那些年，我从微信支付学到的东西</a></li>
</ul>
</li>
<li>软件工程
<ul>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%B8%80_%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E8%AE%A4%E7%9F%A5/">测试技能进阶(一): 软件质量认知</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%BA%8C_parameterized_tests/">测试技能进阶(二): Parameterized Tests</a></li>
<li><a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%B8%89_property_based_testing/">测试技能进阶(三): Property Based Testing</a></li>
</ul>
</li>
</ul>
<div center class="qr-container">
<img src="/ox-hugo/qrcode_gh_e06d750e626f_1.jpg" alt="qrcode_gh_e06d750e626f_1.jpg" width="160px" height="160px" center="t" class="qr-container" />
公号同步更新，欢迎关注👻
</div>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://struts.apache.org/">https://struts.apache.org/</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://hibernate.org/">https://hibernate.org/</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">https://docs.spring.io/spring-framework/reference/web/webmvc.html</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://ibatis.apache.org/">https://ibatis.apache.org/</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p><a href="https://mybatis.org/mybatis-3/">https://mybatis.org/mybatis-3/</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p><a href="https://github.com/sofastack/sofa-rpc">https://github.com/sofastack/sofa-rpc</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a>&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p><a href="https://github.com/sofastack/sofa-boot">https://github.com/sofastack/sofa-boot</a>&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p><a href="https://www.interpals.net/">https://www.interpals.net/</a>&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Rust通过Trait扩展已有类型</title>
      <link>https://ramsayleung.github.io/zh/post/2024/rust%E9%80%9A%E8%BF%87trait%E6%89%A9%E5%B1%95%E5%B7%B2%E6%9C%89%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 04 Dec 2024 18:04:00 -0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2024/rust%E9%80%9A%E8%BF%87trait%E6%89%A9%E5%B1%95%E5%B7%B2%E6%9C%89%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;swift-extension&#34;&gt;&lt;span class=&#34;section-num&#34;&gt;1&lt;/span&gt; Swift extension&lt;/h2&gt;
&lt;p&gt;可扩展性是一个语言非常关键的特性，以Swift 为例，它有一个相当好用的特性，名为 &lt;a href=&#34;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/&#34;&gt;extension&lt;/a&gt;, 它可以非常便利地扩展已有的类型, 例如给已有类型增加 computed property, 实例方法, 新增构造器又或是实现新的 Protocol.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="swift-extension"><span class="section-num">1</span> Swift extension</h2>
<p>可扩展性是一个语言非常关键的特性，以Swift 为例，它有一个相当好用的特性，名为 <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/">extension</a>, 它可以非常便利地扩展已有的类型, 例如给已有类型增加 computed property, 实例方法, 新增构造器又或是实现新的 Protocol.</p>
<p>已有的类型既可以是你自己的代码，或者是第三方的代码，甚至是标准库的代码, 以标准库的 <code>String</code> 类型为例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">extension</span> <span class="nc">String</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nv">isPalindrome</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">reversed</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">reversed</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">self</span> <span class="p">==</span> <span class="n">reversed</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;Hello </span><span class="si">\(</span><span class="kc">self</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">word</span> <span class="p">=</span> <span class="s">&#34;racecar&#34;</span>
</span></span><span class="line"><span class="cl"><span class="bp">print</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">isPalindrome</span><span class="p">)</span> <span class="c1">// Outputs: true</span>
</span></span><span class="line"><span class="cl"><span class="n">word</span><span class="p">.</span><span class="n">greet</span><span class="p">()</span> <span class="c1">// Outputs: Hello racecar</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>又或者让 <code>String</code> 实现新的 Protocol, 如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">extension</span> <span class="nc">String</span><span class="p">:</span> <span class="n">YourOwnProtocol</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>换言之，如果你对已有的类型不满意，你可以直接扩展已有的类型，添加上你想要的属性，方法或者实现你期望的接口。</p>
<h2 id="rust-的扩展能力"><span class="section-num">2</span> Rust 的扩展能力</h2>
<p>Rust 也部分支持Swift extension 特性，如让已有的类型实现新的Trait.</p>
<p>还是以 <code>String</code> 为例子, 我们希望给 <code>String</code> 实现一个 <code>Greet</code> 的接口:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// Define a trait with the desired functionality
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Implement the trait for an existing type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;Hello, </span><span class="si">{}</span><span class="s">!&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Rust&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="n">greet</span><span class="p">());</span><span class="w"> </span><span class="c1">// Outputs: &#34;Hello, Rust!&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样我们就给 <code>String</code> 添加上 <code>greet</code> 方法，不足之处在于，需要定义一个额外的 <code>trait=，没有像 Swift 那样的 =extension</code> 语法糖可以用.</p>
<h3 id="实际例子"><span class="section-num">2.1</span> 实际例子</h3>
<p>上面的 <code>Greet</code> 接口可能过于简单，让我们来看下实际项目的例子, 在<a href="https://ramsayleung.github.io/zh/post/2024/%E6%B5%8B%E8%AF%95%E6%8A%80%E8%83%BD%E8%BF%9B%E9%98%B6%E4%B8%89_property_based_testing/">测试技能进阶(三): Property Based Testing</a> 一文中，我提到了使用 <a href="https://github.com/BurntSushi/quickcheck">Quickcheck</a> 库在Rust实现 Property Based Testing.</p>
<p>假如有 Book struct, 我们只要实现 quickcheck 的 Arbitrary 接口，quickcheck 就会按照我们指定的规则来生成随机测试数据:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">quickcheck</span>::<span class="p">{</span><span class="n">Arbitrary</span><span class="p">,</span><span class="w"> </span><span class="n">Gen</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Debug, Clone, PartialEq)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Book</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">isbn</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">title</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">author</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">publication_year</span>: <span class="kt">u16</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Arbitrary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Book</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">arbitrary</span><span class="p">(</span><span class="n">g</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Gen</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Book</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// isbn必须以`ISBN` 开头，后接任意的大于等于0，小于uint32.max_value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// 的整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">isbn</span>: <span class="nc">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;ISBN-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">title</span>: <span class="nb">String</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="c1">// 任意的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">author</span>: <span class="nb">String</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="c1">// 任意的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">publication_year</span>: <span class="o">*</span><span class="n">g</span><span class="p">.</span><span class="n">choose</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2014_</span><span class="k">u16</span><span class="p">,</span><span class="w"> </span><span class="mi">2022_</span><span class="k">u16</span><span class="p">,</span><span class="w"> </span><span class="mi">2025_</span><span class="k">u16</span><span class="p">]).</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="c1">// 2014,2022或2025年出版的书
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>quickcheck 的 <code>Gen</code> 结构体有一个非常顺手的函数 <code>gen_range</code> ，用于生成指定的范围的数据, 但是作者在<a href="https://github.com/BurntSushi/quickcheck/blob/aa968a94650b5d4d572c4ef581a7f5eb259aa0d2/src/arbitrary.rs#L72">1.0</a>之后，就不向外暴露这个接口了，不然我们就可以通过 <code>g.gen_range(b'a'...b'z') as char)</code> 来指定我们想要的数据.</p>
<p>既然这么好用的函数没有了，我们可以通过 <code>Trait</code> 的扩展能力，把这个 <code>gen_range</code> 函数带回来.</p>
<p>思路很简单，就是定义一个 <code>GenRange</code> Trait, 然后再让 <code>Gen</code> 实现这个 <code>Trait</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">ops</span>::<span class="n">Range</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">num_traits</span>::<span class="n">sign</span>::<span class="n">Unsigned</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">quickcheck</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">GenRange</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">gen_range</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Unsigned</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Arbitrary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_range</span>: <span class="nc">Range</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">GenRange</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Gen</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">gen_range</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Unsigned</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Arbitrary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">range</span>: <span class="nc">Range</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Arbitrary</span><span class="o">&gt;</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通过上面的代码, 我们就可以在 <code>Book</code> 的 <code>arbitrary</code> 函数中使用 <code>gen_range</code> 了:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Arbitrary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Book</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">arbitrary</span><span class="p">(</span><span class="n">g</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Gen</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Book</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// isbn必须以`ISBN` 开头，后接任意的大于等于0，小于uint32.max_value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// 的整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">isbn</span>: <span class="nc">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;ISBN-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">title</span>: <span class="nb">String</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="c1">// 任意的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">author</span>: <span class="nb">String</span>::<span class="n">arbitrary</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="c1">// 任意的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">publication_year</span>: <span class="nc">g</span><span class="p">.</span><span class="n">gen_range</span><span class="p">(</span><span class="mi">2014</span><span class="o">..</span><span class="p">.</span><span class="mi">2026</span><span class="p">),</span><span class="w"> </span><span class="c1">// 2014-2025年出版的书
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用已有trait扩展已有类型"><span class="section-num">2.2</span> 使用已有Trait扩展已有类型</h3>
<p>上面提到的例子都是通过定义一个新的 <code>Trait</code>, 然后让已有类型实现这个新Trait, 那么是否可以让已有类型实现已有的Trait 呢?</p>
<p>事实上, 由于Orphan Rule的限制, Rust 并不允许已有类型实现已有接口, 以下的代码是无法编译通过的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Implement the external trait for the wrapper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;String: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>所谓的 <code>Orphan Rule</code> 限制指的是，如果允许已有类型实现已有接口, 那么 <code>lib1</code> 和 <code>lib2</code> 都实现了 <code>impl fmt::Display for String</code>, 编译器并不知道应该使用哪个lib的实现.</p>
<p>对此，Rust 官方也提供了<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">指引</a>，我们可以通过定义一个 <code>Wrapper</code> 类来实现我们的诉求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Define a newtype wrapper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">MyString</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Implement the external trait for the wrapper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;MyString: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyString</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">// Outputs: MyString: Hello
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考"><span class="section-num">3</span> 参考</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></li>
<li><a href="//github.com/BurntSushi/quickcheck/issues/267">add back a way to put a bound on numbers generated</a></li>
</ul>
<div center class="qr-container">
<img src="/ox-hugo/qrcode_gh_e06d750e626f_1.jpg" alt="qrcode_gh_e06d750e626f_1.jpg" width="160px" height="160px" center="t" class="qr-container" />
公号同步更新，欢迎关注👻
</div>
]]></content:encoded>
    </item>
  </channel>
</rss>
