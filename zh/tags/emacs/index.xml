<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>emacs on 自由庄园</title>
    <link>https://ramsayleung.github.io/zh/tags/emacs/</link>
    <description>Recent content in emacs on 自由庄园</description>
    <image>
      <title>自由庄园</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.120.4</generator>
    <language>zh</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 ·</copyright>
    <lastBuildDate>Tue, 31 Dec 2024 11:57:41 -0800</lastBuildDate>
    <atom:link href="https://ramsayleung.github.io/zh/tags/emacs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>单独使用Emacs的Magit插件</title>
      <link>https://ramsayleung.github.io/zh/post/2024/%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8emacs%E7%9A%84magit%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Wed, 11 Dec 2024 16:00:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2024/%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8emacs%E7%9A%84magit%E6%8F%92%E4%BB%B6/</guid>
      <description>1 Emacs 与 Magit 不知不觉，我已经使用Emacs 快10年了，在我使用过的编辑器中，Emacs是扩展性最强的编辑器，毕竟Emacs是个披着编辑器外衣的L</description>
      <content:encoded><![CDATA[<h2 id="emacs-与-magit"><span class="section-num">1</span> Emacs 与 Magit</h2>
<p>不知不觉，我已经使用Emacs 快10年了，在我使用过的编辑器中，Emacs是扩展性最强的编辑器，毕竟Emacs是个披着编辑器外衣的Lisp虚拟机。</p>
<p>在Emacs无所不能的扩展性之下，诞生了非常多强大的插件，
也让Emacs有了「伪装成操作系统的编辑器」的美名，而Emacs公认的杀手锏插件有两个，一个是 <a href="https://orgmode.org/">org-mode</a>，另一个是 <a href="https://magit.vc/">magit</a>. (我个人觉得还有个 <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html">dired</a>)</p>
<p>Orgmode是类似Markdown，与Emacs深度绑定优化的标记语言，使用Emacs来编写org-mode 文档就有下笔有神，文思泉涌，如丝般顺滑(这篇文章也是用org-mode写的)。</p>
<p>因为org-mode 与Emacs 深度结合，自然无法脱离Emacs单独使用，而其他编辑器模仿org-mode 开发的插件，如 <a href="https://github.com/jceb/vim-orgmode">vim-orgmode</a>, <a href="https://github.com/nvim-orgmode/orgmode">nvim-orgmode</a> 和 <a href="https://github.com/vscode-org-mode/vscode-org-mode">vscode-orgmode</a>, 难免只得其形，未得其神，还不如用Markdown.</p>
<p>而 Magit 是 Git的Emacs图形化客户端, 也是我用过的最好用的Git 客户端软件，既直观又易用(看看Emacs 道友们夸 Magit 的<a href="https://emacs-china.org/t/magit/22521/5">帖子</a>):</p>
<figure>
    <img loading="lazy" src="/ox-hugo/magit_dashboard.jpg"/> 
</figure>

<p>虽然我已经用了Emacs很多年，但是已经过了Live with Emacs的境界, 不会用Emacs处理所有事情, 比如用VSCode 写Rust, 用Intellij Idea写Java, 既然 Magit 那么好用，有没可能独立于Emacs使用呢?</p>
<h2 id="emacs-daemon"><span class="section-num">2</span> Emacs daemon</h2>
<p>作为无所不能的「操作系统」, Emacs 作为<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html">server</a> 一直在后台运行，然后再使用 <code>emacsclient</code> 连接 server:</p>
<p>前文提到, Emacs 是批着编辑器外衣的Lisp VM, 而 Magit 本质也只是一个 lisp function, 只要在启动emacsclient的时候，再调用 magit的函数, 那么就可以启动 Magit:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">magit</span><span class="o">=</span><span class="s2">&#34;emacsclient -nw -eval &#39;(magit-status)&#39;&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><figure>
    <img loading="lazy" src="/ox-hugo/magit.gif"/> 
</figure>

<p>这样就可以在VSCode和Idea里面愉快地使用 magit了.</p>
<h2 id="总结"><span class="section-num">3</span> 总结</h2>
<p>在Emacs-China 论坛搜索Magit的时候, 发现了也有一个帖子讨论把 <a href="https://emacs-china.org/t/magit/25527/6">magit当作的单独的工具</a>, 没想到有个回复的思路和我一样，使用Emacs作为daemon 来启用.</p>
<p>只是没有想到他更evil, 在Nvim 里面使用Magit, 我也学习一下 Nvim+Emacs 的组合 :)</p>
<h2 id="参考"><span class="section-num">4</span> 参考</h2>
<ul>
<li><a href="https://orgmode.org/">https://orgmode.org/</a></li>
<li><a href="https://magit.vc/">https://magit.vc/</a></li>
<li><a href="https://emacs-china.org/t/magit/22521/5">https://emacs-china.org/t/magit/22521/5</a></li>
<li><a href="https://emacs-china.org/t/magit/25527/6">https://emacs-china.org/t/magit/25527/6</a></li>
<li><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html</a></li>
<li><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Emacs技巧分享: 使用eww打开在线org-mode文档</title>
      <link>https://ramsayleung.github.io/zh/post/2023/emacs%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB_%E4%BD%BF%E7%94%A8eww%E6%89%93%E5%BC%80%E5%9C%A8%E7%BA%BForg-mode%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sat, 04 Mar 2023 21:55:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2023/emacs%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB_%E4%BD%BF%E7%94%A8eww%E6%89%93%E5%BC%80%E5%9C%A8%E7%BA%BForg-mode%E6%96%87%E6%A1%A3/</guid>
      <description>1 技巧 对于使用org-mode 格式的文本，例如Emacs官方 tree-sitter 的使用教程 在线阅读不是很易读，相当于人脑解析 org-mode. 我的个人习惯是使用 eww 浏览器来阅读</description>
      <content:encoded><![CDATA[<h2 id="技巧"><span class="section-num">1</span> 技巧</h2>
<p>对于使用org-mode 格式的文本，例如Emacs官方<a href="https://git.savannah.gnu.org/cgit/emacs.git/plain/admin/notes/tree-sitter/starter-guide?h=feature/tree-sitter"> tree-sitter 的使用教程</a></p>
<p>在线阅读不是很易读，相当于人脑解析 <code>org-mode</code>. 我的个人习惯是使用 <code>eww</code> 浏览器来阅读:</p>
<figure><a href="/ox-hugo/tree-sitter-doc.png">
    <img loading="lazy" src="/ox-hugo/tree-sitter-doc.png"/> </a>
</figure>

<ol>
<li>复制网页链接</li>
<li>使用 <code>eww</code> 打开链接</li>
<li><code>major-mode</code> 切换到 <code>org-mode</code>, 就可以愉快地使用 Emacs 来阅读 <code>org-mode</code> 文本.</li>
</ol>
<figure><a href="/ox-hugo/eww.gif">
    <img loading="lazy" src="/ox-hugo/eww.gif"/> </a>
</figure>

]]></content:encoded>
    </item>
    <item>
      <title>Emacs 技巧分享：dired-mode 批量修改文件名</title>
      <link>https://ramsayleung.github.io/zh/post/2023/%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB_dired%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</link>
      <pubDate>Sat, 04 Mar 2023 21:34:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2023/%E6%8A%80%E5%B7%A7%E5%88%86%E4%BA%AB_dired%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</guid>
      <description>1 技巧 分享一下平时使用 dired-mode 批量修改文件名的技巧: C-x C-f 指定的文件目录，进入 dired-mode C-x C-q dired-toggle-read-only: Edit Dired buffer with Wdired. 批量修改，手段有 使用 query-replace 批量修改文件名 使用evil的多</description>
      <content:encoded><![CDATA[<h2 id="技巧"><span class="section-num">1</span> 技巧</h2>
<p>分享一下平时使用 <code>dired-mode</code> 批量修改文件名的技巧:</p>
<ol>
<li><code>C-x C-f</code> 指定的文件目录，进入 <code>dired-mode</code></li>
<li><code>C-x C-q</code> <code>dired-toggle-read-only</code>: Edit Dired buffer with Wdired.</li>
<li>批量修改，手段有
<ul>
<li>使用 <code>query-replace</code> 批量修改文件名</li>
<li>使用evil的多行编辑模式</li>
<li>使用 <code>rectangle-command</code>: <code>C-x r t</code> <code>string-rectangle</code></li>
</ul>
</li>
<li><code>C-c C-c</code> 提交修改或 <code>C-c C-k</code> 放弃修改</li>
</ol>
<figure><a href="/ox-hugo/dired_rename_multi_files.gif">
    <img loading="lazy" src="/ox-hugo/dired_rename_multi_files.gif"
         alt="Figure 1: 使用 rectangle-command 进行批量修改"/> </a><figcaption>
            <p><span class="figure-number">Figure 1: </span>使用 <code>rectangle-command</code> 进行批量修改</p>
        </figcaption>
</figure>

<figure><a href="/ox-hugo/dired_rename_multi_files_2.gif">
    <img loading="lazy" src="/ox-hugo/dired_rename_multi_files_2.gif"
         alt="Figure 2: 使用 evil的多行编辑模式进行批量修改"/> </a><figcaption>
            <p><span class="figure-number">Figure 2: </span>使用 evil的多行编辑模式进行批量修改</p>
        </figcaption>
</figure>

]]></content:encoded>
    </item>
    <item>
      <title>Eshell实现fzf的历史命令搜索功能</title>
      <link>https://ramsayleung.github.io/zh/post/2017/search_eshell_history_like_fzf/</link>
      <pubDate>Sun, 17 Dec 2017 15:46:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2017/search_eshell_history_like_fzf/</guid>
      <description>1 前言 目标: 在Eshell中像在bash/zsh中使用fzf那般搜索历史命令 2 fzf 我的主力Shell 是Eshell, 但是平时我也会用Zsh, 而</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>目标: 在<code>Eshell</code>中像在bash/zsh中使用<code>fzf</code>那般搜索历史命令</p>
<h2 id="fzf"><span class="section-num">2</span> fzf</h2>
<p>我的主力Shell 是Eshell, 但是平时我也会用Zsh, 而<a href="https://github.com/junegunn/fzf">fzf</a> 是一个非常好用的命令行工具，用了<code>fzf</code>搜索历史命令:</p>
<figure>
    <img loading="lazy" src="https://i.imgur.com/pPMxauw.gif"
         alt="Figure 1: fzf"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>fzf</p>
        </figcaption>
</figure>

<h2 id="eshell"><span class="section-num">3</span> Eshell</h2>
<p>我日常的操作基本都是在 Eshell 上面进行的，不过 Eshell 是没办法直接像 Bash 那样调用 <code>fzf</code>来查找命令历史的，所以我希望把这个功能迁移到到Eshell 上面来。</p>
<p>我在 Emacs 使用的补全框架是 <code>Ivy/Counsel</code>,它有一个 <code>counsel-esh-history</code>的命令可以使用 <code>Ivy</code> 来搜索命令，但是没办法使用用户已经输入的内容来过滤命令，所以我就在自己折腾了一个</p>
<p><code>counsel-esh-history</code> 命令。效果如下：</p>
<figure>
    <img loading="lazy" src="https://i.imgur.com/3tvGDzW.gif"
         alt="Figure 2: 感觉很不错嘛 :)"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>感觉很不错嘛 :)</p>
        </figcaption>
</figure>

<h2 id="源代码"><span class="section-num">4</span> 源代码</h2>
<p>得益于 <code>Ivy</code>强大的内置函数, 功能实现起来相当便利，完整代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">samray/esh-history</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Interactive search eshell history.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">interactive</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;em-hist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">save-excursion</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">start-pos</span> <span class="p">(</span><span class="nv">eshell-bol</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	   <span class="p">(</span><span class="nv">end-pos</span> <span class="p">(</span><span class="nv">point-at-eol</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	   <span class="p">(</span><span class="nv">input</span> <span class="p">(</span><span class="nv">buffer-substring-no-properties</span> <span class="nv">start-pos</span> <span class="nv">end-pos</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">command</span> <span class="p">(</span><span class="nv">ivy-read</span> <span class="s">&#34;Command: &#34;</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nv">delete-dups</span>
</span></span><span class="line"><span class="cl">				 <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nv">ring-size</span> <span class="nv">eshell-history-ring</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				   <span class="p">(</span><span class="nv">ring-elements</span> <span class="nv">eshell-history-ring</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">				<span class="ss">:preselect</span> <span class="nv">input</span>
</span></span><span class="line"><span class="cl">				<span class="ss">:action</span> <span class="nf">#&#39;</span><span class="nv">ivy-completion-in-region-action</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	     <span class="p">(</span><span class="nv">cursor-move</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">command</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">start-pos</span> <span class="nv">cursor-move</span><span class="p">)</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">end-pos</span> <span class="nv">cursor-move</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; move cursor to eol</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">end-of-line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码不是很复杂, 主要功能是获取用户输入的命令, 然后把所有的历史命令读取出来,最后使用<code>ivy-read</code>内置的<code>ivy-completion-in-region-action</code>功能, 用用户的输入的命令与历史命令进行匹配, 由用户选择最终的命令.</p>
<p><code>ivy-read</code>是Emacs内置<code>completing-read</code>的函数的强化, 关于<code>ivy-read</code>具体用法可以参考文档<a href="https://oremacs.com/swiper/#getting-started">ivy-read</a>.</p>
<h2 id="总结"><span class="section-num">5</span> 总结</h2>
<p>最后, 我也顺便把代码分享到 <a href="https://www.reddit.com/r/emacs/comments/7k54px/snippet_share_make_eshell_search_command_history/">Emacs社区</a>, 而 <a href="https://github.com/manateelazycat">manateelazycat</a>也把这段代码的功能加入到<a href="https://github.com/manateelazycat/aweshell/commit/ecaddac98b87f881910dbee8b51a98f00b6d9d5d">aweshell</a>, Oh yeah !</p>
]]></content:encoded>
    </item>
    <item>
      <title>Eshell提示符优化</title>
      <link>https://ramsayleung.github.io/zh/post/2017/tweak_eshell_prompt/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2017/tweak_eshell_prompt/</guid>
      <description>Tweak with Emacs shell prompt</description>
      <content:encoded><![CDATA[<h2 id="发现帅气的提示符"><span class="section-num">1</span> 发现帅气的提示符</h2>
<p>近日，笔者在浏览 <a href="https://www.reddit.com/r/emacs/comments/6f0rkz/my_fancy_eshell_prompt/">Reddit</a> 的时候，发现了一位 Emacs 用户把他的 Eshell 提示符修改得很帅，如图：</p>
<p><a href="/ox-hugo/eshell_prompt.png"><img loading="lazy" src="/ox-hugo/eshell_prompt.png" alt=""  />
</a>
本着拿来主义的想法，我就直接把这位小哥的代码添加到了我的配置文件里面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-prompt-function</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="s">&#34;┌─[&#34;</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="p">(</span><span class="nf">user-login-name</span><span class="p">)</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;red&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="s">&#34;@&#34;</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="p">(</span><span class="nf">system-name</span><span class="p">)</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;blue&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="s">&#34;]──[&#34;</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="p">(</span><span class="nf">format-time-string</span> <span class="s">&#34;%H:%M&#34;</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;yellow&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="s">&#34;]──[&#34;</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nv">eshell/pwd</span><span class="p">))</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;white&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="s">&#34;]\n&#34;</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="s">&#34;└─&gt;&#34;</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">propertize</span> <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">user-uid</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&#34; # &#34;</span> <span class="s">&#34; $ &#34;</span><span class="p">)</span> <span class="ss">&#39;face</span> <span class="o">`</span><span class="p">(</span><span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>效果自然是很 sexy.</p>
<h2 id="与原有提示符冲突"><span class="section-num">2</span> 与原有提示符冲突</h2>
<p>但是我原来使用的 <a href="https://github.com/kaihaosw/eshell-prompt-extras">eshell-prompt-extra</a> 的效果就被覆盖了。而 <code>eshell_prompt_extra</code> 可以提供的额外信息非常多，包括：git, python virtualenv, 以及远程登录时的主机信息，如图：</p>
<figure><a href="/ox-hugo/eshell_extra_prompt.png">
    <img loading="lazy" src="/ox-hugo/eshell_extra_prompt.png"/> </a>
</figure>

<p>如果用上这个 sexy 的提示符，eshell-extra-prompt 的额外的信息就不能显示，感觉好亏:(</p>
<p>鱼和熊掌我都想要，似乎太贪心了？怎么办，自己去修改 <code>eshell_prompt_extra</code> 的<a href="https://github.com/kaihaosw/eshell-prompt-extras/blob/master/eshell-prompt-extras.el">源码</a> :).</p>
<h2 id="折腾源码"><span class="section-num">3</span> 折腾源码</h2>
<p><code>eshell_prompt_extra</code> 这个包注释加上全部代码也只是 400 行，代码也写得很清晰. 其中大部份是辅助函数，而 Eshell 的提示符效果是通过两个 eshell-theme 函数来实现的。use-package 的配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">eshell-prompt-extras</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:ensure</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:load-path</span> <span class="s">&#34;~/Code/github/eshell-prompt-extras&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span> <span class="p">(</span><span class="nb">progn</span>
</span></span><span class="line"><span class="cl">	    <span class="p">(</span><span class="nb">with-eval-after-load</span> <span class="s">&#34;esh-opt&#34;</span>
</span></span><span class="line"><span class="cl">	      <span class="p">(</span><span class="nb">use-package</span> <span class="nv">virtualenvwrapper</span> <span class="nb">:ensure</span> <span class="no">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	      <span class="p">(</span><span class="nv">venv-initialize-eshell</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	      <span class="p">(</span><span class="nf">autoload</span> <span class="ss">&#39;epe-theme-lambda</span> <span class="s">&#34;eshell-prompt-extras&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	      <span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-highlight-prompt</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">		    <span class="nv">eshell-prompt-function</span> <span class="ss">&#39;epe-theme-lambda</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	    <span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而 <code>epe-theme-lambda</code> 的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">epe-theme-lambda</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;A eshell-prompt lambda theme.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-prompt-regexp</span> <span class="s">&#34;^[^#\nλ]*[#λ] &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">epe-remote-p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nv">epe-colorize-with-face</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nv">epe-remote-user</span><span class="p">)</span> <span class="s">&#34;@&#34;</span> <span class="p">(</span><span class="nv">epe-remote-host</span><span class="p">)</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="ss">&#39;epe-remote-face</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">when</span> <span class="nv">epe-show-python-info</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;epe-venv-p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">epe-venv-p</span><span class="p">)</span> <span class="nv">venv-current-name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nv">epe-colorize-with-face</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;(&#34;</span> <span class="nv">venv-current-name</span> <span class="s">&#34;) &#34;</span><span class="p">)</span> <span class="ss">&#39;epe-venv-face</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nf">eq</span> <span class="nv">epe-path-style</span> <span class="ss">&#39;fish</span><span class="p">)</span> <span class="ss">&#39;epe-fish-path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		  <span class="p">((</span><span class="nf">eq</span> <span class="nv">epe-path-style</span> <span class="ss">&#39;single</span><span class="p">)</span> <span class="ss">&#39;epe-abbrev-dir-name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		  <span class="p">((</span><span class="nf">eq</span> <span class="nv">epe-path-style</span> <span class="ss">&#39;full</span><span class="p">)</span> <span class="ss">&#39;abbreviate-file-name</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nf">funcall</span> <span class="nv">f</span> <span class="p">(</span><span class="nv">eshell/pwd</span><span class="p">))</span> <span class="ss">&#39;epe-dir-face</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">epe-git-p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;:&#34;</span> <span class="ss">&#39;epe-dir-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nv">epe-colorize-with-face</span>
</span></span><span class="line"><span class="cl">       <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nv">epe-git-branch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	       <span class="p">(</span><span class="nv">epe-git-dirty</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	       <span class="p">(</span><span class="nv">epe-git-untracked</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	       <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">unpushed</span> <span class="p">(</span><span class="nv">epe-git-unpushed-number</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		 <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">unpushed</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		   <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;:&#34;</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">unpushed</span><span class="p">)))))</span>
</span></span><span class="line"><span class="cl">       <span class="ss">&#39;epe-git-face</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34; λ&#34;</span> <span class="ss">&#39;epe-symbol-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">user-uid</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&#34;#&#34;</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			   <span class="ss">&#39;epe-sudo-symbol-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34; &#34;</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码主要逻辑是调用之前定义的辅助函数，判断是否需要显示 git, python, 远程主机等信息，然后对相应的提示符进行拼接。</p>
<p>而其中出现得比较频繁的 <code>epe-colorize-with-face</code> 就是作者定义的一个宏(macro), 用来显示字符串以及对应的 face(其实就是不同的颜色啦). 看懂了代码就好办了，现在就可以自己添加一个 Eshell 主题。</p>
<h3 id="定义所需的-face"><span class="section-num">3.1</span> 定义所需的 face</h3>
<p>因为我需要显示的 face(颜色), <code>eshell-extra-prompt</code> 并没有定义，所以就只好自己动手啦：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defface</span> <span class="nv">epe-pipeline-delimiter-face</span>
</span></span><span class="line"><span class="cl">  <span class="o">&#39;</span><span class="p">((</span><span class="no">t</span> <span class="nb">:foreground</span> <span class="s">&#34;green&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Face for pipeline theme delimiter.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:group</span> <span class="ss">&#39;epe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defface</span> <span class="nv">epe-pipeline-user-face</span>
</span></span><span class="line"><span class="cl">  <span class="o">&#39;</span><span class="p">((</span><span class="no">t</span> <span class="nb">:foreground</span> <span class="s">&#34;red&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Face for user in pipeline theme.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:group</span> <span class="ss">&#39;epe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defface</span> <span class="nv">epe-pipeline-host-face</span>
</span></span><span class="line"><span class="cl">  <span class="o">&#39;</span><span class="p">((</span><span class="no">t</span> <span class="nb">:foreground</span> <span class="s">&#34;blue&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Face for host in pipeline theme.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:group</span> <span class="ss">&#39;epe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defface</span> <span class="nv">epe-pipeline-time-face</span>
</span></span><span class="line"><span class="cl">  <span class="o">&#39;</span><span class="p">((</span><span class="no">t</span> <span class="nb">:foreground</span> <span class="s">&#34;yellow&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Face for time in pipeline theme.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:group</span> <span class="ss">&#39;epe</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后就是按着原有的 Eshell 提示符来组装一个新的 Eshell 主题了，然后把这个主题定义成 pipeline (其实是我自己也没想出比较新颖的名字啦):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">epe-theme-pipeline</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;A eshell-prompt theme with full path, smiliar to oh-my-zsh theme.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-prompt-regexp</span> <span class="s">&#34;^[^#\nλ]* λ[#]* &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">epe-remote-p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">(</span><span class="nb">progn</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;┌─[&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nv">epe-remote-user</span><span class="p">)</span> <span class="ss">&#39;epe-pipeline-user-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;@&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nv">epe-remote-host</span><span class="p">)</span> <span class="ss">&#39;epe-pipeline-host-face</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nb">progn</span>
</span></span><span class="line"><span class="cl">       <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;┌─[&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nf">user-login-name</span><span class="p">)</span> <span class="ss">&#39;epe-pipeline-user-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;@&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nf">system-name</span><span class="p">)</span> <span class="ss">&#39;epe-pipeline-host-face</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">     <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;]──[&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nf">format-time-string</span> <span class="s">&#34;%H:%M&#34;</span> <span class="p">(</span><span class="nf">current-time</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			    <span class="ss">&#39;epe-pipeline-time-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;]──[&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nv">eshell/pwd</span><span class="p">))</span> <span class="ss">&#39;epe-dir-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">epe-colorize-with-face</span>  <span class="s">&#34;]\n&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;└─&gt;&#34;</span> <span class="ss">&#39;epe-pipeline-delimiter-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">when</span> <span class="nv">epe-show-python-info</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;epe-venv-p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">epe-venv-p</span><span class="p">)</span> <span class="nv">venv-current-name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nv">epe-colorize-with-face</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;(&#34;</span> <span class="nv">venv-current-name</span> <span class="s">&#34;) &#34;</span><span class="p">)</span> <span class="ss">&#39;epe-venv-face</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">epe-git-p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="p">(</span><span class="nf">concat</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34;:&#34;</span> <span class="ss">&#39;epe-dir-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nv">epe-colorize-with-face</span>
</span></span><span class="line"><span class="cl">       <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nv">epe-git-branch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	       <span class="p">(</span><span class="nv">epe-git-dirty</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	       <span class="p">(</span><span class="nv">epe-git-untracked</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	       <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">unpushed</span> <span class="p">(</span><span class="nv">epe-git-unpushed-number</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		 <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">unpushed</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		   <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;:&#34;</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">unpushed</span><span class="p">)))))</span>
</span></span><span class="line"><span class="cl">       <span class="ss">&#39;epe-git-face</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="s">&#34; λ&#34;</span> <span class="ss">&#39;epe-symbol-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nv">epe-colorize-with-face</span> <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">user-uid</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&#34;#&#34;</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			   <span class="ss">&#39;epe-sudo-symbol-face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34; &#34;</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结"><span class="section-num">4</span> 总结</h2>
<p>这样一个新的 Eshell 主题就完工了，然后我给 <code>eshell-extra-prompt</code> 发了一个<a href="https://github.com/kaihaosw/eshell-prompt-extras/pull/16">Pull Request</a>, 最终效果如下：</p>
<figure><a href="/ox-hugo/epe.png">
    <img loading="lazy" src="/ox-hugo/epe.png"/> </a>
</figure>

<p>Enjoy Emacs, Enjor Tweaking :)</p>
]]></content:encoded>
    </item>
    <item>
      <title>(翻译)从Helm到Ivy</title>
      <link>https://ramsayleung.github.io/zh/post/2017/from-helm-to-ivy/</link>
      <pubDate>Sun, 05 Mar 2017 00:00:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2017/from-helm-to-ivy/</guid>
      <description>An Translated Post about switch from helm to ivy</description>
      <content:encoded><![CDATA[<p>最近，我发现很多Emacs 用户对Ivy 很感兴趣；而且大部份用户都是已经了解过Helm 或者Ido的
当有人在Reddit 上面问 <a href="https://www.reddit.com/r/emacs/comments/51lqn9/helm_or_ivy/">选择Helm 还是Ido</a>这类问题的时候，我觉得我会给出我自己的选择：
<strong>Ivy</strong>,即使我是一个前Helm 的狂热用户
<img loading="lazy" src="http://www.feer-mcqueen.com/blog/wp-content/uploads/2015/11/miimalism-vs.-maximilasim-700x334.jpg" alt=""  />

<em>最大或者最小</em></p>
<p><strong>Helm 和Ivy 都是补全框架</strong>.这意味着它们都是Emacs生态系统中用来在用户输入后缩窄可供选择选项的范围的工具。
很自然而然想起的通用例子就是搜索文件。Helm 和Ivy 都可以帮助用户快速搜索文件</p>
<p>它们两者都是框架，这意味着它们都可以用在那些需要补全或者缩窄范围的复杂命令。</p>
<p>例如Helm 有一个命令(<strong>helm-google-suggest</strong>)可以模拟Goole 的搜索框，并在你输入时给出相应的google 提示</p>
<p>Ivy 和Helm 都有相同的目标，但是它们实现的方法却是迥然不同</p>
<p>现在我想站在用户的角度来比较一下这两个工具。我这里指的用户观点是我在不需要了解Helm 和Ivy 的内部工作原理的前提下对这两个工具进行比较。</p>
<p>其实，因为我对 <strong>elisp</strong>还谈不上精通，所以也没办法就两者实现细节来进行比较。但是这两个工具我都使用过，所以我可以从用户的角度，跟你分享我使用它们的不同感受。最后，我从Helm 切换到了Ivy</p>
<p>我想先谈Helm.当我使用Spacemacs 的时候，我学会了怎么使用Helm,以Helm 的方式思考, 如何自定义Helm,怎么把Helm 配置得称心如意。</p>
<p>我想我应该算得上是一个中级的Helm 用户吧。我有读过<a href="http://tuhdo.github.io/helm-intro.html">这篇文章</a> 还有<a href="http://tuhdo.github.io/helm-projectile.html">这篇文章</a> 以及<a href="https://github.com/emacs-helm/helm/wiki">Wiki</a> 此外，在长达一年的时间里，我每天都是使用Helm的</p>
<p><strong>Helm 是一个非常成熟的工具</strong>.根据git 的提交历史，Helm 的开发工作是在2009年左右开始的。
在写这篇文章的时候，Helm 官方的git 仓库有超过26000行elisp 代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://github.com/emacs-helm/helm.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> helm
</span></span><span class="line"><span class="cl">cat *.el <span class="p">|</span> wc -l
</span></span><span class="line"><span class="cl"><span class="c1"># =&gt; 26431</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这还是没有把在MELPA 上查询到跟Helm 有关的包有142个的情况考虑在内的呢。</p>
<p>你可以用Helm来完成任何事情它主要的强大之处在于你可以把Helm 和很多Emacs 的行为整合在一起。你可以以Helm 为中心构造接口，就像Spacemacs 做的那样。Helm 支持非常一致的接口，你可以通过Helm 来做任何事</p>
<p>你可以搜索文件，搜索缓冲区，搜索颜色，搜索项目，搜索你最近编辑过的文件，搜索系统进程, 搜索音乐，搜索网络资源，搜索补全，搜索代码片段，搜索正则表达式，搜索命令，文档
相关描述，手册&hellip;.</p>
<p>你可以用Helm-projectile(一个Helm 对projectile 非常好的包装)来管理你的项目。你可以用<a href="https://www.gitignore.io/">gitignore.io</a>来生成gitignore文件，你可以用Helm-bibtex来管理你的参考书目，你可以浏览你的火狐书签</p>
<p>你可以用Helm 来完成任何事。</p>
<p>基于 <strong>tuhdo</strong> 对我在<a href="https://www.reddit.com/r/emacs/comments/52lnad/from_helm_to_ivy_a_user_perspective/d7lypeu/">Reddit</a> 上面问题的回复，我想指出的一个特性就是Helm 是不使用 <em>minibuffer</em>,但是Ivy 是使用的。</p>
<p>所以它可以被配置成总是在当前打开的窗口展示。对于那些大屏幕显示器的用户而言，这个特性真的非常有用，因为你的目光不用在 <em>minibuffer</em> 来回切换：</p>
<figure>
    <img loading="lazy" src="http://i.imgur.com/g1Oz9JY.png"
         alt="Figure 1: 补全结果总是显示在同一个窗口"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>补全结果总是显示在同一个窗口</p>
        </figcaption>
</figure>

<p>最终的比较结果是Helm 是非常便利的工具，相信会有数量非常多的Spacemacs 用户告诉你同样的看法。</p>
<p>而Helm 主要的缺点就是它的代码量太大了。我想虽然Helm 的代码量很大，但是它的开发者利用 <strong>elisp</strong> 成功把它打造成了一个相当快的工具了</p>
<p>而且有些时候，Helm 似乎把简单的问题复杂化了;它配置起来也感觉相当臃肿；有时它也会有一些很奇怪的表现，然后导致卡顿，或者让Emacs 过载，即使你做的只是很简单的查询。</p>
<p>或许那些Helm 的高手用户看到这里，会觉得如果我也是个 <strong>elisp</strong> 高手，就不会出现上述问题了。虽然我已经使用Helm 超过一年了，我还是没有找到方法让可以Helm更加稳定。我觉得Helm 在用自己做例子来讲述了什么是化简为繁吧</p>
<p>你可以用Helm 来做任何事；但事实上你并不需要。你可以这样做并不意味着你应该这样做。</p>
<p>在使用Helm 一年以后，我可以告诉你我只是使用了Helm 三分之一或者更小的功能。有些功能我觉得真的很棒，昨天在读了<a href="http://tuhdo.github.io/helm-intro.html">这篇文章</a> 之后，我又发现了一些新的东西。大部分时间，我都是使用简单的命令来切换缓冲区，或者列举文件</p>
<blockquote>
<p>Helm 只是一个用来补全的包，就好像Ido或者Ivy.它可能很容易使用，一旦有人经历过配置它的困难，就会发现它很难做到让你随心所欲。</p>
<p>有些人觉得只要可以让他们使用好的工具，即使他们完全不了解这些工具也无所谓。</p>
<p>但是我就做不到</p>
<p>&ndash;abo-abo,Ivy 的开发者，回答<a href="https://github.com/abo-abo/swiper/issues/3">&ldquo;为什么不选择Helm&rdquo;</a> 这个问题</p>
</blockquote>
<p><strong>Ivy 为实现最小化，简单化，可定制化，可发现化而努力</strong>.这四个形容词告诉我们很多Helm
和Ivy 这两个工具间不同的设计理念。阅读<a href="http://oremacs.com/swiper/">Ivy介绍</a> 以便更好了解Ivy的理念。</p>
<p>在写这篇文章的时候，Ivy 只有大概3400行代码，为Ivy 所打造的生态系统：即Swipter 和
Counsel 也只有7500 行代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://github.com/abo-abo/swiper.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> swiper
</span></span><span class="line"><span class="cl"><span class="c1">## Only ivy ?</span>
</span></span><span class="line"><span class="cl">cat ivy.el <span class="p">|</span> wc -l
</span></span><span class="line"><span class="cl"><span class="c1"># =&gt; 3442</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## count lines of code into the whole swiper ecosystem</span>
</span></span><span class="line"><span class="cl">cat *.el <span class="p">|</span> wc -l
</span></span><span class="line"><span class="cl"><span class="c1"># =&gt; 7526</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ivy 真的是很容易上手，下面就是我的全部配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">ivy</span> <span class="nb">:ensure</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:diminish</span> <span class="p">(</span><span class="nv">ivy-mode</span> <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:bind</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">:map</span> <span class="nv">ivy-mode-map</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="s">&#34;C-&#39;&#34;</span> <span class="o">.</span> <span class="nv">ivy-avy</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">ivy-mode</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">ivy-use-virtual-buffers</span> <span class="no">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; number of result lines to display</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">ivy-height</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; does not count candidates</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">ivy-count-format</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; no regexp by default</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">ivy-initial-inputs-alist</span> <span class="no">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; configure regexp engine.</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">ivy-re-builders-alist</span>
</span></span><span class="line"><span class="cl">	<span class="c1">;; allow input not in order</span>
</span></span><span class="line"><span class="cl">	<span class="o">&#39;</span><span class="p">((</span><span class="no">t</span>   <span class="o">.</span> <span class="nv">ivy--regex-ignore-order</span><span class="p">))))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ivy 是很低调的；它不想让你把一切都整合到Ivy去。它仅仅是提供你必需的补全。你不能像Helm 那样用Ivy 来做任何事；那为什么我还要切换到Ivy 去呢？</p>
<p>虽然Ivy 已经最小化，但是我依然可以用Ivy 来代替我绝大部分日常使用的Helm命令。</p>
<p>因为Ivy是如此简洁， <em>abo-abo</em> 在它上开发了一个叫 <strong>Counsel</strong> 的包； <strong>Counsel</strong> 可以为你提供非常非常多像你在Helm使用的命令</p>
<p>你可以切换缓冲区，搜索文件，在项目级别进行搜索和替换，与Projectile 整合，搜索你最近
编辑过的文件，搜索Emacs 命令，搜索文档，搜索按键绑定，浏览 kill-ring</p>
<p>让我向你介绍我是怎样用Ivy 代替Helm 的。下面是我对那些我需要使用Ivy 来代替Helm的最常用命令的总结。</p>
<p>这些基本是我一直以来最常用的方法。我每分钟会使用三次的 <strong>ivy-switch-buffer</strong> ,我一天会使用五次的 <strong>helm-swoop</strong>, <strong>swiper</strong> 跟 <strong>helm-swoop</strong> 不分伯仲；</p>
<p>对于那些大文件， <strong>Counsel</strong> 有 <strong>counsel-grep-or-swiper</strong>.</p>
<p>我已经用一些非常非常大的标记语言的文件(一百万行左右)来测试过了，一点问题也没有。</p>
<table>
<thead>
<tr>
<th>Helm</th>
<th>Ivy</th>
<th>What ?</th>
</tr>
</thead>
<tbody>
<tr>
<td>helm-mini</td>
<td>ivy-switch-buffer</td>
<td>search for currently opened buffers</td>
</tr>
<tr>
<td>helm-recentf</td>
<td>counsel-recentf</td>
<td>search for recently edited files</td>
</tr>
<tr>
<td>helm-find-files</td>
<td>counsel-find-files</td>
<td>search files starting from ./</td>
</tr>
<tr>
<td>helm-ag</td>
<td>counsel-ag</td>
<td>search regexp occurence in current project</td>
</tr>
<tr>
<td>helm-grep-do-git-grep</td>
<td>counsel-git-grep</td>
<td>search regexp in current project</td>
</tr>
<tr>
<td>helm-swoop</td>
<td>swiper</td>
<td>search string interactively in current buffer</td>
</tr>
<tr>
<td>helm-show-kill-ring</td>
<td>counsel-yank-pop</td>
<td>search copy-paste history</td>
</tr>
<tr>
<td>helm-projectile</td>
<td>counsel-projectile</td>
<td>search project and file in it</td>
</tr>
<tr>
<td>helm-ls-git-ls</td>
<td>counsel-git</td>
<td>search file in current git project</td>
</tr>
<tr>
<td>helm-themes</td>
<td>counsel-load-theme</td>
<td>switch themes</td>
</tr>
<tr>
<td>helm-descbinds</td>
<td>counsel-descbinds</td>
<td>describe keybindings and associated functions</td>
</tr>
<tr>
<td>helm-M-x</td>
<td>counsel-M-x</td>
<td>enhanced M-x command</td>
</tr>
</tbody>
</table>
<p>我觉得你可以看到Ivy 基本的命令对比Helm 的命令也是毫不逊色的。它们可以代替你日常使用的每一条Helm命令。我不是说你可以像Helm 那样用Ivy 来做任何事，但是它已经足够好用了，正如我说的那样，你也不需要任何事都使用Helm 来完成。</p>
<p>说到补全理念这个话题上，Helm 和Ivy 之间的差异并没有那么大。作为一个用户，我可以告诉你的是：Ivy 会让你感觉到更少的臃肿，更加的直观，更加地容易理解。每一次的补全都是可以预见的。</p>
<p>最后，这真的跟个人的品味有关。对于我自己来说，&ldquo;Ivy 还是Helm&rdquo; 这样的争论跟&quot;Emacs 还是Spacemacs&quot; &ldquo;Emacs 还是Ide&rdquo; &ldquo;C 还是Java&rdquo; &ldquo;简洁还是全能&rdquo; &ldquo;Thelonious 还是 Duke&rdquo;(译者注，两者都是爵士乐作曲家),&ldquo;Van Der Rohe 还是 Gaudi.&quot;(译者注：前者是德国美国
的建筑风格，后者是西班牙加泰罗尼亚的建筑风格)这样的争论是非常相似的。</p>
<p>你选择Helm呢，你会得到一个巨型的包，一系列你不会用到的特性，一堆你可能只是偶尔用一下的功能，一些你会一个小时使用50次的特性。如果你选择Ivy,你会得到一个只拥有那些让你顺心的必要特性的精简的包，你可以很容易地通过 <strong>Counsel</strong> 或者简单的函数对它进行扩展</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">ivy-read</span> <span class="s">&#34;Pick:&#34;</span> <span class="p">(</span><span class="nf">mapcar</span> <span class="nf">#&#39;number-to-string</span> <span class="p">(</span><span class="nv">number-sequence</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你想要通过Helm 来扩展：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">helm</span>
</span></span><span class="line"><span class="cl"> <span class="nb">:sources</span>
</span></span><span class="line"><span class="cl"> <span class="p">(</span><span class="nv">helm-build-sync-source</span> <span class="s">&#34;one-to-ten&#34;</span>
</span></span><span class="line"><span class="cl">			 <span class="nb">:candidates</span>
</span></span><span class="line"><span class="cl">			 <span class="p">(</span><span class="nf">mapcar</span> <span class="nf">#&#39;number-to-string</span> <span class="p">(</span><span class="nv">number-sequence</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			 <span class="nb">:fuzzy-match</span> <span class="no">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="nb">:buffer</span>
</span></span><span class="line"><span class="cl"> <span class="s">&#34;*helm one-to-ten*&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者简单的列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">helm-comp-read</span> <span class="s">&#34;Pick:&#34;</span> <span class="p">(</span><span class="nf">mapcar</span> <span class="nf">#&#39;number-to-string</span> <span class="p">(</span><span class="nv">number-sequence</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Helm 为用户作了非常多的决定，Ivy 让用户按需求进行定制；Helm 通过耗费非常多的内存来变得快速，Ivy 通过保持简洁来实现快速；Helm 很成熟，Ivy 很青涩；Helm 为Emacs 提供一致性，Ivy 为Emacs 提供简洁性和可预见性；Helm 需要你进行一定的配置，Ivy 开箱即用</p>
<p>我自己是稍偏向Ivy 的，因为我正在使用它；
它更符合我的口味。但是作为一个用户，Helm和Ivy并没有那么大的差别。它们都是非常优秀的包，只是以不用的方式去实现相同的目标</p>
<p>原文地址 <a href="https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/">https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/</a></p>
<p>在下翻译水平有限，如有错误，还请指出</p>
]]></content:encoded>
    </item>
    <item>
      <title>(翻译)An Introduction to Magit</title>
      <link>https://ramsayleung.github.io/zh/post/2017/magit/</link>
      <pubDate>Fri, 03 Mar 2017 00:00:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2017/magit/</guid>
      <description>An introduction to Magit</description>
      <content:encoded><![CDATA[<p>如果你足够幸运(或者不幸运，取决于你怎么看待了)可以使用 <em>git</em> 作为你工作流的一部分。</p>
<p>你可能已经 <strong>邂逅</strong> 过 <em>magit</em> 这个Emacs 的git接口了。 <em>magit</em> 是Emacs 上的非常优秀的git 接口，它假定你是了解你正在对 <em>magit</em> 或者 <em>git</em> 做的种种操作的 <strong>注意</strong> ：该文章是针对 magit 1.x 的，对 magit 2.x 并不适用 Magit 有非常完整的文档，包含了Magit 的各种操作，但是和大多数的文档一样，Magit 的文档并没有介绍如何将Magit 和你的工作流结合；</p>
<p>Magit 假定你是熟悉Magit 并且了解如何合理地使用Magit(但大多数情况并不是这样).</p>
<p>Magit 现在还是处于活跃的开发中。在2013年12月，增加了很多很多新的很有用特性的一次 release, 让Magit 变得比以前更强大了，所以本教程是基于比较新的Magit 版本的，并且 假定你也已经安装了新的版本</p>
<p>如果想安装处于 <code>master</code> 分支的Magit,我建议你使用 <code>Melpa</code> 来安装；此外你也可以选择直接拉取<a href="https://github.com/magit/magit">magit github</a> 仓库的最新版本，然后按照README 上面的指导来构建 <code>magit</code></p>
<p>这是我Magit 教程的第一部分。这部分会介绍状态窗口(status window); 已暂存和未暂存的项目 (staging and unstagin item);已经提交的更改 (committing changes) 和查看历史提交 (history view)</p>
<h2 id="getting-started"><span class="section-num">1</span> Getting Started</h2>
<p>首先：Magit 并没有隐藏git 的复杂性，所以，如果你想高效地使用Magit ,你最好清楚了解git 究竟做了哪些工作。</p>
<p>事实上，我更原意把Magit 当作一个取代了git 枯燥的纯命令行操作的工具，它也表现得出乎意料地好。</p>
<p>你可以通过 <code>M-x magit-status</code> 来使用Magit,该命令会打开一个窗口(如果你的缓冲区 所在的目录不是一个git 项目，Magit 会提示你进入一个git项目的目录),然后展示Magit 当前的状态。</p>
<p>你是通过 <code>magit-status</code> 这个接口来使用Magit 的。此外，如果你是使用 Emacs VC的，你需要知道的是，Magit是没有集成到Emacs VC(Version Control)的 抽象层。</p>
<p>虽然你没法在VC 使用Magit,不过你还是可以在大多数版本控制工具使用Magit 的，Magit 为这些版本控制工具都提供了统一的接口；你如果想调用Magit,你只需要 <code>M-x magit-status</code></p>
<h2 id="the-magit-status"><span class="section-num">2</span> The Magit Status</h2>
<figure>
    <img loading="lazy" src="https://www.masteringemacs.org/static/uploads/Screenshot-from-2013-12-06-114511.png"/> 
</figure>

<p>你首先会注意到关于Magit的事情应该就是当你打开Magit 的状态窗口时，Magit 的状态窗口是可以与你的Emacs 窗口配置配合工作的，你也可以像在其他Emacs 窗口那样，通过按下 <code>q</code>
来关闭窗口。</p>
<p>几乎你在Magit 执行的所有操作都是通过在底部打开一个 <code>command console</code> 窗口，然后按下对应的单字符指令执行；你也可以重新定义你自己的指令。</p>
<p>这种交互的方式真的非常好用，可能正是这么强大的特性让Magit变得如此优秀吧。</p>
<p>我个人真的非常喜欢这种交互的方式，我甚至把这部分特性的代码复制到了我自己的Emacs项目上，因为这真的真的非常好用。</p>
<p>Magit 之前的稳定版本在帮助用户更好使用Magit这方面做得略有不足，所以在最新的版本有了相应的改进，你可以通过按下 ~?&lt;/kbd&gt; 来显示一系列带注解说明的操作。我觉得在最开始的时候，Magit 真的很难用，因为我总是在「茫茫」的菜单选项中迷失，好不容易才能找到我想要的操作。</p>
<p>即使是现在，也并不是所有的操作都有注解说明了；有一些命令
(对于我的工作流来说很重要的命令)依然是没有说明的，特别是用来重新定位的 <code>E</code>.</p>
<h2 id="staging-and-unstaging-items"><span class="section-num">3</span> Staging and Unstaging Items</h2>
<p>把你的文件放到git下面是你经常需要完成工作之一，Magit 有一系列的按键绑定和工具可以帮助你更好地完成工作。</p>
<p>Magit 操作不仅可以暂存文件，还可以暂存在 <strong>diff</strong> 中选定 的代码块。</p>
<p>Magit&quot;杀手级&quot;特性之一就是它使用不同的等级来显示相关的信息。Magit 可以让你通过 <code>tab</code> 展开或者折叠已经暂存或者未暂存文件。</p>
<p>如果你想更加细颗粒度地暂存或者未暂存文件，你可以使用 <strong>M-1</strong> 到 <strong>M-4</strong> 来操作所有的文件；此外，也可以使用 <strong>1</strong> 到 <strong>4</strong>
操作选定的文件</p>
<figure>
    <img loading="lazy" src="https://www.masteringemacs.org/static/uploads/diff-hunk-refined-level-4.png"/> 
</figure>

<ol>
<li>
<p>等级1会把所有的东西隐藏到一个分类里面(即已暂存的文件);</p>
</li>
<li>
<p>等级 2在一个分类里面只是显示文件名 (这是默认的等级);</p>
</li>
<li>
<p>等级3会显示git代码块的头部；等级4 会显示所有做出了修改的代码块。</p>
<p>我使用最多的是等级2和等级4, 如果你使用按键 <code>TAB</code>,Magit会完成你想要的等级操作的。你拥有一系列可以让你的</p>
</li>
</ol>
<p>生活变得更加美好的按键绑定，例如： <code>n</code> 和 <code>p</code> 可以在你前一个单元和后一个单元(通常以代码块为单元)
之间移动；<code>M-n</code> 和 <code>M-p</code> 可以在相邻单元之间移动，例如在等级4中的每个文件间移动。</p>
<p>你也可以使用 <code>+</code> 或者 <code>-</code> 放大或者缩小每段代码，使用 <code>0</code> 可以恢复默认设置。此外你也可以按下 <code>H</code> 给代码块 添加额外的代码高亮。</p>
<p>最后，你按下回车 <code>RET</code> 可以打开你修改的文件，代码块或者文件都适用该操作。</p>
<hr>
<p>你可以通过按下 <code>s</code> 或者 <code>u</code> 来暂存或者撤销暂存文件(或者代码块),此外，奉送一个很有用的小提示：如果你选定某部分的代码，然后按下暂存(撤销暂存)按键，Magit 会自动暂存(撤销)你选定的那部分代码。</p>
<p>当你发现 <em>diff</em> 选定的代码块不符合你的要求的时候，你会发现这种细颗粒度的操作真的非常有用</p>
<hr>
<p>有时候你对某些修改并不在意，你也不关心这部分修改是否已经提交；你可以像上面的暂存(撤销暂存)操作一样，通过按下按键 <code>K</code> 来忽略选定的代码块和文件，并且从你的电脑删除未提交到暂存区(untracked)的文件；</p>
<p>这个命令可以比暂存(撤销暂存)命令完成更多的操作，例如，删除已保存的文件或目录(stash)</p>
<h2 id="committing-changes"><span class="section-num">4</span> Committing Changes</h2>
<p>如果你想打开提交菜单，只需按下 <code>c</code>,然后你就会看到琳罗满目的选项，不过大部份选项 你都是用不上的了。你真正有用的操作，不仅可以让你提交已暂存的修改，还可以完成更多的任务：</p>
<ul>
<li>你可以扩展(extend <code>e</code>) <em>HEAD</em> 所指向的提交</li>
<li>你可以修改(amend <code>a</code>) 有关的提交信息</li>
<li>如果你不喜欢现在的提交信息，你可以重写(reword <code>r</code>)提交信息</li>
<li>你同时也可以修整(fixup <code>f</code>)和压缩(squash <code>s</code>)当前这次的提交。如果你之前用 <code>.</code> 标记了一次提交，那么今次使用的就是被标记的那次提交。</li>
</ul>
<p>扩展一次提交其实就是在当前提交上附加修改，所以，如果你忘记了提交本属于此次提交的东西你可以使用 <em>扩展</em> 选项。</p>
<p>如果你想修改当前的提交信息，那就使用 <em>修改</em> 选项吧</p>
<p>重写可以重写你的提交信息但是无需提交你已暂存的修改；如果你不小心按错了选项，想重写你的提交信息，<em>重写</em> 选项就是你最好的选择</p>
<p>如果你想在最新一次提交下创建一个 <code>fixup</code> 或者 <code>squash</code> 提交的话，使用修整或压缩命令 可以重整或者 <code>--(自动压缩)autosquash</code> 最新一次提交。</p>
<p>如果你不会去重写你的git历史或者你未使用过重整，你可能觉得这两个命令不是很有用</p>
<h2 id="logging"><span class="section-num">5</span> Logging</h2>
<figure>
    <img loading="lazy" src="https://www.masteringemacs.org/static/uploads/Screenshot-from-2013-12-06-142317.png"/> 
</figure>

<p>我觉得Magit非常强大的特性之一就是它有不计其数的选项可以用来对你的git 历史进行 过滤，排序，查找。</p>
<p>Magit 不仅可以展示你的git信息，还可以让你执行交互操作。如果你想打开日志的菜单，你只需按下 <code>l</code>.</p>
<p>你应该知道的第一个有用的按键就是 <code>l l</code>, 这个 按键会为你展示缩略的日志信息：你会看到单行的提交信息, 作者的名字, 修改提交距今的时间, 树状结构的git 日志, 各种的标签信息，例如 <code>HEAD</code> 指针的位置或者分支标记的位置</p>
<p>如果你不小心玩坏了git 的提交信息，命令 <code>git reflog</code> 会是你的救星；此外，对于magit 的引用日志(reflog)机制(<code>l h</code>)，它也有很友好稳定的UI界面支持。</p>
<hr>
<p>引用日志和普通的日志都有非常丰富的按键绑定。在日志里，你对单个的提交可以进行非常多的操作：</p>
<ul>
<li><code>.</code>: 为此次提交作标记以便进行后续的操作例如提交修整 (<code>c f</code>)或者提交压缩 (<code>c s</code>)</li>
<li><code>x</code>: 重置你的 <code>HEAD</code> 指针到选定的提交</li>
<li><code>v</code>: 撤销提交</li>
<li><code>d</code>: 将你的工作区与选定的提交进行比较</li>
<li><code>a</code>: 将选定的提交作用在你的工作区</li>
<li><code>A</code>: 选择位于你工作区顶部的提交</li>
<li><code>E</code>: 以交互的方式重置你的 <code>HEAD</code> 指针到选定的工作区。如果你想重写历史，该命令会非常有用</li>
<li><code>C-w</code>: 复制你此次提交的hash值</li>
<li><code>SPC</code>: 展示完整的提交历史</li>
</ul>
<p>需要注意的是：即使你关闭了日志的窗口，标记的命令还是会继续作用的；标记是非常有用的工具，但是你很容易忘记你是否曾经作过标记。如果你在magit 使用 <code>M-n</code> 或者 <code>N-p</code> 向上或者向下浏览日志，
maigt 会自动为你在另外一个窗口显示提交信息</p>
<h2 id="conclusion"><span class="section-num">6</span> Conclusion</h2>
<p>对于有经验的Git 用户来说，Magit 是一个非常好的工具；此外，如果你是Git 的新手， Magit可以帮助你了解Git 是怎么工作的，但是它永远不会教你使用Git.</p>
<p>在我看来，阻碍 你使用Magit 最大的障碍就是Magit缺乏对选项的描述说明；即使Magit 包含了成千上万 Git的选项，参数和操作，但是它并没有教你如何找到并使用这些命令。</p>
<p>我发现Git 的命令行真的无可替代(不是因为我喜欢git 的命令行我才这么说，事实是它真的很棒)因为我 想要完成的操作真的隐藏得很深，没有那么容易在Magit找到。</p>
<p>不过最新版本的改进真的很好，你可以通过按下 <code>?</code> 查看一系列带有注解说明的命令(但不是全部命令，不过这也已经是一个很大的改进了).</p>
<p>如果你曾被Magit 的学习曲线所吓倒，抑或者你已经尝试Magit, 却无奈放弃；我建议你再试一次。我打算写更多关于Magit 的博文</p>
<hr>
<p>原文地址 <a href="https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git">https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git</a>
在下翻译水平有限，如有错误，还请指出</p>
]]></content:encoded>
    </item>
    <item>
      <title>Shell神器fasd与Eshell的不期而遇</title>
      <link>https://ramsayleung.github.io/zh/post/2017/fasd-meet-eshell/</link>
      <pubDate>Thu, 02 Mar 2017 00:00:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2017/fasd-meet-eshell/</guid>
      <description>An introduction about tweaking eshell with fasd</description>
      <content:encoded><![CDATA[<blockquote>
<p>fasd - quick access to files and directory</p>
</blockquote>
<p>之前一位 Windows 用户看到我在 Shell 下面的操作，他很奇怪，觉得明明已经有图形化界面，为什么还要用这种命令行呢，直接用鼠标点击不就很好了么。</p>
<p>我觉得很难直接跟他解释，因为他没有用过Linux/Unix,完全不熟悉命令行，不知道其强大之处，其高效率是图形化界面完全无法比拟的(当然，命令行的学习成本和学习曲线肯定比图型化界面高), So I live in terminal.</p>
<p>而今天我要介绍的神器 fasd 就是可以让命令行操作变得更加高效</p>
<h2 id="fasd"><span class="section-num">1</span> Fasd</h2>
<p>在 Shell 下面有非常多的命令操作是与文件和目录相关的，如果你要进入到另外一个目 录你可以使用相对或者绝对路径来访问该目录，但是如果这是一个与当前目录不相关的目 录你就只能通过绝对路径来访问。</p>
<p>以我自己的目录为例，当前目录是 <strong><em>home/samray</em>.emacs.d/elisp/</strong> ,我希望访问 <strong>Document</strong> 目录下一个的子目录 <strong>Python</strong>, 我可以通过下面的命令来访问：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> ~/Document/Programming/Python
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> /home/samray/Document/Programming/Python
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是我需要的命令，虽然可以通过 <strong>tab</strong> 进行目录名的补全，但是我还是觉得要输入的东西太多了(正如 Larry Wall 所说，懒惰是程序员的美德). 然后，我发现了 <a href="https://github.com/clvv/fasd">Fasd </a>这个神器。它可以让我只输入 <strong>Python</strong> 就进入到我想访问的 <strong>Python</strong> 目录，</p>
<p>神奇吧！:)</p>
<hr>
<p>Fasd以访问的频繁程度和最近是否有访问对文件和目录分配优先级，然后通过判断已访问的文件以及其优先级来切换目录或者打开文件，所以如果你之前已经访问过某个目录.</p>
<p>那么 你很容易就可以切换到那个目录</p>
<h3 id="常用选项"><span class="section-num">1.1</span> 常用选项</h3>
<ul>
<li>
<p><strong>-a(any)</strong>: 匹配文件和目录</p>
</li>
<li>
<p><strong>-i(interactive)</strong>: 以交互的方式选择文件或者目录</p>
</li>
<li>
<p><strong>-s(show/search)</strong>: 按照优先级展示文件或者目录</p>
</li>
<li>
<p><strong>-e &lt;cmd&gt;</strong>:对匹配的文件调用命令&lt;cmd&gt;</p>
</li>
<li>
<p><strong>-d</strong>:只匹配目录</p>
</li>
<li>
<p><strong>-f</strong>:只匹配文件
Fasd 文档还建议你为 fasd的命令选项设置别名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">a</span><span class="o">=</span><span class="s1">&#39;fasd -a&#39;</span>        <span class="c1"># any</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">s</span><span class="o">=</span><span class="s1">&#39;fasd -si&#39;</span>       <span class="c1"># show / search / select</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">d</span><span class="o">=</span><span class="s1">&#39;fasd -d&#39;</span>        <span class="c1"># directory</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">f</span><span class="o">=</span><span class="s1">&#39;fasd -f&#39;</span>        <span class="c1"># file</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">sd</span><span class="o">=</span><span class="s1">&#39;fasd -sid&#39;</span>     <span class="c1"># interactive directory selection</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">sf</span><span class="o">=</span><span class="s1">&#39;fasd -sif&#39;</span>     <span class="c1"># interactive file selection</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">z</span><span class="o">=</span><span class="s1">&#39;fasd_cd -d&#39;</span>     <span class="c1"># cd, same functionality as j in autojump</span>
</span></span><span class="line"><span class="cl"><span class="nb">alias</span> <span class="nv">zz</span><span class="o">=</span><span class="s1">&#39;fasd_cd -d -i&#39;</span> <span class="c1"># cd with interactive selection</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样你就可以通过 <strong>z some-dir</strong> 直接进入到某个目录或者 <strong>zz some-dir</strong> 选择进入有多个匹配的特定目录。</p>
<p>Fasd 还会判断应该显示所有的匹配选项或者是直接选择最佳匹配. 例如你也可以将fasd配合 <em>subshell</em> 使用，例如打开 <strong>foo</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim <span class="sb">`</span>f foo<span class="sb">`</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>又或者打开  <strong>/etc/rc.conf</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim <span class="sb">`</span>f rc conf<span class="sb">`</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="例子"><span class="section-num">1.2</span> 例子</h3>
<p>你可以将fasd 配合正则表达式使用，例如列举以 <em>py</em> 结尾的最近访问的文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">f py$
</span></span></code></pre></td></tr></table>
</div>
</div><p>又或者使用Emacs 打开最近频繁访问的文件 <em>bar</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">f -e emacs bar
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="fasd-plus-eshell"><span class="section-num">2</span> Fasd +Eshell</h2>
<p>fasd 真的可以大幅度提高效率，但是我有点不太满意的是，我是个 Emacser, 我的操作基本是在 Emacs 里完成的，而我在 Emacs里面使用的 shell 是 Eshell,Eshell 似乎不能与 fasd 无缝结合，似乎可以折腾一下。</p>
<hr>
<p><strong>z</strong> 和 <strong>zz</strong> 命令是无法在Eshell 里面运行，因为 <strong>z</strong> 是 <strong>fasd_cd</strong> 的别名，而<strong>fasd_cd</strong> 是一个shell script 函数，Eshell无法运行该函数，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">fasd_cd <span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -le <span class="m">1</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">then</span>
</span></span><span class="line"><span class="cl">	fasd <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">	<span class="nb">local</span> <span class="nv">_fasd_ret</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>fasd -e <span class="s1">&#39;printf %s&#39;</span> <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span><span class="k">)</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$_fasd_ret</span><span class="s2">&#34;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="o">[</span> -d <span class="s2">&#34;</span><span class="nv">$_fasd_ret</span><span class="s2">&#34;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="s2">&#34;</span><span class="nv">$_fasd_ret</span><span class="s2">&#34;</span> <span class="o">||</span> <span class="nb">printf</span> %s<span class="se">\n</span> <span class="s2">&#34;</span><span class="nv">$_fasd_ret</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Eshell无法运行该函数，因为Eshell文档的匮乏，我也不知道如何编写跟上面代码等价的 &ldquo;Eshell script&rdquo;,所以就用 elisp 写一段同样功能的函数好了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">samray/eshell-fasd-z</span> <span class="p">(</span><span class="kp">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Use fasd to change directory more effectively by passing ARGS.&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">args</span> <span class="p">(</span><span class="nv">eshell-flatten-list</span> <span class="nv">args</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">fasd</span> <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;fasd &#34;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">args</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nv">fasd-result</span> <span class="p">(</span><span class="nv">shell-command-to-string</span> <span class="nv">fasd</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">(</span><span class="nv">path</span> <span class="p">(</span><span class="nv">replace-regexp-in-string</span> <span class="s">&#34;\n$&#34;</span> <span class="s">&#34;&#34;</span> <span class="nv">fasd-result</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	 <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">eshell/cd</span> <span class="nv">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">eshell/echo</span> <span class="nv">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数功能很快就写好了，实现了 <strong>z</strong> 的功能，但是原来的代码一直不能正常运行，折腾了一个多小时都没解决，输出什么都正常，最后 debug 发现是因为显示的路径后面多了一个换行符即 <strong>/home/samray</strong> 变成了 <strong>/home/samray\n</strong>,而输出换行符又不会显示，真
的坑。</p>
<p>最后为命令赋予别名就可以像在 <strong>zsh</strong> 下那样工作了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> z <span class="s1">&#39;samray/shell-fasd-z $1&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p>更多的用法就要查阅官方文档了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">man fasd
</span></span></code></pre></td></tr></table>
</div>
</div><p>Enjoy Emacs and Shell :)</p>
<p>参考：
<a href="https://github.com/clvv/fasd">https://github.com/clvv/fasd</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>(翻译)Mastering Eshell</title>
      <link>https://ramsayleung.github.io/zh/post/2017/master_eshell/</link>
      <pubDate>Tue, 28 Feb 2017 00:00:00 -0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2017/master_eshell/</guid>
      <description>An complete instroduction about Eshell</description>
      <content:encoded><![CDATA[<p>Emacs 支持若干种shell,但是就功能丰富度，以及与Emacs 的集成程度而言，
无一能望Eshell项背。</p>
<p>Eshell 是一个完全由Emacs Lisp 编写的shell,但是不要以为这样Eshell在功能上就会先天不足，它能代替绝大部分GNU核心功能集和Bourne shell家族的命令以及相关特性。</p>
<p>此外，通过用Emacs Lisp 重写了类似 <code>ls</code> 和 <code>cp</code> 等常用命令，使Eshell 可以成为真正的跨平台Shell.</p>
<p>但是，Eshell 有一个很大的不足，那就是Eshell 严重缺乏文档与之形成鲜明对比的是，Emacs 及其生态都拥有丰富的文档</p>
<h2 id="overview">Overview</h2>
<p>与Emacs 中的其他shell 不一样的是，Eshell 不是继承默认与的子进程进行交互的 <code>comint-mode</code>
因为Eshell 不是一个子进程，所以它就没有必要使用 <code>comint-mode</code> 了；不过似乎这是件
好事，因为这意味着 <code>comint-mode</code> 的例程和钩子是不会作用于Eshell 的。</p>
<p>此外，几乎所有 <code>comint-mode</code> 的常用命令，都在Eshell 中重新实现了，并且使用相同的按键绑定.</p>
<p>当然，也有为数不多的按键绑定没有迁移到Eshell,例如在Eshll 中搜索历史命令的=comint-history-isearch-backward-regexp= 是绑定到了 <code>M-r</code>,
而原来shell中相同功能的命令的按键就是 <code>C-r</code> Eshell 可以在所有的平台都正常工作.</p>
<p>其实和Eshell 真正进行交互的是一个通用的中间件(即 Emacs Lisp/C 的一个库),而该中间件又会跟你的操作系统进行通信，处理例如复制文件 等相关操作。</p>
<p>此外，这个中间件甚至支持在Eshell 中使用 <code>Tramp</code> 的特性, 由于Emacs 是血统纯正的Unix 产物，Eshell 是可以重现例如bash 等传统Unix shell 以及 其他GNU 工具链的同样功能的。</p>
<p>此外，如果你使用的是Windows,你应该感到庆幸，因为你再也不用折腾 <code>cygwin</code> ,也不需要为跨平台移植Emacs 而担忧依赖问题。</p>
<p>事实上，对比=cygwin= 的bash,在很多方面，Eshell 对Windows 的支持是做得更好滴。</p>
<p>例如，你不再需要 <code>/cygdrive/c</code> 来扩展相应的功能，因为Eshell 自身就支持Windows/MS-DOS 的路径
(所以 <code>cd D:</code> 或者 <code>D:</code> 同样都可以进入D 盘)</p>
<p>虽然Eshell 有很多好处，但是我还是要列出那些让人们很困惑的观点(或者说是误解):</p>
<ul>
<li>Eshell 不是一个终端模拟器，它不是跟shell 进行通信，事实上，它就是一个shell. 它做的所有工作，无论是在屏幕展示数据，还是获取目录里面的信息，它都是通过Emacs 实现的，然后Emacs会再跟你的操作系统进行通信</li>
<li>由于Eshell 跟其他进程通信的方式 (特别是异步通信),所以可能导致它的缓冲区(Buffers) 和其他中断操作出现问题</li>
<li>Eshell 无法直接支持交互命令 (按照Eshell 的说法，叫做“可视化命令”),例如top ,所以你一定要告诉Eshll应在单独的 <code>ansi-term</code> 实例运行此类命令</li>
<li>它不是 <code>bash</code> 或者 <code>zsh</code>,更不是 <code>csh</code>,所以不要像操作它们那样操作Eshell 即使Eshell 跟它们真的很像。因此，如果你想更加高效地使用Eshell,你最好把它当作一个不一样的shell</li>
</ul>
<h2 id="commands">Commands</h2>
<p>Eshell 是可以调用几乎所有的已加载的elisp 函数的；这种灵活性是其它shell 无法想象的也是它们力所不能及的。</p>
<p>事实上，这种在shell 里面跟elisp 函数结合的玩法理应得到更多人的支持和推崇，因为它真的很酷(当然也很有用).假如你想在Emacs 里面打开 <code>foobar.txt</code> ,你只需调用 <code>find-file foobar.txt</code>,Eshell 就会调用对应的 <code>(find-file &quot;foobar.txt&quot;)</code> ,并为你打开文件</p>
<h2 id="technical-details">Technical Details</h2>
<p>所有被Eshell 执行的命令都有一个执行的顺序，这是必需传递给Emacs 的有序列表，
因为这个列表决定了Eshell 的哪一部分应该处理该命令的。</p>
<p>如果该列表中没有找到可以执行你的操作的函数或者对应命令，你会被告知，你输入的是无效命令</p>
<p>假设 你想调用 <code>cp</code> 命令，调用顺序如下：</p>
<ol>
<li>完整的路径 (即 <code>/bin/cp</code>),在 <code>/bin</code> 目录下执行 <code>cp</code></li>
<li>寻找命令的前缀， <em>eshell-explict-command-char</em> (默认值是 &ldquo;=&rdquo;),如果有前缀的话,那么，在搜索路径寻找对应的命令</li>
<li>寻找shell 命令的别名 (<code>alias</code> 命令)</li>
<li>在搜索路径寻找 <code>cp</code> ,即 <code>$PATH</code> (或者 <code>eshell-path-env</code>) 定义的路径</li>
<li>寻找叫做 <code>cp</code> 的Lisp 函数 或者 叫 <code>eshell/cp</code> 的elisp 函数</li>
</ol>
<p>变量 <code>eshell-prefer-lisp-functions</code> 让内部的elisp 函数调用要先于外部调用，这意味着，当该变量值为 <code>t</code> 的时候，Eshell 会 <code>最先</code> 调用elisp 函数，而不是 =最后=才调用；</p>
<p>但是，当命令前缀(即 <em>eshll-explicit-command-char</em>)被指定，该变量会被忽略</p>
<h2 id="built-in-commands">Built-in Commands</h2>
<p>Eshell 有很多很好用的通过Emacs-Lisp 重写的命令，这些命令实现了绝大部分GNU 核心工具集
或者你所钟爱的shell 的特性，所以这些命令被称为&quot;Alias functions&quot;(别名函数).</p>
<p>但是Eshell 并不是全盘模拟其他Shell 的功能特性，如果你传递了一些参数，试图调用Eshell未实现的功能时，Eshell 会自动调用外部的对应的命令来实现你想要的功能 (当然前提是你已经安装该命令)
下面列出Eshell 已经重新实现的命令：
<code>cat</code> , <code>cp</code> , <code>ls</code> , <code>cd</code> , <code>export</code> , <code>dirs</code> , <code>du</code> , <code>echo</code> , <code>env</code> , <code>kill</code>
<code>ln</code> , <code>mkdir</code> , <code>mv</code> , <code>alias</code> , <code>popd</code> , <code>pushd</code> , <code>pwd</code> , <code>rm</code> , <code>rmdir</code>
<code>time</code> , <code>umask</code>.
Eshell 注重跟原有的GNU工具功能同步，所以你不用担心因Eshell 命令跟其他原生Shell 命令不一致而导致的问题</p>
<h2 id="command-interception">Command Interception</h2>
<p>Eshell 有一个很cool 的特性，那就是某些命令会被拦截并且传递给Emacs.</p>
<p>这种机制允许你调用一个命令例如 <code>man ls</code>,但是真正调用处理的是Emacs 内置的 <code>man</code>.</p>
<p>此外，对于之前提及的交互式命令而言，这种特性是很重要的，因为Eshell 是没有能力处理该命令的。</p>
<p>但真正展现该特性威力的还是那么复杂的命令，例如 <code>grep</code> <code>diff</code>,因为Emacs 本身就内置了更加强大的 <em>grep</em> 和 <em>diff</em> 工具。</p>
<p>这种特性真真实实展示了Eshell 对比其他shell 的强大之处</p>
<p>下列的命令都会被重定向到Emacs内置的功能去：
<code>agrep</code> , <code>diff</code> , <code>egrep</code> , <code>fgrep</code> , <code>glimpse</code> , <code>grep</code> , <code>info</code> , <code>jobs</code>
<code>locate</code> , <code>man</code> , <code>occur</code> , <code>su</code> , <code>sudo</code> , <code>whoami</code>
<code>su</code> <code>sudo</code> <code>whoami</code> 是与 <code>TRAMP</code> 相关的命令，所以如果你是连接到远程shell 的
这些命令也是可以正常工作的</p>
<h2 id="subshells">Subshells</h2>
<p>你可以使用 <code>$()</code> 来调用命令，并且把命令对应的输出当作接下来命令的参数，就好像你在bash 那样使用。</p>
<p>但是你要谨记的一样事情就是你是无法使用反引号 =``=来生成一个subshell的。</p>
<p>虽然你也可以使用像调用subshell 的语法来调用标准的elisp form: <code>(form ....)</code> 注意没有了 <code>$</code>,不过我并不推荐这种用法，因为很多情况，这种用法都是不行的</p>
<h2 id="useful-elisp-commands">Useful Elisp Commands</h2>
<p>Eshell 有一套可以让你每天的生活变得更美好的帮助函数(helper function), 此外你可以在Eshell调用几乎所有的elisp 函数，这就意味着，你拥有无上的能力来控制你的shell.</p>
<p>接下来，我会列举那些为Eshell 专门编写的命令和一些我觉得很有用的命令。</p>
<p>我也编写了挺多的elisp 函数了 (部分是专门写给Eshell,其他的就不是了)</p>
<h3 id="listify-args">listify ARGS</h3>
<p>将字符串参数解析成 elisp 列表符号，然后打印到屏幕。</p>
<p>该函数不仅可以解析 POSIX 类型的参数，也可以解析 MS-DOS/Windows 类型参数</p>
<h3 id="addpath-path">addpath PATH</h3>
<p>将参数 (必须是文件路径) 添加到环境变量 <code>$PATH</code>,如果没有参数被指定的话，那么将原有的变量值输出到屏幕</p>
<h3 id="unset-env-var">unset ENV-VAR</h3>
<p>移除已有的环境变量</p>
<h3 id="find-file-file">find-file FILE</h3>
<p>搜索文件FILE,然后在Emacs 中打开该文件。这个函数与 <code>TRAMP</code> 相关，所以也可以远程工作</p>
<h3 id="dired-directory">dired DIRECTORY</h3>
<p>在目录 <code>DIRECTORY</code> 下打开一个 dired 缓冲区</p>
<h3 id="calc-eval-expr">calc-eval EXPR</h3>
<p>在Emacs calculator 执行该表达式 <code>EXPR</code></p>
<h3 id="upcase-str-downcase-str">upcase STR /downcase STR</h3>
<p>字符串 STR 大小写转换</p>
<h3 id="vc-dir-directory">vc-dir DIRECTORY</h3>
<p>展示在版本控制下的目录 <code>DIRECTORY</code> 的状态，跟大多数版本控制工具的 <code>status</code> 命令相同</p>
<h3 id="ediff-files-file1-file2">ediff-files FILE1 FILE2</h3>
<p>使用Emacs 的比较引擎 (diff engine) ediff,对文件 <code>FILE1</code> <code>FILE2</code> 进行比较</p>
<h2 id="aliasing">Aliasing</h2>
<p>你可以像在其它主流的shell 那样给Eshell命令赋予别名，操作是一样滴，此外，你甚至可以混合使用elisp 函数和Eshell 命令。</p>
<p><code>alias</code> 命令的格式是 <code>alias alias-name definition</code> <code>definition</code> 必须由一对单引号 <code>''</code> 包围。</p>
<p>你也可以使用其它shell 的参数引用形式：</p>
<p>例如 <code>$1</code> 指第一个参数， <code>$2</code> 指第二个参数，依此类推，或者 <code>$=</code> 指所有的参数。
当参数没有在 <code>definition</code> 被引用，Eshell 会自动把参数添加到命令的末尾，并把参数忽略</p>
<p>如果想移除一条命令的别名，只需不对变量 <code>definition</code> 赋值 (即 <code>alias alias-name</code>) 别名就会被自动移除，如果想列出所有的别名，只需输入 <code>alias</code></p>
<p>Eshell 会把命令的别名及其定义写入到变量 <code>eshell-aliases-file</code> 然后统一被变量 <code>Eshell-directory-name</code> 管理；然后别名默认会被统一写入到 <code>~/.Eshell/alias</code>.</p>
<p>每次你更改一个命令别名，都会重复上面的流程, 另外一个很有用的特性就是别名自动修正 (<em>auto-correcting aliasing</em>),
如果你输入 一个无效的命令太多次 (变量 <code>eshll-bad-command-tolerance</code> 表示触发自动更正的最低 次数，默认值为3),Eshell会为你真正想执行的命令提供别名.</p>
<p>例如你想输入的是 <code>cp</code> 但是输入了太多次的 <code>co</code>,所以下次你输入 <code>co</code> 的时候，Eshell 就会自动执行 <code>cp</code>.</p>
<p>当然，如果你不喜欢这种特性的话，你可以把最低次数设得很大</p>
<h3 id="useful-examples">Useful Examples</h3>
<p>让我们把长长的 <code>find-file</code> 命令映射到更顺手的别名 <code>ff</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> ff <span class="s1">&#39;find-file $1&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>把 <code>dired</code> 映射到 <code>d</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">alias</span> d <span class="s1">&#39;dired $1&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="visual-commands">Visual Commands</h2>
<p>有一些对Eshell 而言是太复杂的命令，Eshell 是无法直接显示的，所以需要特殊的处理</p>
<p>例如 <code>top</code> ,是无法与一些哑终端(dumb terminal)一起正常工作的。</p>
<p>为了使这些命令正常工作，Eshell 会运行一个终端模拟器 <code>term</code> 来执行这些的命令 (即被称为可视化的命令)</p>
<p>如果你想修改可视化命令的列表，你可以修改变量 <code>eshell-visual-commands</code></p>
<h2 id="command-history">Command History</h2>
<p>Eshell 有功能丰富的命令行历史机制，但是因为Eshell 不是继承 <code>comint-mode</code> 的</p>
<p>所以 <code>comint-mode</code> 与历史相关的功能，Eshell 是没法用的，不过它绝大部份的功能都已经在Eshell 重新实现了</p>
<h3 id="m-r-m-s">M-r /M-s</h3>
<p>向前或者向后搜索命令，支持正则表达式</p>
<h3 id="m-p-m-n">M-p/M-n</h3>
<p>在历史命令列表中前进或者后退</p>
<h3 id="c-p-c-n">C-p/C-n</h3>
<p>Eshell上一条命令或者下一条命令</p>
<h3 id="c-c-m-r-c-c-m-s">C-c M-r /C-c M-s</h3>
<p>回到上一条/下一条历史命令，历史命令必须与现在的命令输入一致。</p>
<p>例如现在的输入是：
<code>ls</code> ,那么回到的上一条 /下一条历史命令必须是 <code>ls</code>,或者以 <code>ls</code> 开头的命令，如 <code>lsmod</code></p>
<p>不足的是，新的经过修改的命令 <code>comint-history-isearch-backward-regexp</code> (在 <code>comint</code> 键绑定是 <code>M-r</code>)在Eshll 是无法使用的，因为Eshell 不是继承于 <code>comint</code> (所以在升级中被忽略了)</p>
<h2 id="history-interaction">History Interaction</h2>
<p>像bash 和其它shell 那样，Eshell 也支持历史的修改和交互。</p>
<p>如果想要知道历史交互是怎么操作的，你就需要回去翻一下 bash 的手册了。接下来我会总结一下Eshell 大部份的历史交互用法</p>
<h3 id="ef9fcd">!!</h3>
<p>重复上一条命令</p>
<h3 id="ls">!ls</h3>
<p>重复上一条以 <code>ls</code> 开头的命令</p>
<h3 id="ls">!?ls</h3>
<p>重复上一条包含 <code>ls</code> 的命令</p>
<h3 id="ls-n">!ls:n</h3>
<p>从上一条以 <code>ls</code> 开头的命令截取第n个参数</p>
<h3 id="ls-tab">!ls&lt;tab&gt;</h3>
<p>使用命令补全，显示补全结果中包含 <code>ls</code> 的命令</p>
<h3 id="old-new">^old^new</h3>
<p>快速替换，对于上一条命令，使用 <code>old</code> 来代替命令中的 <code>new</code> (备注：似乎有Bug)</p>
<h3 id="792e5b">$_</h3>
<p>返回上一条执行的命令的最后一个参数</p>
<p>Eshll 也支持bash 历史修改(例如 !!:s/old/new/),如果你想了解更多的信息，
<a href="https://www.gnu.org/software/bash/manual/bash.html#History-Interaction">the bash reference on history interaction</a> 可以告诉你你想知道的东西</p>
<h2 id="commandline-interaction">Commandline Interaction</h2>
<h2 id="the-eshell-prompt">The Eshell Prompt</h2>
<p>你可以通过修改变量 <code>eshell-prompt-function</code> 来自定义Eshell 的提示符；该变量
有一个函数定义了Eshell 命令行提示符应该包含的内容。</p>
<p>通过用elisp 来管理Eshell 命令行提示符的配置，你就可以实现你想要的任何特性。</p>
<p>你需要注意的事情就是：你需要告诉Eshell,命令行提示符长什么样子，所以你必须修改变量 <code>eshell-prompt-regexp</code>
,那样 Eshell 就会知道你想要的提示符长什么样子了</p>
<h2 id="the-commandline">The Commandline</h2>
<p>Eshell 可以使用反斜杠 <code>\</code> 来转义新行，以及基本的多行输入。</p>
<p>另外一个输入多行的文学字符串 (literal string)的方法就是使用单引号：输入一个单引号，然后回车，
接着你就可以输入你想输入的内容，最后用另外一个单引号结束输入。</p>
<p>如果你使用双引号的话，Eshell 会自动展开 subshell 命令并且展开相应的变量得益于Eshell 的调用机制，你甚至可以回去继续修改引号里面的文本。</p>
<p>当你想回去修改你不喜欢的内容，让Eshell像你预期那样工作的时候，你就会觉得这种特性真的相当
有用</p>
<h2 id="useful-keybindings">Useful Keybindings</h2>
<p>Eshell 做了很多与Eamcs 进行交互的功能的改进，而且，这些改进足以影响你的生活
质量，让我为你一一道来：</p>
<h3 id="c-c-m-b">C-c M-b</h3>
<p>将已经某个缓冲区的名字插入到当前光标</p>
<h3 id="c-c-m-i">C-c M-i</h3>
<p>将已经某个进程的名字插入到当前光标</p>
<h3 id="c-c-m-v">C-c M-v</h3>
<p>将一个环境变量的名字插入到当前光标</p>
<h3 id="c-c-m-d">C-c M-d</h3>
<p>在直接输入和延迟输入(回车确认)之间切换 (对不能与来源于其他缓冲区的输入正常工作
的命令来说就很有用了)</p>
<h2 id="argument-predicates">Argument Predicates</h2>
<p>参数谓词是一个很擅长过滤文件，甚至elisp列表的工具。</p>
<p>Eshell的谓词语法是参照zsh 的，所以如果你熟悉zsh的参数谓词，你也可以以同样的方式来使用Eshell.</p>
<p>与Eshell 绝大部分迥异的是，参数谓词是有详细的文档的。你可以通过输入 <code>eshell-display-predicate-help</code></p>
<p>或者 <code>eshell-display-modifier-help</code> 来查看帮助文档参数谓词用来过滤有相同模式的文件是很有用，你不需再花费额外的时间来使用诸如 <code>find</code> <code>ls</code> 此类命令。</p>
<p>虽然有帮助手册，但是手册还是很简单，不尽人意，所以我自己总结了一些用法来帮助读者了解相关特性。</p>
<p>但是最好的学习方法还是多尝试，多出错，多总结</p>
<h3 id="syntax-reference">Syntax Reference</h3>
<p>我就不把那么多的谓词和修饰符一一列出来了，因为Eshell 的手册已经作了很详细的解释了，你需要做的就是自己查看</p>
<h3 id="globbing">Globbing</h3>
<p>Eshell 的匹配模式和其他常用shell 的是基本一致滴：shell 会扩展文件和路径的匹配 模式，然后将匹配后的列表当作参数传递给相应的命令，例如 <code>ls</code>.</p>
<p>这就是为什么你一起使用 <code>find</code> 和 <code>xargs</code> 命令的时候，最好要把 <code>-print0</code> 传递给 <code>find</code> 并且把 <code>-0</code>
传递给 <code>xargs</code>.</p>
<p>因为如果你不这样做的话，文件名或者路径名中的特殊字符或者空格就会 让 <code>xargs</code> 不知道如何正确地处理。通过使用 <code>NUL</code> 字符作为分隔符，保证字符可以被正确地标记，并且文件中紧跟着 <code>/</code> 的 <code>NUL</code> 字符会被标记为无效字符</p>
<h3 id="elisp-lists">Elisp Lists</h3>
<p>如果你把Eshell 的列表理解成输出的 <code>form</code> 的elisp列表，你会发现理解起来变得容易因为事实上Eshell 是可以通过Elisp 来处理列表的，而处理列表恰恰是Lisp 擅长的东西最简单的模式扩展就是 <code>echo *</code>,该命令会把当前文件夹下所有匹配的文件以列表的形式 打印出来。</p>
<p>因为，正如我先前提及的那样，通配符扩展是同步一致进行的，所以我可以在 在使用 <code>*</code> 的同时再使用另外一个修饰符。</p>
<p>例如: 我们把当前文件夹下的所有文件名变成大写的形式，并以列表的形式打印出来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/ $ <span class="nb">echo</span> *<span class="o">(</span>:U<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span><span class="s2">&#34;BAR&#34;</span> <span class="s2">&#34;BIN/&#34;</span> <span class="s2">&#34;DEV/&#34;</span> <span class="s2">&#34;ETC/&#34;</span> <span class="s2">&#34;FOO&#34;</span> <span class="s2">&#34;HOME/&#34;</span> <span class="s2">&#34;LIB/&#34;</span> <span class="s2">&#34;TMP/&#34;</span> <span class="s2">&#34;USR/&#34;</span> <span class="s2">&#34;VAR/&#34;</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，我是怎样在使用模式扩展的同时使用 <code>()</code>.这对括号可以让你使用参数修饰符或者 是谓词。</p>
<p>修饰符是可以修饰你的结果列表的(很惊讶吧).</p>
<p>修饰符总是以冒号 <code>:</code> 开头滴， 而谓词却不一样。</p>
<p>我会展示另外一个例子，这次这个例子我会使用谓词来过滤目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/ $ <span class="nb">echo</span> *<span class="o">(</span>^/<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span><span class="s2">&#34;bar&#34;</span> <span class="s2">&#34;foo&#34;</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个 <code>^</code> 在上面的命令的作用，是跟在正则表达式中一样，用作取反，而斜杠的作用 <code>/</code>
是只代表目录，所以上面的作用就是打印所有文件</p>
<p>对于修饰符和谓词，我也可以不使用模式扩展</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/ $ <span class="nb">echo</span> <span class="o">(</span><span class="s2">&#34;foo&#34;</span> <span class="s2">&#34;bar&#34;</span> <span class="s2">&#34;baz&#34;</span> <span class="s2">&#34;foo&#34;</span><span class="o">)(</span>:gs/foo/blarg<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span><span class="s2">&#34;blarg&#34;</span> <span class="s2">&#34;bar&#34;</span> <span class="s2">&#34;baz&#34;</span> <span class="s2">&#34;blarg&#34;</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这次我是把所有的 <code>foo</code> 代替为 <code>blarg</code>.</p>
<p>你可以发现语法是相同的，只是这次我不是使用模式匹配来获取文件列表，而是直接输入文件的列表.</p>
<p>使用参数谓词和修饰符的好处是你大大减少了输入的命令行数量，因为用谓词可以处理权限 ，属主，文件属性，甚至更多方面的问题</p>
<h3 id="adding-new-modifiers-and-predicates">Adding New Modifiers and Predicates</h3>
<p>你也可以添加自己的谓词 (<code>eshell-predicate-alist</code>)或者修饰符 (<code>eshell-modifier-alist</code>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">&#39;eshell-modifier-alist</span> <span class="o">&#39;</span><span class="p">(</span><span class="sc">?X</span> <span class="o">.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">lambda</span><span class="p">(</span><span class="nv">lst</span><span class="p">)(</span><span class="nf">mapcar</span> <span class="ss">&#39;rot13</span> <span class="nv">lst</span><span class="p">))))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我已经将 <code>rot13</code> 绑定到 <code>X</code> 了，替换结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/ $ <span class="nb">echo</span> <span class="o">(</span><span class="s2">&#34;foo&#34;</span> <span class="s2">&#34;bar&#34;</span> <span class="s2">&#34;baz&#34;</span><span class="o">)(</span>:X<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span><span class="s2">&#34;sbb&#34;</span> <span class="s2">&#34;one&#34;</span> <span class="s2">&#34;onm&#34;</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="plan-9-smart-shell">Plan 9 Smart Shell</h2>
<p>Eshell 有一个 <code>Plan 9</code> 终端的弱化版，叫做 <strong>the Eshell smart display</strong>.</p>
<p>Eshell 的智能展示(smart display)意味着它改进了所有黑客所习惯的 <strong>输入－运行－修改</strong> 工作流程。</p>
<p>智能展示特别之处在于，Eshell 的光标不会像普通的shell那样，落在你运行
的命令的输出后面；</p>
<p>相反，光标的位置会保持在你输入命令的位置，让你可以通过 <code>M-p</code> <code>M-n</code> 或者其他修改历史的命令更容易地修改你输入的命令.</p>
<p>如果你启用了 <code>smart display</code> 模式，你还可以使用 <code>SPC</code> 向下翻页，或者使用 <code>BACKSPACE</code>
向上翻页来查看那些长时间运行的命令的输出。</p>
<p>如果你按下了任何其它的按键，光标会直接跳到你缓冲区的结尾，就好像你没有启用 <code>smart display</code> 运行命令时那样</p>
<p>值得注意的是，如果Eshell 检测到你想回顾最后一条执行的命令时，Eshell 会很贴心地帮你回顾的，但是，如果你没有这样的行为，Eshell 的光标会直接跳转到缓冲区的结尾.</p>
<p>这么看来，Eshell真的很智能，而且它也有一些设置可以让你微调相关的行为。</p>
<p>你会发现智能显示 (smart display)真的非常有用，特别是你可以通过移动按键就能修改</p>
<p>刚刚执行过的命令；例如修改拼写错误的命令或者是给相应的命令添加参数, 智能显示还可以被设置成当命令成功执行时，不使用扩展的 <code>edit mode</code>;并且隐藏命令输出, 就好像你执行 <code>chown</code> 那样。</p>
<p>这也是我喜欢的玩法，如果你也想试试这种玩法，你可以把下面的elisp 代码添加到你的 <code>.emacs</code> 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;eshell</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;em-smart</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-where-to-jump</span> <span class="ss">&#39;begin</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-review-quick-commands</span> <span class="no">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">eshell-smart-space-goes-to-end</span> <span class="no">t</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果Eshell 已经被初始化(即你已经在Emacs运行了一个Eshell实例),那样的话，运行
上面的代码是不会起作用的。</p>
<p>你必须在Eshell 里面按下 <code>M-:</code> 然后输入 <code>(shell-smart-initialize)</code> ,或者直接重启Emacs
智能显示真的是非常有用的特性，但是你一时半刻是很难完全领会其全部的精妙之处滴。</p>
<p>你直接输入一个命令，Eshell的光标就会跳转到缓冲区的结尾，所以你会觉得光标似乎本来就在那里</p>
<h2 id="redirection">Redirection</h2>
<p>Eshell 的重定向跟其它shell 的工作方式基本是一样的，但是，有一项非常重要的差异就是Eshell 必须模拟可能不存在的伪设备，例如Windows 平台上的 <code>/dev/null</code> 其实是 <code>NUL</code></p>
<p>另外一个值得注意的地方就是：虽然Eshell 支持重定向，但是只是支持输出重定向，是 不支持输入重定向的。</p>
<p>为了避免跳进输入重定向这个坑，你最好使用管道。</p>
<p>重定向到标准输入 标准输出，标准错误都是可以正常工作的，此外，你也可以重定向到多个目标，很不错的特性吧</p>
<h2 id="to-emacs">To Emacs</h2>
<p>因为Eshell 在内部用Elisp重新实现了各种伪设备，所以也就无需跟Unix 的设备文件打交道了，甚至，可以用Elisp实现自己的伪设备。</p>
<p>一个很好的例子就是，你可以把重定向到一个你选择的缓冲区，用下面的命令就能实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/ $ cat mylog.log &gt;&gt; <span class="c1">#&lt;buffer *scratch*&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我之前提到的快捷键 <code>C-c M-b</code> 就是可以把一个选定的缓冲区的名字插入到光标前</p>
<p>此外，你也可以把输出直接重定向到Elisp 的符号(不过注意，不要执行错误的设置)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/ $ <span class="nb">echo</span> foo bar baz &gt; <span class="c1">#&#39;myvar</span>
</span></span><span class="line"><span class="cl">/ $ <span class="nb">echo</span> <span class="k">$(</span>cadr myvar<span class="k">)</span>
</span></span><span class="line"><span class="cl">bar
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你将变量 <code>eshell-buffer-shorthand</code> 设置为 <code>t</code> 的话。</p>
<p>你就可以使用缓冲区的速记名, 例如 <code>#'*scratch*'</code>,但是你就不能直接重定向到Elisp 的符号了</p>
<h2 id="to-pseudo-devices">To Pseudo-Devices</h2>
<p>Eshell 重新实现了以下的伪设备：</p>
<h3 id="dev-eshell">/dev/eshell</h3>
<p>以交互的方式，把结果输出到Eshell</p>
<h3 id="dev-null">/dev/null</h3>
<p>把结果输出到 <code>NULL</code> 设备</p>
<h3 id="dev-clip">/dev/clip</h3>
<p>把结果输出到剪切板</p>
<h3 id="dev-kill">/dev/kill</h3>
<p>把结果输出到 <code>kill ring</code></p>
<p>跟通用的shell 一样，使用 <code>&gt;</code> 代表覆盖(或者新建);使用 <code>&gt;&gt;</code> 代表追加</p>
<h3 id="to-custom-virtual-target">To custom virtual target</h3>
<p>你通过修改变量 <code>eshell-virtual-targets</code> 创建自己的可视化目标(即存储你想创建的 伪设备的名字的一个列表),以及修改代表重定向行为(即覆盖或追加或插入)的函数 <code>mode</code></p>
<h2 id="tramp">TRAMP</h2>
<p>Eshell 可以很好地支持TRAMP,这意味着如果Eshell 所在的目录是在远程服务器的话， 像 <code>su</code> <code>sudo</code> <code>whoami</code> 这样的命令会自动作用在远程服务器</p>
<p>想直接使用TRAMP,你可以像使用 <code>C-x C-f</code> 寻找文件那样输入TRAMP的命令符，然后你就可以使用TRAMP 了。</p>
<p>虽然你会觉得Eshell里面使用TRAMP有点奇怪，但是你的确得到了 一个TRAMP的远程shell,不是么？</p>
<p>此外，你不应把TRAMP局限在使用远程shell, 你可以在本地 使用 <code>sudo</code> 和 <code>su</code> 命令的</p>
<p>有关TRAMP 的更详细的用法，我总结在了另外一篇文章，不过如果你迫不及待想了解更多
有关TRAMP的用法，<a href="http://www.gnu.org/software/tramp/">官方手册</a> 是一个很好的选择</p>
<h2 id="startup-scripts">Startup Scripts</h2>
<p>跟其它的shell 一样，Eshell 也支持 <code>login</code> 和 <code>profile</code> 的配置文件。</p>
<p><code>login</code> 和 <code>profile</code> 配置文件的绝对路径分别保存在变量 <code>eshell-login-script</code> 和 <code>eshell-rc-script</code>
不过默认情况下，上述两个配置文件都保存在 <code>~/.eshell/</code>.</p>
<p>顺便说一下，Eshell的配置文件也是使用 <code>#</code> 来注释变量和语句的</p>
<h2 id="more-customization">More Customization</h2>
<p>如果你想折腾的话，Eshell 有成百上千的选项供你选择。</p>
<p>如果你想配置Eshell 的话，按下 <code>M-x</code> 然后输入 <code>customize-group</code> 回车，然后输入 <code>eshell</code> 回车确认</p>
<h2 id="conclusion">Conclusion</h2>
<p>额，我觉得我已经总结了Eshell 的大部份用法了，希望你可以在其中发现乐趣。</p>
<p>因为与Emacs 的紧密结合，Eshell 有了各种各样突出好用的特性，但是你需要理解的是，Eshell 的诞生不是
为了全盘取代bash 或者其它你喜欢的终端模拟器，它只是希望在Emacs 里面就可以完成我们
日常必需的命令行操作。</p>
<p>如果你要运行很多交互式的命令，Eshell 就可能不是很有用了 因为为了运行你输入的每一条可视化命令，Eshell 都会在Emacs 里面启动一个新的终端模拟器。</p>
<p>Eshell 有TRAMP支持，自定义伪设备，袖珍的elisp REPL和很多非常有用的命令，例如对你打开的文件或者目录，调用 <code>find-file</code> 或者 <code>dired</code>.正是这种种有用的特性， 让Eshell 成为我工具箱里面一个非常可靠的工具。</p>
<p>原文地址 <a href="https://www.masteringemacs.org/article/complete-guide-mastering-eshell">Mastering Eshell</a> ,在下翻译水平有限，如有错误，还望指出</p>
]]></content:encoded>
    </item>
    <item>
      <title>提高Emacs启动速度</title>
      <link>https://ramsayleung.github.io/zh/post/2016/emacs_startup/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2016/emacs_startup/</guid>
      <description>Tips to reduce emacs startup time</description>
      <content:encoded><![CDATA[<p>之前看到个笑话：</p>
<blockquote>
<ul>
<li>A: 在等待emacs 加载的时间里，你会干什么？</li>
<li>B: 打开Vim,修改代码，保存，退出</li>
</ul>
</blockquote>
<p>有时候，经常看到社区里面有人吐嘈Emacs 什么都好，就是启动时间太长了，其实是存在一些技巧来缩短加载时间的</p>
<h2 id="技巧1"><span class="section-num">1</span> 技巧1</h2>
<p>在你的 <code>.emacs</code> 或者相应的初始化文件里面添加如下代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="err">#</span> <span class="nv">Increase</span> <span class="nv">the</span> <span class="nv">garbage</span> <span class="nv">collection</span> <span class="nv">threshold</span> <span class="nv">to</span> <span class="mi">128</span> <span class="nv">MB</span> <span class="nv">to</span> <span class="nv">ease</span> <span class="nv">startup</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">gc-cons-threshold</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">128</span> <span class="mi">1024</span> <span class="mi">1024</span> <span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nv">your</span> <span class="nv">configuration</span> <span class="nv">code</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="o">......</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nv">Garbage</span> <span class="nv">collector-decrease</span> <span class="nv">threshold</span> <span class="nv">to</span> <span class="mi">5</span> <span class="nv">MB</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;after-init-hook</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">gc-cons-threshold</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">5</span> <span class="mi">1024</span> <span class="mi">1024</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nv">init.el</span> <span class="nv">ends</span> <span class="nv">here</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>gc-cons-threshold</code> 指定了emacs 进行垃圾回收的阀值，默认值是 <code>800000byte</code>,实在是太小了，所以Emacs 会在启动期间进行非常多次的垃圾回收，启动时间自然长了。</p>
<p>在加载完以后，再把 <code>gc-cons-threshold</code> 的值调低，当然，如果你的内存很大，也可以不改回来</p>
<h2 id="技巧2"><span class="section-num">2</span> 技巧2</h2>
<p><code>(let((file-name-hander-alist nil))init.file)</code> 包裹(wrap)你的初始化文件，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">gc-cons-threshold</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">500</span> <span class="mi">1024</span> <span class="mi">1024</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">file-name-handler-alist</span> <span class="no">nil</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nv">**</span> <span class="nv">your</span> <span class="nv">config</span> <span class="nv">goes</span> <span class="nv">here</span> <span class="nv">**</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;after-init-hook</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">gc-cons-threshold</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">5</span> <span class="mi">1024</span> <span class="mi">1024</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">provide</span> <span class="ss">&#39;init</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">;;; init.el ends here</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为 <code>file-name-handler-alist</code> 的默认值是一些正则表达式，也就是说Emacs 在启动过程中加载el和elc 文件都会将文件名和正则表达式进行匹配</p>
<h2 id="技巧3"><span class="section-num">3</span> 技巧3</h2>
<p>Emacs lisp 有一项auto-load 的技术，类似延迟加载，合理运用延迟，让笔者的Emacs启动加载时间减少一半，因为笔者用 <code>use-package</code> 这个macro,而 <code>use-package</code> 又集成了延迟加载的功能，所以笔者就直接拿自己的代码举例了</p>
<h3 id="after"><span class="section-num">3.1</span> :after</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="c1">;;; Export to twitter bootstrap</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">ox-twbs</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:after</span> <span class="nv">org</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:ensure</span> <span class="nv">ox-twbs</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>:after</code> 关键字的作用基本跟 <code>with-eval-after-load</code> 的作用是相同的，所以笔者所
有类似的org-mode 插件包都会在org-mode 加载以后才会加载</p>
<h3 id="commands"><span class="section-num">3.2</span> :commands</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">avy</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:commands</span> <span class="p">(</span><span class="nv">avy-goto-char</span> <span class="nv">avy-goto-line</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:ensure</span> <span class="no">t</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里就贴上<a href="https://github.com/jwiegley/use-package">use-package</a>文档 的说明了</p>
<blockquote>
<p>When you use the :commands keyword, it creates autoloads for those commands
and defers loading of the module until they are used</p>
</blockquote>
<p>也就是 <code>:commands</code> 关键字就创建了后面所接的命令的 <code>autoloads</code> 机制了</p>
<h3 id="bind-mode"><span class="section-num">3.3</span> :bind :mode</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">hi-lock</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:bind</span> <span class="p">((</span><span class="s">&#34;M-o l&#34;</span> <span class="o">.</span> <span class="nv">highlight-lines-matching-regexp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="s">&#34;M-o r&#34;</span> <span class="o">.</span> <span class="nv">highlight-regexp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="s">&#34;M-o w&#34;</span> <span class="o">.</span> <span class="nv">highlight-phrase</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">vue-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:ensure</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:mode</span> <span class="p">(</span><span class="s">&#34;\\.vue\\&#39;&#34;</span> <span class="o">.</span> <span class="nv">vue-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span> <span class="p">(</span><span class="nb">progn</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nb">setq</span> <span class="nv">mmm-submode-decoration-level</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>附上文档说明</p>
<blockquote>
<p>In almost all cases you don&rsquo;t need to manually specify :defer t. This is implied
whenever :bind or :mode or :interpreter is used</p>
</blockquote>
<p>也就是说，当你使用了 <code>:bind</code> 或者 <code>:mode</code> 关键字的时候，不用明确指定 <code>:defer</code> 也可以实现延迟加载机制。</p>
<p>当然你也可以，直接使用 <code>:defer</code> 关键字来指定延迟加载. 不过前提是，你要明确它加载的时机</p>
<blockquote>
<p>Typically, you only need to specify :defer if you know for a fact that some
other package will do something to cause your package to load at the appropriate
time, and thus you would like to defer loading even though use-package isn&rsquo;t
creating any autoloads for you.</p>
</blockquote>
<p>贴上笔者自己的代码，可以更加清晰</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">anaconda-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:ensure</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:init</span><span class="p">(</span><span class="nb">progn</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;python-mode-hook</span> <span class="ss">&#39;anaconda-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;python-mode-hook</span> <span class="ss">&#39;anaconda-eldoc-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样 <code>anaconda-mode</code> 就会在 <code>python-mode</code> 加载以后被加载</p>
<p>Enjoy Emacs :)</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
