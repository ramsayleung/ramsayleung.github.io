<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>bloom_filter on 自由庄园</title>
    <link>https://ramsayleung.github.io/zh/tags/bloom_filter/</link>
    <description>Recent content in bloom_filter on 自由庄园</description>
    <image>
      <title>自由庄园</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>See this site&#39;s source code [here](https://github.com/ramsayleung/ramsayleung.github.io), licensed under GPLv3 ·</copyright>
    <lastBuildDate>Sun, 09 Apr 2017 00:00:00 +0800</lastBuildDate><atom:link href="https://ramsayleung.github.io/zh/tags/bloom_filter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>爬虫高效去重之布隆过滤器</title>
      <link>https://ramsayleung.github.io/zh/post/2017/bloom_filter/</link>
      <pubDate>Sun, 09 Apr 2017 00:00:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2017/bloom_filter/</guid>
      <description>an dscription about bloom filter</description>
      <content:encoded><![CDATA[<p>笔者最近思考如何编写高效的爬虫; 而在编写高效爬虫的时候，有一个必需解决的问题就是：
url 的去重，即如何判别 url 是否已经被爬取，如果被爬取，那就不要重复爬取。</p>
<p>一般如果需要爬取的网站不是非常庞大的话，使用Python 内置的 set 就可以实现去重了，但是使用 set 内存利用率不高，此外对于那些不像Python 那样用 hash 实现的 set 而言，时间复杂度是 log(N),实在难说高效。</p>
<h2 id="bloom-filter"><span class="section-num">1</span> Bloom Filter</h2>
<p>那么如何实现高效的去重呢？ 笔者查阅资料之后得知：使用布隆过滤器 (Bloom Filter).</p>
<p>布隆过滤器可以用于快速检索一个元素是否在一个集合中。布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数（Hash函数）。</p>
<p>而一般的判断一个元素是否在一个集合里面的做法是：用需要判断的元素和集合中的元素进行比较，一般的数据结构，例如链表，树，都是这么实现的。</p>
<p>缺点是：随着集合元素的增多，需要比较的元素也增多，检索速度就越来越慢。</p>
<p>而使用布隆过滤器判重可以实现常数级的时间复杂度(检索时间不随元素增长而增加).那么布隆过滤器又是怎样实现的呢</p>
<h3 id="布隆过滤器实现原理"><span class="section-num">1.1</span> 布隆过滤器实现原理</h3>
<p>一个Bloom Filter是基于一个m位的位向量（Bit Vector），这些位向量的初始值为0, 并且有一系列的 hash 函数，hash 函数值域为1-m.在下面例子中，是15位的位向量，初始值为0以空白表示，为1以颜色填充</p>
<figure><a href="/ox-hugo/bit_vector.png">
    <img loading="lazy" src="/ox-hugo/bit_vector.png"/> </a>
</figure>

<p>现在有两个简单的 hash 函数：fnv,murmur.现在我输入一个字符串 &ldquo;whatever&rdquo; ,然后分别使用两个 hash 函数对 &ldquo;whatever&rdquo; 进行散列计算并且映射到上面的位向量。</p>
<figure><a href="/ox-hugo/whatever.png">
    <img loading="lazy" src="/ox-hugo/whatever.png"/> </a>
</figure>

<p>可知，使用 fnv 函数计算出的 hash 值是11,使用 murmur 函数计算出的 hash 值是4. 然后映射到位向量上：</p>
<figure><a href="/ox-hugo/bit_vector1.png">
    <img loading="lazy" src="/ox-hugo/bit_vector1.png"/> </a>
</figure>

<p>如果下一次，笔者要判断 <strong>whatever</strong> 是否在字符串中，只需使用 fnv 和 murmur 两个 hash 函数对 <strong>whatever</strong> 进行散列值计算，然后与位向量做 &ldquo;与运算&rdquo;，如果结果为0, 那么说明 <strong>whatever</strong> 是不在集合中的，因为同样的元素使用同一个 hash 函数产生的值每次都是相同的，不相同就说明不是同一个元素。</p>
<p>但是如果 &ldquo;与运算&rdquo; 的结果为1,是否可以说明 <strong>whatever</strong> 就在集合中呢？其实上是不能100% 确定的，因为 hash 函数存在散列冲突现象 (即两个散列值相同，但两个输入值是不同的), 所以布隆过滤器只能说&quot;我可以说这个元素我在集合中是看见过滴，只是我有一定的不确定性&quot;.</p>
<p>当你在分配的内存足够大之后，不确定性会变得很小很小。</p>
<p>你可以看到布隆过滤器可以有效利用内存实现常数级的判重任务，但是鱼和熊掌不可得兼，付出的代价就是一定的误判 (机率很小),所以本质上，布隆过滤器是 &ldquo;概率数据结构 (probabilistic data structure)&rdquo;.</p>
<p>这个就是布隆过滤器的基本原理。当然，位向量不会只是15位，hash函数也不会仅是两个简单的函数. 这只是简化枝节，为了清晰解述原理而已。</p>
<h2 id="python-bloomfilter"><span class="section-num">2</span> Python BloomFilter</h2>
<p>算法都是为了实际问题服务的，又回到爬虫这个话题上。在了解布隆过滤器原理之后，可以很容易地实现自己的布隆过滤器，但是想要实现一个高效健壮的布隆过滤器就需要比较多的功夫了，因为需要考虑的问题略多。</p>
<p>幸好，得益Python 强大的社区，已经有<a href="https://axiak.github.io/pybloomfiltermmap/">Python BloomFilter</a> 的库。一个文档中的简单例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pybloomfilter</span> <span class="kn">import</span> <span class="n">BloomFilter</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bf</span> <span class="o">=</span> <span class="n">BloomFilter</span><span class="p">(</span><span class="mi">10000000</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s1">&#39;filter.bloom&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;/usr/share/dict/words&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">bf</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="s1">&#39;apple&#39;</span> <span class="ow">in</span> <span class="n">bf</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>结果为 <strong>True</strong></p>
<h2 id="总结"><span class="section-num">3</span> 总结</h2>
<p>原理就说得差不多了，要想对布隆过滤器有更深的认识，还需要更多的实战。多写，多思考。 Enjoy Python,Enjoy Crawler :)</p>
<h2 id="参考"><span class="section-num">4</span> 参考</h2>
<ul>
<li><a href="https://llimllib.github.io/bloomfilter-tutorial/">https://llimllib.github.io/bloomfilter-tutorial/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bloom_filter">https://en.wikipedia.org/wiki/Bloom_filter</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
