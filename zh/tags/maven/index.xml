<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Maven on 菠萝油与天光墟</title>
    <link>https://ramsayleung.github.io/zh/tags/maven/</link>
    <description>Recent content in Maven on 菠萝油与天光墟</description>
    <image>
      <title>菠萝油与天光墟</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.146.7</generator>
    <language>zh</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 ·</copyright>
    <lastBuildDate>Fri, 25 Feb 2022 07:59:43 +0800</lastBuildDate>
    <atom:link href="https://ramsayleung.github.io/zh/tags/maven/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Maven 小记</title>
      <link>https://ramsayleung.github.io/zh/post/2018/maven%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Tue, 23 Oct 2018 12:15:00 +0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2018/maven%E5%B0%8F%E8%AE%B0/</guid>
      <description>&lt;p&gt;Maven 在工作中的经验以及《Maven 实战》读后感&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;&lt;span class=&#34;section-num&#34;&gt;1&lt;/span&gt; 前言&lt;/h2&gt;
&lt;p&gt;蚂蚁金服的伯岩大大曾经说 &lt;a href=&#34;http://blog.fnil.net/index.php/archives/70/&#34;&gt;Java 生态都太重量级，连Maven 都是怪兽级的构建工具，需要整整一本书来讲解&lt;/a&gt;. 平心而论，Maven 的确如此, 但是无论是怪兽级，还是迪迦级的工具，只要能把事情做好了就是好工具, 而 Maven 恰恰就是这样的工具&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Maven 在工作中的经验以及《Maven 实战》读后感</p>
<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>蚂蚁金服的伯岩大大曾经说 <a href="http://blog.fnil.net/index.php/archives/70/">Java 生态都太重量级，连Maven 都是怪兽级的构建工具，需要整整一本书来讲解</a>. 平心而论，Maven 的确如此, 但是无论是怪兽级，还是迪迦级的工具，只要能把事情做好了就是好工具, 而 Maven 恰恰就是这样的工具</p>
<h2 id="配置文件"><span class="section-num">2</span> 配置文件</h2>
<h3 id="pom-dot-xml"><span class="section-num">2.1</span> pom.xml</h3>
<p>就好像 Unix 平台的 Make 对应的 <code>MakeFile</code>，Cmake对应的 <code>CmakeFile.txt</code>, Maven 项目的核心是 <code>pom.xml</code>, POM(Project Object Model,项目对象模型)定义了项目的基本信息，用于描述项目如何构建，声明项目依赖等等，可以 pom.xml 是 Maven 一切实践的基础</p>
<h2 id="依赖管理"><span class="section-num">3</span> 依赖管理</h2>
<h3 id="坐标"><span class="section-num">3.1</span> 坐标</h3>
<p>Maven 仓库中有成千上万个构件（jar，war 等文件），Maven 如何精确地找到用户所需的构件呢，用的就是坐标。说起坐标，可能第一反映是平面几何中的 x，y坐标，通过 x，y坐标来唯一确认平面中的一个点，而Maven 的坐标就是用来唯一标识一个构件。</p>
<p>Maven 通过坐标为构件引入了秩序，任何一个构件都需要明确定义自己的坐标，而坐标是由以下元素组成：<code>groupId</code>, <code>artifactId</code>, <code>version</code>, <code>packaging</code>, <code>classifier</code>, <code>scope</code>, <code>exclusions</code>等。一个典型的Maven 坐标：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;groupId&gt;</span>springframework<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;artifactId&gt;</span>spring-beans<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;version&gt;</span>1.2.6<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>坐标元素详解:</p>
<ul>
<li>groupId(必填): 定义当前Maven 项目隶属的实际项目, 一般是域名的方向定义</li>
<li>artifactId(必填): 定义实际项目中的一个Maven 项目，推荐的做法是使用实际项目名称作为 <code>artifactId</code> 的前缀, 比如上例的 <code>artifactId</code> 是 spring-beans，使用了实际项目名 spring 作为前缀</li>
<li>version(必填): 定义了Maven 项目当前所处的版本，如上例版本是 1.2.6</li>
<li>packaging(选填): 定义了Maven 项目的打包方式。打包方式和所生成的构建的文件扩展名对应，如果上例增加了<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code>元素，最终的文件名为spring-beans-1.2.6.jar(Maven 打包方式默认是 jar)，如果是 web 构件，打包方式就是 <code>war</code>，生成的构件将会以<code>.war</code> 结尾</li>
<li>classifier: 用来帮助定义构建输出的一些附属构件. 附属构建和主构件对应，如上例的主构件是<code>spring-beans-1.2.6.jar</code>, 这个项目还会通过使用一些插件生成`=spring-beans-1.2.6-doc.jar=, <code>spring-beans-1.2.6-source.jar</code>, 其中包含文档和源码</li>
<li>exclusions: 用来排除依赖</li>
<li>scope: 定义了依赖范围，例如 <code>junit</code> 常见的scope 就是<code>&lt;scope&gt;test&lt;/scope&gt;</code>, 表示这个依赖只对测试生效</li>
</ul>
<h3 id="依赖范围"><span class="section-num">3.2</span> 依赖范围</h3>
<p>上文提到，JUnit 依赖的测试范围是test，测试范围用元素scope 表示。首先需要知道，Maven 在编译项目主代码的时候需要使用一套classpath，上例在编译项目主代码的时候就会用到<code>spring-beans</code>，该文件以依赖的方式呗引入到classpath 中。</p>
<p>其次，Maven 在执行测试时候会使用另外一套 classpath。如上文提到的 JUnit 就是以依赖的方式引入到测试使用的 classpath，需注意的是这里的依赖范围是<code>test</code>. 最后，项目在运行的时候，又会使用另外一套的 classpath，上例的<code>spring-beans</code>就是在该classpath里，而JUnit 则不需要。</p>
<p>简而言之，依赖范围就是用来控制依赖与这是那种 classpath (编译classpath, 测试 classpath, 运行 classpath 的关系，Maven 有以下几种依赖范围:</p>
<ul>
<li>compile: 编译依赖范围，如果没有显式指定<code>scope</code>, 那么<code>compile</code>就是默认依赖范围，使用此依赖范围的Maven 依赖，对于编译，测试，运行三种 classpath 都是有效的</li>
<li>test: 测试依赖范围，指定了该范围的依赖，只对测试 classpath 有效，在编译或者运行项目的时候，无法使用该依赖；典型例子就是 JUnit</li>
<li>provided: 已提供依赖范围。使用此依赖范围的 Maven 依赖，对于编译和测试classpath 有效，但在运行时无效</li>
<li>runtime：运行时依赖范围。使用此依赖范围的 Maven 依赖，对于测试和运行的classpath 有效，但在编译主代码时无效</li>
<li>import: 导入依赖范围，该依赖范围不会对三种 classpath 产生实际的影响</li>
<li>system: 系统依赖方位。与 provided 依赖范围完全一致, 即只对编译和测试的classpath有效，对运行时的 classpath 无效. 但是，使用system 范围的依赖必须通过systemPath 元素显式地指定依赖文件的路径 如：</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;groupId&gt;</span>javax.sql<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;artifactId&gt;</span>jdbc-stdext<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;version&gt;</span>2.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;scope&gt;</span>system<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;systemPath&gt;</span>${java.home}/lib/rt.jar<span class="nt">&lt;/systemPath&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>由于此类依赖不是通过Maven 仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用</strong>
上述除import 以外的各种依赖范围与三种classpath 的关系如下:</p>
<table>
  <thead>
      <tr>
          <th>依赖范围 scope</th>
          <th>对于编译classpath有效</th>
          <th>对于测试classpath 有效</th>
          <th>对于运行时classpath有效</th>
          <th>例子</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>compile</td>
          <td>Y</td>
          <td>Y</td>
          <td>Y</td>
          <td>spring-core</td>
      </tr>
      <tr>
          <td>test</td>
          <td>&ndash;</td>
          <td>Y</td>
          <td>&ndash;</td>
          <td>JUnit</td>
      </tr>
      <tr>
          <td>provided</td>
          <td>Y</td>
          <td>Y</td>
          <td>&ndash;</td>
          <td>servlet-apt</td>
      </tr>
      <tr>
          <td>runtime</td>
          <td>&ndash;</td>
          <td>Y</td>
          <td>Y</td>
          <td>JDBC 驱动实现</td>
      </tr>
      <tr>
          <td>system</td>
          <td>Y</td>
          <td>Y</td>
          <td>&ndash;</td>
          <td>本地的，java类库以外的文件</td>
      </tr>
  </tbody>
</table>
<h2 id="仓库"><span class="section-num">4</span> 仓库</h2>
<p>上文提及了依赖管理，通过声明的方式指定所需的构件，那么是从哪里获取所需的构件的呢？答案是 Maven 仓库，Maven 仓库可以分为两类: 本地仓库和远程仓库。</p>
<p>当 Maven 需要根据坐标寻找构件的时候，它首先会查找本地仓库，如果本地仓库存在该构件，则直接使用，如果本地不存在该构件，或者需要查看是否有更新的构件版本，Maven 聚会去远程仓库查找，发现需要的构件之后，下载到本地仓库在使用.</p>
<p>如果本地和远程仓库都没有所需要的构件，那么 Maven 就会报错。如果需要细化远程仓库的类型，还可以分成中央仓库，私服和其他公共库。</p>
<ul>
<li>中央仓库：Maven 核心自带的的远程仓库，它包含了绝大部分开源的构件。在默认的配置下，当本地仓库没有 Maven 需要的构件的时候，它就会尝试从中央仓库下载。</li>
<li>私服：为了节省带宽和时间，可以在内网假设一个特殊的仓库服务器，用来代理所有的外部的远程仓库</li>
</ul>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-fe466" hidden>
    <label for="zoomCheck-fe466">
    
    
    <img class="zoomCheck" loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191104112131.png"
         alt="Figure 1: repo"/> 
    
    
    </label><figcaption>
            <p><span class="figure-number">Figure 1: </span>repo</p>
        </figcaption>
</figure>

<h3 id="snapshot"><span class="section-num">4.1</span> SNAPSHOT</h3>
<p>在Maven 的世界中，任何一个项目或者构件都必须有自己的版本，版本可能是 <code>1.0.0</code>, <code>1.0-alpha-4,2.1-SNAPSHOT</code> 或者 <code>2.1-20181028-11</code>, 其中 <code>1.0.0</code>, <code>1.0-alpha-4</code> 是稳定的发布版本，而 <code>2.1-SNAPSHOT</code> 或者 <code>2.1-20181028-11</code> 是稳定的快照版本。</p>
<p>Maven 为什么要区分快照版本和发布版本呢？难道1.0.0 不能解决么？为什么需要2.0-SNAPSHOT。</p>
<p>我对此 <code>SNAPSHOT</code> 这个特性印象非常深刻，在蚂蚁金服的新人培训中，其中就有一项是大家协作完成一个 Mini Alipay，一个 Mini Alipay 分成三个应用<code>bkonebusiness</code>, <code>bkoneuser</code>, <code>bkoneacccount</code>，以SOA 的架构进行拆分，应用之间相互依赖。</p>
<p>在开发过程中，<code>bkoneuser</code> 经常需要将最新的构件共享 <code>bkonebusiness</code>, 以供他们进行测试和开发。</p>
<p>因为<code>bkoneuser</code>本身也在快速迭代中，为了让<code>bkonebusiness</code> 用到最新的代码，我们不断地变更版本，<code>1.0.1</code>, <code>1.0.2</code>, <code>1.0.3</code>,&hellip; <code>bkoneuser</code> 不断发版本，<code>bkonebusiness</code> 不断升版本，甚至有一次<code>bkoneuser</code> 在没有更新版本号的情况下发布了最新代码，而 <code>bkonebusiness</code> 已经有原来版本的 jar 包，所以就没有去远程仓库拉取最新的代码，就出问题了&hellip;.</p>
<p>其实 Maven 快照版本就是为了解决这种问题，防止滥用版本号和及时拉取最新代码。</p>
<p>bkoneuser 只需将版本指定为<code>1.0.1-SNAPSHOT</code>, 然后发布到远程服务器，在发布的工程中，Maven 会自动为构件打上时间戳，比如 <code>1.0.1-20181028.120112-13</code> 表示 2018年10月28号的12点01分12秒的13次快照，有了时间戳，Maven 就能随时找到仓库中该构件<code>1.0.1-SNAPSHOT</code>版本的最新文件。</p>
<p>这是，<code>bkonebusiness</code>对于 <code>bkoneuser</code>的依赖，只要构建<code>bkonebusiness</code>，Maven就会自动从仓库中检查 <code>bkoneuser</code>的罪行构建，发现有更新便进行下载。</p>
<p>基于快照版本，<code>bkonebusiness</code> 可以完全不用考虑 <code>bkoneuser</code> 的构建，因为它总是拉取最新版本的 <code>bkoneuser</code>,这个是 Maven 的快照机制进行保证。</p>
<p>如果到了 release，就要及时将 <code>1.0.1-SNAPSHOT</code>, 否则 <code>bkonebusiness</code> 在构建发布版本的时候可能拉取到最新的有问题的版本.</p>
<h3 id="仓库搜索服务"><span class="section-num">4.2</span> 仓库搜索服务</h3>
<p>在公司开发的时候有私服，但是在开发自己项目的时候，我一般到 <a href="https://repository.sonatype.org/">SnoaType Nexus</a> 找对应的构件</p>
<h2 id="插件与生命周期"><span class="section-num">5</span> 插件与生命周期</h2>
<h3 id="何为生命周期"><span class="section-num">5.1</span> 何为生命周期</h3>
<p>在有关 Maven 的日常使用中，命令行的输入往往就对应了生命周期，如 <code>mvn package</code> 就表示执行默认的生命周期阶段 <code>package</code>.</p>
<p>Maven 的生命周期是抽象的，其实际行为都由插件来完成，如<code>package</code> 阶段的任务就会有<code>maven-jar-plugin</code> 完成。</p>
<p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一，包括项目的清理，初始化，编译，测试，打包，集成测试，验证，部署等几乎所有的构建步骤。</p>
<p>需要注意的是 <strong>Maven 的生命周期是抽象的，这意味着生命周期本身不作任何实际的工作，实际的任务(如编译源代码)都交由插件来完成. 每个步骤都可以绑定一个或者多个插件行为，而且Maven 为大多数构建步骤编写并绑定了默认的插件</strong></p>
<p>例如：针对编码的插件有 <code>maven-compiler-plugin</code>,针对测试的插件有<code>maven-surefire-plugin</code> 等，用户几乎不会察觉插件的存在</p>
<h3 id="三套生命周期"><span class="section-num">5.2</span> 三套生命周期</h3>
<p>Maven 有用三套相互独立的生命周期，它们分别是<code>clean</code>, <code>default</code> , <code>site</code>. <code>clean</code> 生命周期的目的是清理项目，<code>default</code> 生命周期的目的是构件项目，而 <code>site</code> 生命周期的目的是建立项目站点</p>
<h4 id="clean-生命周期"><span class="section-num">5.2.1</span> clean 生命周期</h4>
<p>clean 生命周期主要是清理项目，它包含三个阶段:</p>
<ol>
<li>pre-clean: 执行一些清理前需要完成的工作</li>
<li>clean 清理上一次构造生成的文件</li>
<li>post-clean 执行一些清理后需要完成的工作</li>
</ol>
<h4 id="default-生命周期"><span class="section-num">5.2.2</span> default 生命周期</h4>
<p>default 生命周期奠定了真正构件时所需要执行的所有步骤，它是所有生命周期最核心的部分，其包含的阶段如下：</p>
<ul>
<li>validate</li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources 处理项目主资源文件。一般来说，是对src/main/resources 目录内的内容进行变量替换的工作后，复制到项目输出的主classpath 目录中</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile 编译项目的主源码，一般来说，是编译 src/main/java 目录下的java 文件至项目输出的主 classpath 目录中</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources 处理项目测试资源文件。一般来说，是对src/test/resources 目录的内容进行变量替换等工作后，复制到项目输出的测试classpath 目录中</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile 编码项目的测试代码。一般来说，是编译 src/test/java 目录下的java 文件至项目输出的测试classpath 目录中</li>
<li>process-test-classes</li>
<li>test 使用单元测试框架运行测试，测试代码不会被打包或部署</li>
<li>prepare-packae</li>
<li>package 接受编译好的代码，打包或可发布的格式，如 jar</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>vertify</li>
<li>install 将包安装到Maven 本地仓库，供本地其他Maven 项目使用</li>
<li>deploy 将最终的包复制到远程仓库，共其他开发人员和Maven 项目使用</li>
</ul>
<h4 id="site-生命周期"><span class="section-num">5.2.3</span> site 生命周期</h4>
<p>site 生命周期的目的是建立和发布项目站点，生命周期包含如下阶段</p>
<ul>
<li>pre-site 执行一些在生成项目站点前需要完成的工作</li>
<li>site 生成项目站点文档</li>
<li>post-site 执行一些在生成项目站点之后需要完成的工作</li>
<li>site-deploy 将生成的项目站点发布到服务器上</li>
</ul>
<h4 id="命令行和生命周期"><span class="section-num">5.2.4</span> 命令行和生命周期</h4>
<p>从命令行执行Maven 任务的最主要方式就是调用 Maven的生命周期阶段。需要注意的是，各个生命周期是相互独立的，而一个生命周期的阶段是有前后依赖关系的。</p>
<p>下面以一些常见的Maven 命令为例，解释其执行的生命周期阶段:</p>
<ul>
<li>mvn clean: 该命令调用clean 生命周期的clean 阶段。实际执行的阶段为clean 生命周期的pre-clean 和clean 阶段</li>
<li>mvn test: 该命令调用default 生命周期的test 阶段。实际执行的阶段是 default 生命周期的 validate, initialize, 直到 test 的所有阶段。这也解释了为什么在测试的时候，项目的代码能够自动得以编译</li>
<li>mvn clean install: 该命令调用 clean 生命周期的clean 阶段和default 生命周期的 install 阶段。实际执行的阶段为 clean 生命周期的 pre-clean, clean 阶段，以及default 生命周期的从validate 到 install 的所有阶段。该命令结合了两个生命周期，在执行真正的项目构建之前清理项目是一个很好的实践</li>
</ul>
<h2 id="继承"><span class="section-num">6</span> 继承</h2>
<p>如bkoneuser 的项目结构所示:</p>

<figure>
    
    
    <input type="checkbox" id="zoomCheck-25d4b" hidden>
    <label for="zoomCheck-25d4b">
    
    
    <img class="zoomCheck" loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191104112215.png"
         alt="Figure 2: bkoneuser 的项目结构"/> 
    
    
    </label><figcaption>
            <p><span class="figure-number">Figure 2: </span>bkoneuser 的项目结构</p>
        </figcaption>
</figure>

<p>按照 DDD(Domain Driven Design) 的驱动，<code>bkoneuser</code> 下有多个对应的子模块，每个模块也是一个 Maven 项目，每个模块里面可能有相同的依赖，如 <code>SpringFramework</code> 的 <code>spring-core</code>, <code>spring-beans</code>, <code>spring-context</code> 等。</p>
<p>如果每个子模块都维护一份大致相同的依赖，那么就有10几份相同的依赖，这还会随着子模块的增多而变得庞大。</p>
<p>如果我们工程师的嗅觉, 会发现有很多的重复依赖，面对重复应该怎么办？通过抽象来减少重复代码和配置，而 Maven 提供的抽象机制就是继承(还有聚合，只是个人觉得不如继承常用).</p>
<p>在 OOP 中，工程师可以建立一种类的父子结构，然后在父类中声明一些字段供子类继承，这样就可以做到“一处声明，多处使用”, 类似地，我们需要创建 POM 的父子结构，然后在父POM 中声明一些供子 POM 继承，以实现“一处声明，多处使用”</p>
<h3 id="配置示例"><span class="section-num">6.1</span> 配置示例</h3>
<p>parent 的配置如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;groupId&gt;</span>com.minialipay<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;artifactId&gt;</span>bkgponeuser-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;version&gt;</span>1.0.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;properties&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;bkgponeaccount.common.service.facade.version&gt;</span>1.1.0.20180919<span class="nt">&lt;/bkgponeaccount.common.service.facade.version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/properties&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;modules&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/core/service<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/core/model<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/biz/shared<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/biz/service-impl<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/util<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/service/facade<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/service/integration<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/common/dal<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;module&gt;</span>app/test<span class="nt">&lt;/module&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/modules&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要主要的关键点是parent 的 <code>packaging</code> 值必须是 <code>pom</code>, 而不是默认的 <code>jar</code>, 否则则无法进行构件.</p>
<p>而 <code>modules</code> 元素则是实现继承最核心的配置，通过在打包方式为 pom 的Maven 项目中声明任意数量的 <code>module</code> 来实现模块的继承, 每个 <code>module</code>的值都是一个当前POM 的相对目录，比如 <code>app/core/service</code> 就是说子模块的POM在 parent 目录的下的 <code>app/core/service</code>目录</p>
<h3 id="子模块配置示例"><span class="section-num">6.2</span> 子模块配置示例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;parent&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;groupId&gt;</span>com.minialipay<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;artifactId&gt;</span>bkgponeuser-parent<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;version&gt;</span>1.0.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;relativePath&gt;</span>../../../pom.xml<span class="nt">&lt;/relativePath&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/parent&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;artifactId&gt;</span>bkgponeuser-core-service<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;packaging&gt;</span>jar<span class="nt">&lt;/packaging&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述pom 中使用 <code>parent</code> 元素来声明父模块，<code>parent</code> 下元素groupid， artifactId 和 version 指定了父模块的坐标，这三个元素是必须。</p>
<p>元素 <code>relativePath</code> 表示父模块POM的相对路径, <code>../../../pom.xml</code> 指父POM的位置在三级父目录上</p>
<h3 id="可继承的pom-元素"><span class="section-num">6.3</span> 可继承的POM 元素</h3>
<p>可继承元素列表及简短说明:</p>
<ul>
<li>groupId: 项目Id, 坐标的核心元素</li>
<li>version：项目版本, 坐标的核心元素</li>
<li>description: 项目的描述信息</li>
<li>organization: 项目的组织信息</li>
<li>inceptionYear: 项目的创始年份</li>
<li>url: 项目的url 地址</li>
<li>developers: 项目的开发者信息</li>
<li>contributors: 项目的贡献者信息</li>
<li>distributionManagement：项目的部署配置</li>
<li>issueManagement: 项目的缺陷跟踪系统信息</li>
<li>ciManagement: 项目的持续继承系统信息</li>
<li>scm: 项目的版本控制系统信息</li>
<li>mailingLists: 项目的邮件列表信息</li>
<li>properties: 自定义的Maven 属性</li>
<li>dependencies: 项目的依赖配置</li>
<li>dependencieyManagemant: 项目的依赖管理配置</li>
<li>repositories: 项目的仓库配置</li>
<li>build: 包括项目的源码目录配置，输出目录配置，插件配置，插件管理配置等</li>
<li>reporting: 包括项目的报告输出目录配置，报告插件配置等</li>
</ul>
<h3 id="dependencymanagement-依赖管理"><span class="section-num">6.4</span> dependencyManagement 依赖管理</h3>
<p>可继承列表包含了 <code>dependencies</code> 元素，说明是会被继承的，这是我们就会很容易想到将这一特性应用到 <code>bkoneuser-parent</code> 中。子模块同时依赖 <code>spring-beans</code>,=spring-context=,=fastjson= 等, 因此可以将这些依赖配置放到父模块 <code>bkoneuser-parent</code> 中，子模块就能移除这些依赖，简化配置.</p>
<p>这种做法可行，但是存在问题，我们可以确定现有的子模块都是需要 <code>spring-beans</code>, <code>spring-context</code> 这几个模块的，但是我们无法确定将来添加的子模块就一定需要这四个依赖.</p>
<p>假设将来项目中要加入一个<code>app/biz/product</code>, 但是这个模块不需要 <code>spring-beans</code>, <code>spring-context</code>, 只需要 <code>fastjson</code>, 那么继承 <code>bkoneuser</code> 就会引入不需要的依赖，这样是非常不利于项目维护的！</p>
<p>Maven 提供的 <code>dependencyManagement</code> 元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。在 <code>dependencyManagement</code> 元素下的依赖声明不会引入实际的依赖，不过它能够约束 <code>dependencies</code> 下的依赖使用。</p>
<p>例如在 <code>bkoneuser-parent</code> 用 <code>dependencyManagement</code>声明依赖:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependencyManagement&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;groupId&gt;</span>com.alibaba<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;artifactId&gt;</span>fastjson<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;version&gt;</span>1.1.33<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;version&gt;</span>4.7<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependencies&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependencyManagement&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>app/core/service</code> 子模块进行引用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.alibaba<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>fastjson<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>junit<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>junit<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependencies&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>子模块的<code>fastjson</code> 依赖只配置了 <code>groupId</code> 和 <code>artifactId</code>, 省去了 <code>version</code> , 而 <code>junit</code> 依赖 不仅省去了<code>version</code>, 连<code>scope</code> 都省去了。</p>
<p>《Maven 实战》作者强烈推荐使用这种方式，其主要原因在与在父POM 中使用 <code>dependencyManagement</code> 声明依赖能够统一规范依赖的版本，当依赖版本在父POM中声明之后，子模块在使用依赖的时候就无须声明版本，也就不会发生多个子模块使用依赖版本不一致的情况</p>
<h2 id="依赖冲突"><span class="section-num">7</span> 依赖冲突</h2>
<p>在Java 项目中，随着项目代码量的增长，各种问题就会接踵而至，jar 包冲突就是其中一个最常见的问题. jar 冲突常见的异常: <code>NoSuchMethodError</code>, <code>NoClassDefFoundError</code></p>
<h3 id="成因"><span class="section-num">7.1</span> 成因</h3>
<p>当Maven根据pom文件作依赖分析, 发现通过直接依赖或者间接依赖, 有多个相同<code>groupId</code>, <code>artifactId</code>, 不同 <code>version</code> 的依赖时, 它会根据两点原则来筛选出唯一的一个依赖, 并最终把相应的jar包放到 classpath下:</p>
<ol>
<li>依赖路径长度: 比如应用的pom里直接依赖了A, 而A又依赖了B, 那么B对于应用来说, 就是间接依赖, 它的依赖路径长度就是2. 长度越短, 优先级越高. 当出现不同版本的依赖时, maven优先选择依赖路径短的依赖.</li>
<li>依赖声明顺序: 当依赖路径长度相同时, POM 里谁的声明在上面, Maven 就选择谁.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_a</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">b</span><span class="p">.</span><span class="na">func_b</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 来自b-1.0.jar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">B</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">c</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_b</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="n">c</span><span class="p">.</span><span class="na">func_c</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 来自c-1.0.jar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">C</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_xxx</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_c</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 来自c-1.1.jar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">C</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_xxx</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_c1</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// d.1.0.jar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">D</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 来自c-1.1.jar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">C</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func_d</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="n">c</span><span class="p">.</span><span class="na">func_xxx</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyMain</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">().</span><span class="na">func_a</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>应用程序里有个A类, 里面含有一个属性B, 这个B类来自 <code>b-1.0.jar</code> 包. A类有个 <code>func_a()</code> 方法, 里面会调用b类的 <code>func_b</code> 方法.B类含有一个属性C, 这个C类来自<code>c-1.0.jar</code>. B类还提供一个方法 <code>func_b()</code>, 里面调用C类的 <code>func_c()</code> 方法.</p>
<p>这时, 应用程序的主POM里间接依赖了 <code>c-1.1.jar</code> 包, 但是这个jar里的C类中已经把 <code>func_c()</code> 删除了.</p>
<p>这样由于B类使用的 <code>c-1.0.jar</code> 对于应用程序来说, 是间接依赖, 依赖路径长度是2 (A -&gt; B -&gt; C), 比应用程序主pom中间接依赖的 <code>c-1.1.jar</code> 路径(D-&gt;C)长, 最后就会被maven排掉了 (也就是应用程序的 classpath 下, 最终会保留 <code>c-1.1.jar</code>).</p>
<p>最后执行main函数时, 就会报 <code>NoSuchMethodError</code>, 也就是找不到C类中 <code>func_c()</code> 方法.</p>
<h3 id="解决方案"><span class="section-num">7.2</span> 解决方案</h3>
<p>强制Maven 使用<code>c-1.0.jar</code>, 也就是将<code>c-1.1.jar</code>排除掉:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;dependencies&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>com.d<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>d<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;exclusions&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;exclusion&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;groupId&gt;</span>com.c<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;artifactId&gt;</span>c<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/exclusion&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/exclusions&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/dependency&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependencies&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>d.1.0.jar</code> 的依赖排除 <code>c.1.1.jar</code> 的时候，不需要指定版本, 因为这个时候<code>d.1.0.jar</code> 的依赖的版本一定是 <code>c.1.1.jar</code>. 需要注意的是，如果 <code>d</code> 使用了<code>c.1.1.jar</code> 的 <code>func_c1()</code>，排掉 <code>c.1.1.jar</code> 是会报错的，因为满足了B类的 <code>func_c()</code> 就无法满足 D 类的 <code>func_c1()</code>, 这个就是著名的“菱形依赖问题”(diamond dependency problem)。</p>
<p>不得不说，入职的时候，遇上了各种jar 包冲突的问题，排包都排出心得. 在此推荐个排包神器, Intellij Idea 的插件：<a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">maven helper</a>, 比手动<code>-verbose:class</code> + <code>mvn dependency:tree</code>排包方便多了</p>
<h2 id="总结"><span class="section-num">8</span> 总结</h2>
<p>的确，写到这里，必须再次承认 Maven 是怪兽级的 构建工具，但是同样无可否认的是，它出色的构建和依赖管理功能。写go 语言的时候，我多希望有个 Maven 可以用呢 ╥﹏╥&hellip;</p>
<div center class="qr-container">
<img src="/ox-hugo/qrcode_gh_e06d750e626f_1.jpg" alt="qrcode_gh_e06d750e626f_1.jpg" width="160px" height="160px" center="t" class="qr-container" />
公号同步更新，欢迎关注👻
</div>
]]></content:encoded>
    </item>
  </channel>
</rss>
