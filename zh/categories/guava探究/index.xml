<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Guava探究 on 自由庄园</title>
    <link>https://ramsayleung.github.io/zh/categories/guava%E6%8E%A2%E7%A9%B6/</link>
    <description>Recent content in Guava探究 on 自由庄园</description>
    <image>
      <title>自由庄园</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.120.4</generator>
    <language>zh</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 ·</copyright>
    <lastBuildDate>Thu, 09 Jan 2025 18:49:30 -0800</lastBuildDate>
    <atom:link href="https://ramsayleung.github.io/zh/categories/guava%E6%8E%A2%E7%A9%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>guava 探究系列之五：新类型容器</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 12 Dec 2019 15:45:00 -0800</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E7%B1%BB%E5%9E%8B%E5%AE%B9%E5%99%A8/</guid>
      <description>1 前言 JDK 提供了各种功能强大的工具类, 宛如装备齐全的军火库, 而容器就是其中一项内置的利器, 提供了包括诸多常用的数据结构, 下图对 JDK 已有容器进行了</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>JDK 提供了各种功能强大的工具类, 宛如装备齐全的军火库,
而容器就是其中一项内置的利器, 提供了包括诸多常用的数据结构, 下图对 JDK
已有容器进行了概括:</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/20191122171101.png"
         alt="Figure 1: JDK 容器"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>JDK 容器</p>
        </figcaption>
</figure>

<p>不过, 虽然 JDK 的容器类已经五花八门, 琳琅满目, 但是某些很有用的容器类
JDK 依然欠缺, 而 Guava 恰如其分地填补了这些空缺, 开发了 JDK
所欠缺的容器类, &ldquo;造福大众&rdquo;.</p>
<p>此外, 虽然引入了新的容器类, 但 Guava 实现了
JDK 的 <code>Collection</code> 接口, 保证 Guava 的容器类能够与 JDK
的容器类”和谐共处”, 避免不必要的”纷争”.</p>
<h2 id="multiset"><span class="section-num">2</span> Multiset</h2>
<p>假设你是个书店的老板, 你想统计下书店里不同书籍的存货量,
你可能写下这样的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">book</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">bookNames</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Integer</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counts</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">book</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">counts</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">book</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">counts</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">book</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>嗯, 我现在想改需求, 我想知道书店里共有多少本书? 怎么办呢? 把 <code>counts</code> 的
value 都加起来?</p>
<p>对于这样的要求, Guava 提供了一个更好的解决方案: 一个新类型容器
<code>Multiset</code> , 它支持新增多个相同类型的元素并统计. 维基百科给出的关于
<code>Multiset</code>
的<a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">解释</a>:</p>
<blockquote>
<p>这是个成员可以出现多次的集合(Set), 也被称为背包(bag)</p>
</blockquote>
<p>大名鼎鼎的《算法/Algorithm》也给出过 <a href="https://algs4.cs.princeton.edu/13stacks/">bag</a> 的解释和实现.</p>
<p>需要注意的是, <code>multisets</code> 的成员是无序的, <code>{a,a,b}</code> 和 <code>{a,b,a}</code>
这两个集合在 <code>multisets</code> 看来是相等.</p>
<p>我们可以从两个角度来分析 <code>multisets</code> :</p>
<ul>
<li>
<p><code>multisets</code> 就好像一个=ArrayList&lt;E&gt;=, 只不过是无序的.
当把它当作=ArrayList&lt;E&gt;=时:</p>
<ul>
<li>调用=add(E)=函数, 增加给定元素的出现次数</li>
<li>调用=iterator()=函数, 获取一个 <code>multisets</code> 的迭代器,
用来迭代每个元素</li>
<li>调用=size()=函数, 获取所有元素出现次数之和</li>
</ul>
</li>
<li>
<p><code>multisets</code> 就好象一个=Map&lt;E, Integer&gt;=, 包含元素和对应的数量,
只不过数量只能为正数. 当把它当作=Map&lt;E, Integer&gt;=的时候:</p>
<ul>
<li>调用=count(Object)=函数获取某个特定元素的出现次数.</li>
<li>调用=entrySet()=函数返回一个=Set&lt;Multiset.Entry&lt;E&gt;&gt;=, 大概类似一个
<code>Map</code> 返回 <code>entrySet</code> .</li>
<li>调用 <code>elementSet</code> 函数返回一个=Set&lt;E&gt;=对象,
返回所有的元素(去掉重复的元素)</li>
</ul>
</li>
</ul>
<h3 id="multiset-的例子"><span class="section-num">2.1</span> Multiset 的例子</h3>
<p>粗略介绍完 <code>Multiset</code> 之后, 现在就让我们用它重新实现原来的需求:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testMultiset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">POTTER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Potter&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Multiset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bookstore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMultiset</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bookstore</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">POTTER</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bookstore</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">POTTER</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bookstore</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;四体&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bookstore</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;五体&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertTrue</span><span class="p">(</span><span class="n">bookstore</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">POTTER</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">bookstore</span><span class="p">.</span><span class="na">count</span><span class="p">(</span><span class="n">POTTER</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">4</span><span class="p">,</span><span class="w"> </span><span class="n">bookstore</span><span class="p">.</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bookstore</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">POTTER</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertTrue</span><span class="p">(</span><span class="n">bookstore</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">POTTER</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">bookstore</span><span class="p">.</span><span class="na">count</span><span class="p">(</span><span class="n">POTTER</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>multisets</code> 完美满足了我们的需求.</p>
<h3 id="multiset-并不是一个-map"><span class="section-num">2.2</span> Multiset 并不是一个 Map</h3>
<p>需要注意的是, <code>Multiset</code> 虽然与=Map&lt;E, Integer&gt;=类似, 但 <code>Multiset</code>
并不是一个=Map&lt;E, Integer&gt;=, 请不要混淆它们两个.</p>
<p>最大的差别是, <code>Multiset</code> 实现了 <code>Collection</code> 接口, 完全遵守 <code>Collection</code>
接口需要满足的协议, 而 <code>Map</code> 和 <code>Collection</code> 是完全不同的接口,
这点需要牢记于心. 还有其他的差别, 诸如:</p>
<ol>
<li>=Multiset&lt;E&gt;=出现的次数只能是正数, 没有任何元素的出现次数会是负数的,
出现次数为 0 的元素会被认为不存在,
这样的元素是不会出现在=elementSet()=和=entrySet()=的返回结果中的.
而=Map&lt;E, Integer&gt;=肯定不会有这样的限制.</li>
<li><code>multiset.size()=返回所有元素出现次数之和, 如果想要知道有多少个不重复的元素, 可以使用=elementSet().size()</code>,
例如={a,a,b}=, =elementSet.size()=返回结果是 2,
=multiset.size()=返回结果是 3.</li>
<li>=multiset.iterator()=用于迭代每个出现的元素,
所以迭代次数和=multiset.size()=的值一样的.</li>
<li><code>Multiset&lt;E&gt;=支持增加元素, 删减元素, 或者通过 =setCount</code>
函数直接设置元素的出现次数, <code>setCount(a, 0)=的意思等于将删除所有的 =a</code> 元素.</li>
<li><code>multiset.count(elem)</code>: 如果元素 <code>elem</code> 不存在, 那么返回值总是 0. 而
<code>Map</code> 对于不存在的元素, 返回的是 <code>null</code> .</li>
</ol>
<h3 id="multiset-实现"><span class="section-num">2.3</span> Multiset 实现</h3>
<p>鉴于 <code>Multiset</code> 只是个接口, Guava 提供许多的接口实现, 大致可以与 Java
中的容器对应上:</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>MultiSet</th>
<th>支持 <code>null</code> 元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashMultiset.html">HashMultiset</a></td>
<td>Yes</td>
</tr>
<tr>
<td>TreeMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeMultiset.html">TreeMultiset</a></td>
<td>Yes</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/LinkedHashMultiset.html">LinkedHashMultiset</a></td>
<td>Yes</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ConcurrentHashMultiset.html">ConcurrentHashMultiset</a></td>
<td>No</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultiset.html">ImmutableMultiset</a></td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="multimap"><span class="section-num">3</span> Multimap</h2>
<p>又来假设, 你是个班主任, 刚刚考完试, 你想记录下班里所有同学的成绩,
你可能写下这样的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Integer</span><span class="w"> </span><span class="n">studentScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">60</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">studentName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Alan&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 每个学生的成绩单</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 如果 Alan 还没记录各科成绩的列表, 就新建一个列表</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">studentScores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">studentName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">studentScores</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">studentScores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">studentName</span><span class="p">,</span><span class="w"> </span><span class="n">studentScores</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 然后将某个科目的成绩加进去</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScores</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">studentScore</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一个学生考试要考多个科目, 自然就会有多个学科成绩, 也就出现了一个 key
需要对应多个 value 的情况.
使用=Map&lt;K, List&lt;V&gt;&gt;=或者=Map&lt;K, Set&lt;V&gt;&gt;=这样的方式构建 key-values
自然可以, 只不过显得不甚优雅.</p>
<p>为此, Guava 提供了新的容器类型来应对一个
key 对应多个 values 的场景: <code>Multimap</code> . 同样的,
我们也可以从两个角度来理解 <code>Multimap</code> :</p>
<ul>
<li>一个 <code>key</code> 对应一个 <code>value</code> , 同样的 <code>key</code> 可以存在多个:</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">a -&gt; 1
</span></span><span class="line"><span class="cl">a -&gt; 2
</span></span><span class="line"><span class="cl">a -&gt; 4
</span></span><span class="line"><span class="cl">b -&gt; 3
</span></span><span class="line"><span class="cl">c -&gt; 5
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>或者一个 <code>key</code> 对应一个列表的 <code>value</code> :</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">a -&gt; [1, 2, 4]
</span></span><span class="line"><span class="cl">b -&gt; [3]
</span></span><span class="line"><span class="cl">c -&gt; [5]
</span></span></code></pre></td></tr></table>
</div>
</div><p>通常来说, 最好以第一种方式来理解 <code>Multimap</code> 接口,
不过你也可以以第二种方式来获取数据: <code>asMap()=函数, 返回一个 =Map&lt;K, Collection&lt;V&gt;&gt;</code> 对象.</p>
<p>需要注意的是, 不存在 1 个 <code>key</code> 对应 0 个 <code>value</code> 的情况, 不会有空的值列表这样的说法, 要不一个 <code>key</code> 对应至少一个
<code>value</code> , 要不就是这个 <code>key</code> 不存在于这个 <code>Multimap</code> .</p>
<p>一般来说, 我们不会直接使用 <code>Multimap</code> 接口, 使用的是它的子接口; <code>Multimap</code>
接口提供了两个子接口: <code>ListMultimap</code> 和 <code>SetMultimap</code> , 大致类似于
<code>Map&lt;K, List&lt;V&gt;&gt;=和 =Map&lt;K, Set&lt;V&gt;&gt;</code>.</p>
<h3 id="multimap-的例子"><span class="section-num">3.1</span> Multimap 的例子</h3>
<p>现在让我们用 <code>Multimap</code> 重新实现一次学生不同科目的成绩单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="w"> </span><span class="n">alan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Alan&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">turing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Turing&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 创建一个 ListMultimap</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ListMultimap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MultimapBuilder</span><span class="p">.</span><span class="na">hashKeys</span><span class="p">().</span><span class="na">arrayListValues</span><span class="p">().</span><span class="na">build</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">alan</span><span class="p">,</span><span class="w"> </span><span class="n">95</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">alan</span><span class="p">,</span><span class="w"> </span><span class="n">88</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">turing</span><span class="p">,</span><span class="w"> </span><span class="n">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">alanScores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">alan</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">alanScores</span><span class="p">.</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">alanScores</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">alan</span><span class="p">).</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="构造"><span class="section-num">3.1.1</span> 构造</h4>
<p>细心的同学可能会发现, 上面创建 <code>ListMultimap</code>
的方式不是直接调用实现类的=.create()=函数, 而是使用 <code>MultimapBuilder</code> .</p>
<p>并不是 <code>Multimap</code> 的实现没有提供=.create()=方法, 是通过
<code>MultimapBuilder</code> 创建 <code>Multimap</code> 实现会更加便利一点,
使用=hashKeys()=函数创建的就是一个 <code>HashMap</code> ,
使用=treeKeys()=函数创建的就是一个 <code>TreeMap</code> .</p>
<h4 id="修改"><span class="section-num">3.1.2</span> 修改</h4>
<p><code>Multimap.get(key)=返回的就是特定 =key</code> 关联的集合, 对于一个
<code>ListMultimap</code> , 返回的就是一个 <code>List</code> ; 对于一个 <code>SetMultimap</code> ,
返回的就是一个 <code>Set</code> .</p>
<p>实际返回的是集合的引用, 所以对这个返回集合的操作,
将直接反馈在 <code>Multimap</code> 实例上. 如上面的例子所示, 把学生 <code>alan</code>
返回列表的数据清空, 在 <code>ListMultimap</code> 的数据也相应地被清空了.</p>
<h3 id="视图"><span class="section-num">3.2</span> 视图</h3>
<p>所谓的视图(Views), 我理解就是看待事物的方式和角度,
称为视图(或者视角&rsquo;perspective&rsquo;).</p>
<p><code>Multimap</code> 提供了若干个有用的视图:</p>
<ol>
<li>
<p><code>asMap</code> 把 <code>Multimap&lt;K,V&gt;</code> 看作一个 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> ,
返回一个的 map 对象支持 <code>remove</code> 操作, 但不支持 <code>put</code> 和 <code>putAll</code>
操作.</p>
<p>值得关注的是: 当对应的 key 不存在的时候, multiMap
返回的是一个新构造的, 为空的集合, 如果你想在对应的 key
不存在的时候返回空指针(就好像 HashMap 那样), 你可以通过
<code>asMap().get(key)</code> 实现这样的效果</p>
</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">asMap</span><span class="p">().</span><span class="na">remove</span><span class="p">(</span><span class="n">alan</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抛出 UnsupportedOperationException 异常</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">asMap</span><span class="p">().</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Lists</span><span class="p">.</span><span class="na">newArrayList</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抛出 UnsupportedOperationException 异常, 除非 anotherScores 是个空的 Map</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">asMap</span><span class="p">().</span><span class="na">putAll</span><span class="p">(</span><span class="n">anotherScores</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 返回空的集合</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Elons</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;Elon&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 返回空指针</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScoresMap</span><span class="p">.</span><span class="na">asMap</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;Elon&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>entries</code> 把 <code>Multimap</code> 内所有的记录(entry)看作
<code>Collection&lt;Map.Entry&lt;K,V&gt;&gt;</code>, 如前文的 <code>studentScoresMap.entries()</code>
返回的就是: <code>[{&quot;Alan&quot;: 95}, {&quot;Alan&quot;: 88}, {&quot;Turing&quot;: 100}]</code>.</li>
<li><code>keySets</code> 把 <code>Multimap</code> 内所有的不重复的 <code>key</code> 看作一个 <code>Set</code> .
如前文的 <code>studentScoresMap.keySets()</code> 返回的就是:
<code>Set([&quot;Alan&quot;,&quot;Turing&quot;])</code>.</li>
<li><code>keys</code> 把 <code>Multimap</code> 内所有的 key 看作一个前文提到的 <code>Multiset</code> ,
可以从这个 <code>Multiset</code> 删除元素, 但不能新增元素, 如前文的
<code>studentScoresMap.keys()</code> 返回的就是:
<code>Multiset([&quot;Alan&quot;,&quot;Alan&quot;, &quot;Turing&quot;])</code>.</li>
<li><code>values()</code> 把 <code>Multimap</code> 内所有的 value 看作一个集合, 相当于把所有 key
对应的 value 集合串联起来, 如前文的 <code>studentScoresMap.values()</code>
返回的就是: <code>[95, 88, 100]</code></li>
</ul>
<h3 id="multimap-也不是一个-map"><span class="section-num">3.3</span> Multimap 也不是一个 Map</h3>
<p>严格来说, 即使 <code>Multimap</code> 名字中带有 map, 甚至 <code>map</code> 可能用来实现
<code>Multimap</code> , 但一个 <code>Multimap&lt;K,V&gt;</code> 终究不是一个
<code>Map&lt;K, Collection&lt;V&gt;&gt;</code>. 它们之间的差异包括:</p>
<ol>
<li><code>Multimap.get(key)</code> 返回的对象总是不为空指针的, 即使查询的 key
不存在, 返回的是个空的集合. 而 <code>Map.get(key)</code> 查询的 key 不存在,
返回的就是空指针. 前文提到过, 如果想要让 <code>Multimap</code> 在查询 key
不存在的时候返回空指针, 可以使用 <code>Multimap.asMap().get(key)</code>.</li>
<li><code>Multimap.containsKey(key)</code> 在 values 集合为空的时候就会返回 false,
例如
<code>studentScoresMap.putAll(&quot;elon&quot;, Lists.newArrayList()); Assert.assertFalse(studentScoresMap.containsKey(&quot;elon&quot;))</code>,
但对于 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 而言, 返回的就会是 true, 因为 value
不为 null.</li>
<li><code>Multimap.size()</code> 返回的是所有记录的总数的, 即把所有的 value
的数量累加起来, 而 <code>Map&lt;K, Colleciton&lt;V&gt;&gt;</code> 返回的就是 key 对应的数量.</li>
</ol>
<h3 id="实现"><span class="section-num">3.4</span> 实现</h3>
<p><code>Multimap</code> 提供了若干个不同类型的实现, 你可以使用对应的实现来取代原来
<code>Map&lt;K, Collection&lt;V&gt;&gt;</code> 的地方:</p>
<table>
<thead>
<tr>
<th>实现</th>
<th>key 表现得类似&hellip;</th>
<th>value 表现得类似&hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ArrayListMultimap.html">ArrayListMultimap</a></td>
<td>HashMap</td>
<td>ArrayList</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashMultimap.html">HashMultimap</a></td>
<td>HashMap</td>
<td>HashSet</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/LinkedListMultimap.html">LinkedListMultimap</a></td>
<td>LinkedHashMap</td>
<td>LinkedList</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/LinkedHashMultimap.html">LinkedHashMultimap</a></td>
<td>LinkedHashMap</td>
<td>LinkedHashSet</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeMultimap.html">TreeMultimap</a></td>
<td>TreeMap</td>
<td>TreeSet</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableListMultimap.html">ImmutableListMultimap</a></td>
<td>ImmutableMap</td>
<td>ImmutableList</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableSetMultimap.html">ImmutableSetMultimap</a></td>
<td>ImmutableMap</td>
<td>ImmutableSet</td>
</tr>
</tbody>
</table>
<p>上述的实现, 除了不可变的实现之外, 其他都支持 <code>null key</code> 与 <code>null value</code>.
并非所有的实现底层用的都是 <code>Map&lt;K, Collection&lt;V&gt;&gt;</code>,
有好几个实现出于性能的考虑, 实现了自定义的 hash 表.</p>
<p><code>Multimap</code> 还支持自定义 value 的集合形式, 如 List 形式或者 Set 形式, 详情可见
<a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/Multimaps.html#newMultimap-java.util.Map-com.google.common.base.Supplier-"><code>Multimaps.newMultimap(Map, Supplier&lt;Collection&gt;)</code></a></p>
<h2 id="bimap"><span class="section-num">4</span> BiMap</h2>
<p>继续假设, 你是个班主任, 你有个学生名字与学号的名单,
你有时会通过名字查询对应学号, 有时又会根据学号反查询学生名字, 通常来说,
你会这么实现这个名单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nameToId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maps</span><span class="p">.</span><span class="na">newHashMap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">idToName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maps</span><span class="p">.</span><span class="na">newHashMap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">nameToId</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;Linus&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;0001&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idToName</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Linus&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 如果 0001 这个学号, 或者 Linus 这个名字已经存在了, 会发生什么事情呢?</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 会出现很微妙的 bug, 为了避免出现这种情况, 你需要手动维护这种限制</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不得不说, 通过两个 Map 和实现 <code>value</code> 反查 <code>key</code> 的传统做法并不优雅,
即增加了心理负担, 又容易出 bug.</p>
<p>幸运的是, Guava 有一个名为 <code>BiMap</code> 类库, 提供了通过 <code>value</code> 也反查 <code>key</code> 的特性.
一个=BiMap&lt;K,V&gt;=是一个=Map&lt;K,V&gt;=, 提供了如下功能:</p>
<ol>
<li>允许通过 <code>inverse()</code> 函数调转 key-value, 从 <code>Map&lt;K,V&gt;</code> 变成
<code>Map&lt;V,K&gt;</code></li>
<li>保证所有的 <code>value</code> 都是唯一的, <code>values()</code> 函数返回一个包含所有
<code>value</code> 的 Set</li>
<li>如果 <code>value</code> 已经存在, 那么 <code>BiMap.put(key,value)</code> 会抛出一个
<code>IllegalArgumentException</code> 异常, 如果想强制删除掉原来的 <code>value</code> ,
并插入一对新的 key-value, 可以使用
<a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/BiMap.html#forcePut-java.lang.Object-java.lang.Object-"><code>Bimap.forcePut(key,value)</code></a></li>
</ol>
<h3 id="bimap-例子"><span class="section-num">4.1</span> BiMap 例子</h3>
<p>让我们用 BiMap 来重新实现学生名字和学号的名单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BiMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">userId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashBiMap</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">userId</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;Linus&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;0001&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">userId</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;Linus&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 反向查询, 通过学号查询名字.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">idForUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">userId</span><span class="p">.</span><span class="na">inverse</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抛出异常: java.lang.IllegalArgumentException: value already present: 0001</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">userId</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;RMS&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;0001&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bimap-实现"><span class="section-num">4.2</span> BiMap 实现</h3>
<table>
<thead>
<tr>
<th>key-value map 实现</th>
<th>value-key map 实现</th>
<th>对应的 BiMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>HashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashBiMap.html"><code>HashBiMap</code></a></td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableBiMap.html"><code>ImmutableBiMap</code></a></td>
</tr>
<tr>
<td>EnumMap</td>
<td>EnumMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/EnumBiMap.html"><code>EnumBiMap</code></a></td>
</tr>
<tr>
<td>EnumMap</td>
<td>HashMap</td>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/EnumHashBiMap.html"><code>EnumHashBiMap</code></a></td>
</tr>
</tbody>
</table>
<h2 id="table"><span class="section-num">5</span> Table</h2>
<p>假设还是个班主任, 现在你需要制作一个包含学号, 姓名与成绩的名单,
然后可以通过姓名或者学号进搜索, 你会怎么实现呢? 什么? 用 excel?
你好幽默啊!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// key: 学号, value: {姓名: 成绩}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">studentScores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maps</span><span class="p">.</span><span class="na">newHashMap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">linus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maps</span><span class="p">.</span><span class="na">newHashMap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">linus</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;Linus&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">99</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">studentScores</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">linus</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 通过学号获取成绩</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">studentScores</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">).</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">studentScores</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">).</span><span class="na">entrySet</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="na">getKey</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Integer</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 通过姓名获取成绩</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">studentScores</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="na">getKey</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nameScores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nameScores</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="s">&#34;Linus&#34;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nameScores</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;Linus&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不得不说, 用 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code> 的形式来实现多 key 搜索非常难受,
算法效率变为 O(n), 线性时间复杂度, 不但不优雅, 还容易出错,
如果我是班主任, 我就辞职了, 给我个 excel 不行么?</p>
<p>excel 是没有的了, 但是 Guava 提供了一个类 excel 的多 key 存储/搜索的容器: <code>Table</code>,
它支持以行和列维度搜索.</p>
<h3 id="table-例子"><span class="section-num">5.1</span> Table 例子</h3>
<p>让我们用 <code>Table</code> 重新实现一次可根据姓名与学号进行搜索的成绩单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 从左到右各列分别是: 学号, 姓名, 成绩</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Table</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">idNameScoreTranscript</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashBasedTable</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idNameScoreTranscript</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Linus&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">99</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idNameScoreTranscript</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;0002&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Aaron&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idNameScoreTranscript</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;RMS&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">98</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idNameScoreTranscript</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;0004&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;RMS&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">97</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">/// 返回结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">/// Linus: 99</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">/// RMS: 98</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idNameScoreTranscript</span><span class="p">.</span><span class="na">row</span><span class="p">(</span><span class="s">&#34;0001&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">/// 返回结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">/// 0001: 98</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">/// 0004: 97</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">idNameScoreTranscript</span><span class="p">.</span><span class="na">column</span><span class="p">(</span><span class="s">&#34;RMS&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>正常来说, 不会有两个学号一样的学生, 只是为了展示 <code>Table</code>
用法而这样造数据. <code>row</code>, <code>column</code> 函数可能让人比较迷惑,
这两个函数是怎么搜索的?</p>
<p>其实很简单, <code>row</code> 是以第一个 key 来搜索, 而 <code>column</code> 以第二个 key 来搜索, 如图:</p>
<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/guava_table_row.png"
         alt="Figure 2: row: 以第一个 key 来搜索"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>row: 以第一个 key 来搜索</p>
        </figcaption>
</figure>

<figure>
    <img loading="lazy" src="https://raw.githubusercontent.com/ramsayleung/images/master/guava_table_column.png"
         alt="Figure 3: column: 以第二个 key 来搜索"/> <figcaption>
            <p><span class="figure-number">Figure 3: </span>column: 以第二个 key 来搜索</p>
        </figcaption>
</figure>

<h3 id="table-视图"><span class="section-num">5.2</span> Table 视图</h3>
<p>一往常, <code>Table</code> 也提供了若干个视图:</p>
<ol>
<li><code>rowMap()</code>, 把 <code>Table&lt;R, C, V&gt;</code> 看作一个 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code>, 同样的,
<code>rowKeySet()=返回一个=Set&lt;R&gt;</code>.</li>
<li><code>row(r)</code> 返回一个非空的 <code>Map&lt;C, V&gt;</code> 的引用, 对返回的 Map
的修改也会反馈给持有该引用 <code>Table</code>.</li>
<li>类似地, <code>column(c)</code> 返回一个非空的 <code>Map&lt;R, V&gt;</code> 的引用, 对返回的 Map
的修改也会反馈给持有该引用 <code>Table</code>.</li>
<li><code>cellSet()</code> 把=Table&lt;R, C, V&gt;=看作一个 <code>Table.Cell&lt;R, C, V&gt;</code>, <code>Cell</code>
与 <code>Map.Entry</code> 十分类似, 只不过它有两个 key, 形式是 <code>(r,c)=v</code>, 而
<code>Map.Entry</code> 是 <code>key = value</code>.</li>
</ol>
<h3 id="table-实现"><span class="section-num">5.3</span> Table 实现</h3>
<p>Table 依旧提供了若干个实现, 列表如下:</p>
<table>
<thead>
<tr>
<th>Table&lt;R, C, V&gt;</th>
<th>类似的 Map&lt;R, Map&lt;C, V&gt;&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/HashBasedTable.html"><code>HashBasedTable</code></a></td>
<td>HashMap&lt;R, HashMap&lt;C, V&gt;&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeBasedTable.html"><code>TreeBasedTable</code></a></td>
<td>TreeMap&lt;R, TreeMap&lt;C, V&gt;&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableTable.html"><code>ImmutableTable</code></a></td>
<td>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ArrayTable.html"><code>ArrayTable</code></a></td>
<td>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;, 特别的一个</td>
</tr>
</tbody>
</table>
<h2 id="classtoinstancemap"><span class="section-num">6</span> ClassToInstanceMap</h2>
<p>目前, 我们介绍过的 Map, 无论是原生 Jdk 的 Map, 抑或是 Guava 的 Map,
<code>key</code> 都是同一个类型的.</p>
<p>这是因为 Map 的签名是 <code>Map&lt;K,V&gt;</code>, 实例的时候, 只能实例成某具体一个类型的参数. 所谓凡事都有例外, 有没有支持 <code>key</code>
是不同类型的 map 呢? 自然是有的, Guava 的
<a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ClassToInstanceMap.html"><code>ClassToInstanceMap</code></a>
就可以支持多个类型的 key.</p>
<p>为什么它可以实现多个类型的 <code>key</code> 呢? 因为 <code>ClassToInstanceMap</code> 的签名声明为 <code>Map&lt;Class&lt;? extends B&gt;, B&gt;</code>,
通过传入不同类型的 <code>Class</code> 对象, 实现类型不同的 =key=(如果你要说,
即使传入不同类型的 Class 对象, 它只有一个 Class, 没有实现多个不同类型的
key 阿! 你也可以这样理解, well, 咬文嚼字就没有什么意义了)</p>
<h3 id="classtoinstancemap-例子"><span class="section-num">6.1</span> ClassToInstanceMap 例子</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ClassToInstanceMap</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numberDefault</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MutableClassToInstanceMap</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">numberDefault</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">Integer</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">numberDefault</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">Long</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">20L</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 编译失败</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//numberDefault.put(String.class, &#34;string&#34;);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">Long</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">20L</span><span class="p">),</span><span class="w"> </span><span class="n">numberDefault</span><span class="p">.</span><span class="na">getInstance</span><span class="p">(</span><span class="n">Long</span><span class="p">.</span><span class="na">class</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果查看源码, 可以发现, <code>ClassToInstanceMap&lt;B&gt;</code> 只有一个类型参数 <code>B</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ClassToInstanceMap</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>很明显的, 类型 <code>B</code> 限制了 <code>key</code> 与 <code>value</code> 的类型。</p>
<p>对于 <code>value</code> 的限制,
就和常规的 <code>map</code> 一样; 而对于 <code>key</code> 而言, 泛型实例化时的参数类型只能是
<code>B</code>, 或者是 <code>B</code> 的子类, 例如: <code>ClassToInstanceMap&lt;Number&gt;</code>, 那么这个 map
的 <code>key</code> 类型必须是 <code>Number</code> 或 <code>Number</code> 的子类, 而传入的 <code>Integer</code> 和
<code>Long</code> 都是 <code>Number</code> 子类, 因此能编译通过。</p>
<p>如果传入的是 <code>String,</code> 不符合声明, 编译就报错了.</p>
<p><strong>需要注意的是, 和 <code>Map&lt;Class, Object&gt;</code> 一样, 一个 <code>ClassToInstanceMap</code> 可以包含着是原始类型的 <code>value</code>,
而原始类型与它对应的包装类型并不是同一种类型, 不要混淆了哦</strong></p>
<h3 id="classtoinstancemap-实现"><span class="section-num">6.2</span> ClassToInstanceMap 实现</h3>
<p><code>ClassToInstanceMap</code> 提供了两个实现:</p>
<table>
<thead>
<tr>
<th>ClassToInstanceMap</th>
<th>类似的 Map</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/MutableClassToInstanceMap.html"><code>MutableClassToInstanceMap</code></a></td>
<td>Map&lt;Class, Object&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableClassToInstanceMap.html"><code>ImmutableClassToInstanceMap</code></a></td>
<td>ImmutableMap&lt;Class,Object&gt;</td>
</tr>
</tbody>
</table>
<h2 id="rangeset"><span class="section-num">7</span> RangeSet</h2>
<p>目前为止, 我们介绍过的新类型容器都是常见的 Map/Set/Table,
现在我们就来介绍一个表示区间的容器: <code>RangeSet</code>. 一个 <code>RangeSet</code>,
表示一个包含无连接的, 不为空的区间的集合, 例如包含一个整数区间的
<code>RangeSet</code>: <code>{[1,5], [7,9)}</code>.</p>
<p>在 <code>RangeSet</code> 中, 区间是由类 <code>Range</code> 来表示的, 当把一个区间加入到一个可变的 <code>RangeSet</code> 时,
任何有交集的区间都会被合并, 为空的区间就会被忽略, 例如将区间 <code>[3,5]</code>
加入到已有的 <code>RangeSet</code> <code>{[2,4]}</code>, 就会被合并成 <code>{[2,5]}</code>,
这个也符合我们日常的生活经验.</p>
<h3 id="rangeset-例子"><span class="section-num">7.1</span> RangeSet 例子</h3>
<p>让我们现在来看一下 <code>RangeSet</code> 的两个例子, 一个是整数的 <code>RangeSet</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RangeSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rangeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TreeRangeSet</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[2,4]}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">4</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[2,5]}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">5</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[1,10]}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">10</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 无连接上的区间: {[1,10], [11,15)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closedOpen</span><span class="p">(</span><span class="n">11</span><span class="p">,</span><span class="w"> </span><span class="n">15</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 连接上的区间; {[1,10], [11,20)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closedOpen</span><span class="p">(</span><span class="n">15</span><span class="p">,</span><span class="w"> </span><span class="n">20</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 空区间, 被忽略; {[1,10],[11,20)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">openClosed</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 分割区间 [1,10]; {[1,5],[10,10],[11,20)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">open</span><span class="p">(</span><span class="n">5</span><span class="p">,</span><span class="w"> </span><span class="n">10</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中, <code>[2,4]</code> 和 <code>[3,5]</code> 这两个区间有交集,
所以它们被自动合并到一起了, 而对于区间 <code>[1,10]</code> 和 <code>[11,15)</code>, 10
相邻的整数就是 11, 但两个区间也没有合并起来, 因为它们没有相交,
如果想要他们合并起来, 可以手动调用 <code>Range.canonical(DiscreteDomain)</code>,
即:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// {[1,10]}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">10</span><span class="p">).</span><span class="na">canonical</span><span class="p">(</span><span class="n">DiscreteDomain</span><span class="p">.</span><span class="na">integers</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 连接上的区间: {[1,15)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closedOpen</span><span class="p">(</span><span class="n">11</span><span class="p">,</span><span class="w"> </span><span class="n">15</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>另外一个例子是日期的 <code>RangeSet</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RangeSet</span><span class="o">&lt;</span><span class="n">LocalDate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rangeSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TreeRangeSet</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[2019-10-10, 2019-12-25]}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-10&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-12-25&#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[2019-10-10, 2019-12-30)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closedOpen</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-12-24&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-12-30&#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertTrue</span><span class="p">(</span><span class="n">rangeSet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeSet</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-30&#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertFalse</span><span class="p">(</span><span class="n">rangeSet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// [2019-11-10,2019-11-25] 在 `{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}`的区间包围内</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertTrue</span><span class="p">(</span><span class="n">rangeSet</span><span class="p">.</span><span class="na">encloses</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-11-11&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-11-20&#34;</span><span class="p">))));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closedOpen</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-10&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-20&#34;</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">rangeSet</span><span class="p">.</span><span class="na">rangeContaining</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-19&#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[2019-10-10, 2019-12-30)}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Range</span><span class="o">&lt;</span><span class="n">LocalDate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">span</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rangeSet</span><span class="p">.</span><span class="na">span</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-10-10&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">span</span><span class="p">.</span><span class="na">lowerEndpoint</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">LocalDate</span><span class="p">.</span><span class="na">parse</span><span class="p">(</span><span class="s">&#34;2019-12-30&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">span</span><span class="p">.</span><span class="na">upperEndpoint</span><span class="p">());</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>RangeSet</code> 提供了若干个查询函数, 用法在上面的代码已经展示了,
查询函数列表:</p>
<ul>
<li><code>contains(C)</code>: <code>RangeSet</code> 最基础的查询操作, 判断任意的元素是否在
<code>RangeSet</code> 内.</li>
<li><code>rangeContaining(C)</code>: 与 <code>contains(C)</code> 类似, 判断任意的元素是否在
<code>RangeSet</code> 内, 如果在的话返回一个对应的区间, 否则返回空指针. 如上代码,
有 <code>RangeSet</code>: <code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>,
而元素 <code>2019-10-19</code> 在区间 <code>[2019-10-10, 2019-10-20)</code> 内, 因此
<code>rangeContaining(C)</code> 函数返回的就是 <code>[2019-10-10, 2019-10-20)</code>.</li>
<li><code>encloses(Range&lt;C&gt;)</code>: 判断任意的区间是否在 <code>RangeSet</code> 的包围中.</li>
<li><code>span</code>: 返回一个最小区间, 包含 <code>RangeSet</code> 中的所有区间, 如有:
<code>RangeSet</code>: <code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>,
<code>span</code> 函数返回的区间就是 <code>{[2019-10-10, 2019-12-30)}</code>.</li>
</ul>
<h3 id="rangeset-视图"><span class="section-num">7.2</span> RangeSet 视图</h3>
<p>依照惯例, <code>RangeSet</code> 也提供了若干个视图:</p>
<ul>
<li><code>complement()</code>: 返回某个 <code>RangeSet</code> 的补集, 返回结果也是个 <code>RangeSet</code>,
如有 <code>RangeSet</code>:
<code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>, 那它的补集就是:
<code>RangeSet</code>:
<code>{(-∞,2019-10-10), [2019-10-20,2019-10-30], [2019-12-30,+∞)}</code>,
分别是三个区间: 负无穷到 <code>2019-10-10</code>, <code>2019-10-20</code> 到 <code>2019-10-30</code>,
以及 <code>2019-12-30</code> 到正无穷.</li>
<li><code>subRangeSet(Range&lt;C&gt;)</code>: 返回某个 <code>RangeSet</code> 相交的子区间, 如有
<code>RangeSet</code>: <code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>,
取子区间 <code>[2019-11-10,2019-11-20]</code>, 那么返回结果就是
<code>{[2019-11-10, 2019-11-20]}</code>; 如果取子区间 <code>[2019-10-15, 2019-11-20]</code>,
那么返回结果就是
<code>{[2019-10-10, 2019-10-20), (2019-10-30, 2019-11-20]}</code></li>
<li><code>asRanges()</code>: 把 <code>RangeSet</code> 当作一个 <code>Set&lt;Range&lt;C&gt;&gt;</code>, 如有 <code>RangeSet</code>:
<code>{[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)}</code>, 返回结果就是:
<code>Set({[2019-10-10,2019-10-20), (2019-10-30, 2019-12-30)})</code></li>
</ul>
<h3 id="rangeset-实现"><span class="section-num">7.3</span> RangeSet 实现</h3>
<p><code>RangeSet</code> 提供了两个实现:</p>
<table>
<thead>
<tr>
<th><code>RangeSet</code></th>
<th>类似的 Set&lt;Range&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeRangeSet.html"><code>TreeRangeSet</code></a></td>
<td>TreeSet&lt;Range&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableRangeSet.html"><code>ImmutableRangeSet</code></a></td>
<td>ImmutableSet&lt;Range&gt;</td>
</tr>
</tbody>
</table>
<h2 id="rangemap"><span class="section-num">8</span> RangeMap</h2>
<p>既然能以区间集作为容器, 那么能否把区间当作 Map 的 <code>key</code> 呢?
答案是当然可以, Guava 就提供了一个这样的容器: <a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/RangeMap.html"><code>RangeMap</code></a>.</p>
<p>需要注意的是, 不像 <code>RangeSet</code> 那样, 相邻或者相交的区间不能连接起来的,
即使毗邻的区间映射的是同一个 <code>value</code>.</p>
<h2 id="rangemap-例子"><span class="section-num">9</span> RangeMap 例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">RangeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rangeMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TreeRangeMap</span><span class="p">.</span><span class="na">create</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[1,10] =&gt; &#34;foo&#34;}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">10</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;foo&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[1, 3] =&gt; &#34;foo&#34;, (3, 6) =&gt; &#34;bar&#34;, [6, 10] =&gt; &#34;foo&#34;}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">open</span><span class="p">(</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">6</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;bar&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[1, 3] =&gt; &#34;foo&#34;, (3, 6) =&gt; &#34;bar&#34;, [6, 10] =&gt; &#34;foo&#34;, (10,20) =&gt; &#34;foo&#34;}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">open</span><span class="p">(</span><span class="n">10</span><span class="p">,</span><span class="w"> </span><span class="n">20</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;foo&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[1, 3] =&gt; &#34;foo&#34;, (3, 5) =&gt; &#34;bar&#34;, (11, 20) =&gt; &#34;foo&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">rangeMap</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">5</span><span class="p">,</span><span class="w"> </span><span class="n">11</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertSame</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">rangeMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">3</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Range</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">span</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rangeMap</span><span class="p">.</span><span class="na">span</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">span</span><span class="p">.</span><span class="na">lowerEndpoint</span><span class="p">(),</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">span</span><span class="p">.</span><span class="na">upperEndpoint</span><span class="p">(),</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">20</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// {[12, 15]} =&gt; &#34;foo&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">RangeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">subRangeMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rangeMap</span><span class="p">.</span><span class="na">subRangeMap</span><span class="p">(</span><span class="n">Range</span><span class="p">.</span><span class="na">closed</span><span class="p">(</span><span class="n">12</span><span class="p">,</span><span class="w"> </span><span class="n">15</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">subRangeMap</span><span class="p">.</span><span class="na">span</span><span class="p">().</span><span class="na">lowerEndpoint</span><span class="p">(),</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">12</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">subRangeMap</span><span class="p">.</span><span class="na">span</span><span class="p">().</span><span class="na">upperEndpoint</span><span class="p">(),</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">15</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">subRangeMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">12</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>RangeMap</code> 提供的查询函数不多, 满打满算也只有 <code>get(K)</code> 和 <code>span</code>
这两个函数.</p>
<h3 id="rangemap-视图"><span class="section-num">9.1</span> RangeMap 视图</h3>
<p><code>RangeMap</code> 提供的视图也不多, 只有两个:</p>
<ul>
<li><code>asMapOfRanges()</code>, 把 <code>RangeMap</code> 看作一个 <code>Map&lt;Range&lt;K&gt;, V&gt;</code>,
可以用来遍历 <code>RangeMap</code></li>
<li><code>subRangeMap(Range&lt;K&gt;)</code>, 返回某个 <code>RangeMap</code>
相关区间的子区间以及对应的 <code>value</code>, 如有 <code>RangeMap</code>:
<code>{[1, 3] =&gt; &quot;foo&quot;, (3, 5) =&gt; &quot;bar&quot;, (11, 20) =&gt; &quot;foo&quot;</code>, 取子区间
<code>[12,15]</code>, 返回结果就是 <code>{[12, 15]} =&gt; &quot;foo&quot;</code>; 如果取子区间=[4,12]=,
返回结果就是: <code>{[4,5) =&gt; bar, (11, 12] =&gt; foo}</code></li>
</ul>
<h3 id="rangemap-实现"><span class="section-num">9.2</span> RangeMap 实现</h3>
<p>RangeMap 提供了两个实现:</p>
<table>
<thead>
<tr>
<th>RangeMap</th>
<th>类似的 Map&lt;Range, V&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/TreeRangeMap.html">TreeRangeMap</a></td>
<td>TreeMap&lt;Range, V&gt;</td>
</tr>
<tr>
<td><a href="https://guava.dev/releases/snapshot/api/docs/com/google/common/collect/ImmutableRangeMap.html">ImmutableRangeMap</a></td>
<td>ImmutableMap&lt;Range&lt;K, V&gt;&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="总结"><span class="section-num">10</span> 总结</h2>
<p>介绍完新类型的容器之后, 希望大家对这些新类型容器熟悉起来, 应对需求来也能得心应手 :)</p>
]]></content:encoded>
    </item>
    <item>
      <title>guava探究系列之四：不可变容器</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 05 Sep 2019 15:36:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8/</guid>
      <description>1 前言 先此声明, 个人倾向于将 Collection 翻译成容器, 将 Set 翻译成集合. 已经许久没有更新Guava研读系列的文章, 今天要介绍的是Guava的不可变容器. 2</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>先此声明, 个人倾向于将 <code>Collection</code> 翻译成容器, 将 <code>Set</code> 翻译成集合.</p>
<p>已经许久没有更新Guava研读系列的文章, 今天要介绍的是Guava的不可变容器.</p>
<h2 id="关于不可变对象"><span class="section-num">2</span> 关于不可变对象</h2>
<p>不可变的对象有许多的优点, 如下:</p>
<ol>
<li>线程安全, 可以在多线程之间使用也不用担心有竞争条件的风险</li>
<li>可以放心地用于不被信任的第三方类库</li>
<li>不用考虑支持可变性, 无需额外的空间和时间消耗.</li>
<li>可用作常量使用</li>
</ol>
<p>使用对象的不可变拷贝是一项良好的编程防御策略, 为此,
Guava提供了许多简单易用的, 实现了标准库 <code>Collection</code> 接口的不可变容器,
当然也包括实现了他们自家 <code>Collection</code> 接口的不可变容器.</p>
<p>虽然通过JDK的静态方法 <code>Collection.unmodifiableXXX</code> 可以使用内置不可变容器,
但是在Guava团队的同学看来,
它们有若干的不足(又到了喜闻乐见的黑JDK的环节):</p>
<ol>
<li>笨重; 使用起来很笨重, 不够赏心悦目和优雅.</li>
<li>不安全;
上述静态方法返回的容器只有在没有对象持有原来容器的情况下才是真正不可变的.
例如,
当想要通过可变Map <code>ids</code> 来生成一个不可变Map的时候, <code>Collections.unmodifiableMap(ids)</code>,
如果有多个对象持有 <code>ids</code> 时, 静态方法返回的对象就不是真正的不可变.
具体的分析可以参考<a href="https://stackoverflow.com/questions/22636575/unmodifiablemap-java-collections-vs-immutablemap-google/22636674">StackOverFlow关于unmodifiableMap和ImmutableMap的讨论</a></li>
<li>低效; 静态方法生成的不可变容器和可变容器有着同样的性能开销,
包括并发修改, 动态扩容等(对于真正的不可变容器而言,
这些都是不会出现的操作)</li>
</ol>
<p>综上所述, 如果你不想修改某个容器, 或者你想把某个容器当作不可变常量,
把这个容器变成一个不可变容器是一个很好的手段(使用Guava的不可变容器).</p>
<p>此外, 在之前的文章中, 我阐述过Guava对于空指针的态度是尽量不要使用空指针,
Guava的类库对于空指针都是快速失败的, Guava的不可变容器也是不例外的,
是拒绝接受空指针的.</p>
<h2 id="代码实例"><span class="section-num">3</span> 代码实例</h2>
<p>前面详细介绍了不可变容器, 现在是时候来看一下Guava不可变容器的代码例子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">COLOR_NAMES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                                                       </span><span class="s">&#34;red&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                                                       </span><span class="s">&#34;orange&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                                                       </span><span class="s">&#34;purple&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bars</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bars</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">bars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">bars</span><span class="p">);</span><span class="w"> </span><span class="c1">// defensive copy!</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>前文提到的, <code>Collections.unmodifiableXXX(mutableXXX)</code> ,
Collections方法不能提供真正的不可变容器,
除非没有对象持有可变对象 <code>mutableXXX</code> 的引用</p>
<p>那么Guava的不可变容器又是否是真正的不可变呢? 以 <code>ImmutableSet</code> 为例,
发现所有可以修改 <code>ImmutableSet</code> 对象的操作函数,
包括 <code>add</code> , <code>remove</code> , <code>addAll</code> , <code>removeAll</code> 等函数都被重载,
然后标注成 <code>@Deprecated</code> ,
重载函数的内容就是抛出 <code>UnsupportedOperationException</code> 异常,
所以不可能修改 <code>ImmutableSet</code> 对象的内容:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Guaranteed to throw an exception and leave the collection unmodified.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws UnsupportedOperationException always
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @deprecated Unsupported operation.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Deprecated</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">E</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">UnsupportedOperationException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>至于持有 <code>mutableXXX</code> 对象引用,
修改 <code>mutableXXX</code> 对象内容导致不可变内容发生改变的情况也不会发生:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testImmutable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">colors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sets</span><span class="p">.</span><span class="na">newHashSet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">colors</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;blue&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">modifiableSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Collections</span><span class="p">.</span><span class="na">unmodifiableSet</span><span class="p">(</span><span class="n">colors</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unmodifiableSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Collections</span><span class="p">.</span><span class="na">unmodifiableSet</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">colors</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">COLOR_NAMES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">colors</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">colors</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;yellow&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 不会修改不可变集合的值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertFalse</span><span class="p">(</span><span class="n">COLOR_NAMES</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;yellow&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 修改引用导致集合值发生修改</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertTrue</span><span class="p">(</span><span class="n">modifiableSet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;yellow&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 因为没有对象持有new HashSet&lt;&gt;(colors)的引用, 所以unmodifiableSet是不可变集合, 不能修改</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertFalse</span><span class="p">(</span><span class="n">unmodifiableSet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;yellow&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Assert</span><span class="p">.</span><span class="na">assertTrue</span><span class="p">(</span><span class="n">colors</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;yellow&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>查看 <code>ImmutableSet.copyOf(Set&lt;T&gt;)</code> 函数的源码,
发现不可变集合的实现逻辑和在构造函数新建对象实现对象引用拷贝的逻辑一致,
即和 <code>Collections.unmodifiableSet(new HashSet&lt;&gt;(colors))</code> 的逻辑一样的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">copyOf</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="n">elements</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * TODO(lowasser): consider checking for ImmutableAsList here
</span></span></span><span class="line"><span class="cl"><span class="cm">     * TODO(lowasser): consider checking for Multiset here
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">ImmutableSortedSet</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&#34;unchecked&#34;</span><span class="p">)</span><span class="w"> </span><span class="c1">// all supported methods are covariant</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 新建对象, 拷贝对象引用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">set</span><span class="p">.</span><span class="na">isPartialView</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">set</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elements</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">EnumSet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">copyOfEnumSet</span><span class="p">((</span><span class="n">EnumSet</span><span class="p">)</span><span class="w"> </span><span class="n">elements</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">.</span><span class="na">toArray</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">construct</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="具体细节"><span class="section-num">4</span> 具体细节</h2>
<p>下面我们来讨论一下各种不可变容器的具体使用细节.</p>
<h3 id="构造不可变容器"><span class="section-num">4.1</span> 构造不可变容器</h3>
<p>关于如何构造一个不可变容器, Guava提供的手段是多种多样的:</p>
<ol>
<li>使用 <code>copyOf</code> 静态方法, 例如 <code>ImmutableSet.copyOf(set)</code> ,
这种构造方法与JDK不可变容器的构造方式类似 <code>Collections.unmodifiableXXX(mutableXXX)</code></li>
<li>使用 <code>of</code> 静态方法,
例如 <code>ImmutableSet.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)=或者=ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2)</code>,
前文已经介绍过, 在此就不赘言</li>
<li>使用 <code>Builder</code> 构造不可变容器, 例如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GOOGLE_COLORS</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="n">builder</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="na">addAll</span><span class="p">(</span><span class="n">WEBSAFE_COLORS</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">191</span><span class="p">,</span><span class="w"> </span><span class="n">255</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="na">build</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不过某些不可变容器的builder方法废弃了,
如 <code>ImmutableSortedSet</code> 的 <code>builder</code> 方法就被替换成了 <code>naturalOrder</code>.</p>
<p>此外, 对于有序容器(sorted collections)而言,
容器内的元素的顺序是按照构造时元素的插入顺序排列的, 例如如下代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">alphaTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;b&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;c&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;d&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;b&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">alphaTable</span><span class="p">.</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">::</span><span class="n">println</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 结果为 a b c d</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="aslist-函数"><span class="section-num">4.2</span> <code>asList</code> 函数</h3>
<p>所有的不可变容器都提供了一个 <code>asList</code> 方法来返回一个不可变列表 <code>ImmutableList</code>,
所以即使你把数据存在一个不可变有序集合 <code>ImmutableSortedSet</code>,
你也可以通过下标索引获取最小的元素或者第n小的元素, 如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numberSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSortedSet</span><span class="p">.</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="n">naturalOrder</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">4</span><span class="p">,</span><span class="w"> </span><span class="n">5</span><span class="p">,</span><span class="w"> </span><span class="n">6</span><span class="p">).</span><span class="na">build</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">numberSet</span><span class="p">.</span><span class="na">asList</span><span class="p">().</span><span class="na">get</span><span class="p">(</span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">结果为1</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="智能的-copyof-函数"><span class="section-num">4.3</span> 智能的 <code>copyOf</code> 函数</h3>
<p>前文提到,
不可变容器都提供了一个 <code>copyOf</code> 方法用于从另外一个容器构造出一个不可变容器.
值得指出的是不可变容器的 <code>copyOf</code> 方法在不需要拷贝数据的时候就会尽量避免拷贝数据,
但这是什么意思呢? 假如有如下的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foobar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableSet</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;baz&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">thingamajig</span><span class="p">(</span><span class="n">foobar</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">void</span><span class="w"> </span><span class="nf">thingamajig</span><span class="p">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">collection</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">defensiveCopy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImmutableList</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">collection</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的代码调用 <code>ImmutableList.copyOf(foobar)</code> 函数的时候,
函数的内部实现不会逐个拷贝,
而会直接通过 <code>foobar.asList()</code> 函数返回一个不可变值列表,
这样实现的算法时间复杂度就是 <code>O(1)</code> , 而不是 <code>O(n)</code> , 实现性能消耗的最小化,
这也就是小标题智能指的意思.</p>
<p>但是需要注意的是,
并不是所有的不可变容器之间的转换都能实现 <code>O(1)</code> 时间复杂度,
例如 <code>ImmutableSet.copyOf(ImmutableList)</code> 就只能逐个元素拷贝,
时间复杂度退化到 <code>O(n)</code> .</p>
<h2 id="jdk容器与guava不可变容器"><span class="section-num">5</span> JDK容器与Guava不可变容器</h2>
<p>对于JDK提供的标准容器, Guava提供了相应的不可变容器实现,
对于Guava自家的容器, Guava也提供了对应的不可变容器, 具体实现对比如下:</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th>JDK or Guava?</th>
<th>Immutable Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Collection</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableCollection.html"><code>ImmutableCollection</code></a></td>
</tr>
<tr>
<td><code>List</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableList.html"><code>ImmutableList</code></a></td>
</tr>
<tr>
<td><code>Set</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSet.html"><code>ImmutableSet</code></a></td>
</tr>
<tr>
<td><code>SortedSet=/=NavigableSet</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedSet.html"><code>ImmutableSortedSet</code></a></td>
</tr>
<tr>
<td><code>Map</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMap.html"><code>ImmutableMap</code></a></td>
</tr>
<tr>
<td><code>SortedMap</code></td>
<td>JDK</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSortedMap.html"><code>ImmutableSortedMap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#Multiset"><code>Multiset</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultiset.html"><code>ImmutableMultiset</code></a></td>
</tr>
<tr>
<td><code>SortedMultiset</code></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/12.0/api/docs/com/google/common/collect/ImmutableSortedMultiset.html"><code>ImmutableSortedMultiset</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#Multimap"><code>Multimap</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableMultimap.html"><code>ImmutableMultimap</code></a></td>
</tr>
<tr>
<td><code>ListMultimap</code></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableListMultimap.html"><code>ImmutableListMultimap</code></a></td>
</tr>
<tr>
<td><code>SetMultimap</code></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableSetMultimap.html"><code>ImmutableSetMultimap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#BiMap"><code>BiMap</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableBiMap.html"><code>ImmutableBiMap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#ClassToInstanceMap"><code>ClassToInstanceMap</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableClassToInstanceMap.html"><code>ImmutableClassToInstanceMap</code></a></td>
</tr>
<tr>
<td><a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#Table"><code>Table</code></a></td>
<td>Guava</td>
<td><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableTable.html"><code>ImmutableTable</code></a></td>
</tr>
</tbody>
</table>
<h2 id="总结"><span class="section-num">6</span> 总结</h2>
<p>因为不可变容器不会在运行时改变他们的内部状态, 所以他们是线程安全和无副作用的.</p>
<p>因为这些属性, 不可变容器在多线程环境就会变得特别有用, 可以安全地传递数据. 总而言之,
生活和工作或许可以多拥抱变化, 对于代码, 最好还是多保持不变地好.</p>
<h2 id="参考"><span class="section-num">7</span> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/ImmutableCollectionsExplained">Immutable
Collections</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Guava探究系列之三：改善通用方法</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%94%B9%E5%96%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 25 Jul 2019 22:33:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%94%B9%E5%96%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>1 前言 Java 是一门集大成的面向对象语言, 在Java的世界里, 一切皆对象, 而=Object=类就是所有对象的默认父类. Guava 提供了若干个工具方法来扩展</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>Java 是一门集大成的面向对象语言, 在Java的世界里, 一切皆对象, 而=Object=类就是所有对象的默认父类. Guava
提供了若干个工具方法来扩展=Object=类的通用能力.</p>
<h2 id="equals"><span class="section-num">2</span> equals</h2>
<p>在Java的编程世界, 比较两个对象是个很常见的操作, <code>Object=类也提供了一个=equals=方法来判断对象是否相等. 但是=Object=使用的=equals=方法有诸多不便, 最痛苦的是无处不在的=NullPointerException</code>, 例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">testEqueal</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">input</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但当 =this=指针指向一个空对象的时候,
就会出现=null.testEqueal(input)=的情形, 就会抛出NPE.
为了让=equals=方法更易用,
Guava提供了一个=Objects.equal(Object a, Object b)=方法来判断两个对象是否相等.
用法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Objects</span><span class="p">.</span><span class="na">equal</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;a&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Objects</span><span class="p">.</span><span class="na">equal</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;a&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Objects</span><span class="p">.</span><span class="na">equal</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Objects</span><span class="p">.</span><span class="na">equal</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w"> </span><span class="c1">// returns true</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可能是Java语言的开发者也意识到=Object.equals=方法的不便,
所以在JDK7的时候,
官方也提供了=Objects.equals(Object a, Object b)=的方法,
Guava的竞品自然也没了用武之处。</p>
<p>不过, 说实话, 无论是JDK的=Objects.equals=, <code>Object.equal=还是Guava的=Object.equal()</code>,
在日常的开发中也用的不多, 用的最多的是Apache Common库的各种Utils工具,
比较String类型用的是=StringUtils.equals()=,
比较容器(Collection)用的=CollectionUtils.isEqualCollection()=,
毕竟这些工具要更高级和完善(有趣的是, JDK的方法名是=equals=,
Guava的方法名是=equal=, 下文提到的JDK的hash方法名叫=hash=,
Guava叫=hashCode=).</p>
<h3 id="hashcode"><span class="section-num">2.1</span> hashCode</h3>
<p>在《Effective Java》的条款9中说到:</p>
<blockquote>
<p>Always override <code>hashCode</code> when you override <code>equals</code></p>
</blockquote>
<p>就是说在你重写=equals=方法的时候, 记得重写=hashCode=方法,
因为按照Java的约定, 如果两个对象通过调用=equals=方法判断是相等的话,
它们调用=hashCode()=方法的返回结果也是一样的.</p>
<p>《Effective Java》 给出的重写建议是把一个对象的所有字段进行计算取得一个hash值,
示例代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hashCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">passport</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hashCode</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hashCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">17</span><span class="p">;</span><span class="w"> </span><span class="c1">// Aribtrary number.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">31</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="na">hashCode</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">31</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"> </span><span class="c1">// 31 is an odd prime</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">31</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">passport</span><span class="p">.</span><span class="na">hashCode</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">hashCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">hashCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样的计算方式虽然有效, 但是未免过于烦琐, 还要手动计算每个字段. 为此,
Guava 提供了一个 =Objects.hashCode(field1, field2, &hellip;, fieldn=的方法,
用于对所有的字段计算hash值, 用法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hashCode</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Objects</span><span class="p">.</span><span class="na">hashCode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">passport</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>看起来简洁多了。然后在Java7的时候,
JDK也推出了一个=Objects.hash(field1, field2,&hellip;,fieldn)=的方法,
而Guava的竞品很快就被废弃了. 我都在想JDK是不是在吸收Guava的精华,
毕竟实现都一样！(￣▽￣)</p>
<h2 id="tostring"><span class="section-num">3</span> toString</h2>
<p>《Effective Java》的条款10说到:</p>
<blockquote>
<p>Always override toString</p>
</blockquote>
<p>也就是说, 《Effective Java》建议所有的类都重写=toString()=方法.
其实=toString()=方法不是给程序看的, 而是给开发者自己看的.</p>
<p>据说, 好看的=toString()=方法的输出结果可以让程序员更愉悦, 可见颜值处处都有用.
比较常见的重写=toString()=的方式是把所有的字段拼接输出,
只不过手动拼接有点累.</p>
<p>省心的是, Intellij Idea 为开发者提供了生成=toString()=的快捷方式, 如下图:</p>
<figure><a href="/ox-hugo/Idea_generate_to_string.gif">
    <img loading="lazy" src="/ox-hugo/Idea_generate_to_string.gif"
         alt="Figure 1: Idea生成toString"/> </a><figcaption>
            <p><span class="figure-number">Figure 1: </span>Idea生成toString</p>
        </figcaption>
</figure>

<p>如果觉得Idea生成的=toString()=有太多的拼接字符串,
还可以试试Guava提供的=toString()=工具方法: <code>MoreObjects.toStringHelper</code>,
具体用法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">MoreObjects</span><span class="p">.</span><span class="na">toStringHelper</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Linus&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="p">.</span><span class="na">toString</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">MoreObjects</span><span class="p">.</span><span class="na">toStringHelper</span><span class="p">(</span><span class="s">&#34;TestToStringHelper&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;method&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;toStringHelper&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="p">.</span><span class="na">toString</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 结果如下:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// ToStringTest{name=Linus}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// TestToStringHelper{method=toStringHelper}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用方法也是很明了, 就不过多赘述.</p>
<h2 id="compare-compareto"><span class="section-num">4</span> compare/compareTo</h2>
<p>既然前面提到了《Effective Java》, 那么基于前后呼应的原则,
最后也免不了要再引用一下《Effective Java》:</p>
<blockquote>
<p>条款12: Consider implementing Comparable</p>
</blockquote>
<p>不像前文介绍过的方法, =compareTo=方法并不是=Object=类的方法,
而是=Comparable=接口的方法. 这个方法和前文提到的=equals=方法类似,
只不过用法不一样. =compareTo=通常用于排序,
如下面的代码就是对实现了Comparable接口的Person对象的列表进行排序:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">lastName</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">firstName</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zipCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">Person</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lastName</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="na">lastName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">cmp</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstName</span><span class="p">.</span><span class="na">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="na">firstName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cmp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">cmp</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="n">zipCode</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="na">zipCode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CompareTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testSort</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Person</span><span class="o">[]</span><span class="w"> </span><span class="n">persons</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="o">[</span><span class="n">2</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">persons</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="s">&#34;Ma&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Jack&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">12345</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">persons</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="s">&#34;Ma&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Pony&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">65432</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Arrays</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">persons</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Arrays</span><span class="p">.</span><span class="na">stream</span><span class="p">(</span><span class="n">persons</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">person</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="na">getFirstName</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码的逻辑就是先比较=Person.lastName=,
如果相等再比较=Person.firstName=, 如果前面的条件还是相等,
就再比较=Person.zipCode=.</p>
<p>代码的含义相当清晰, 只是有不少的模板代码, 如果能减少这些模板代码, 那就更好了. 幸运的是, Guava 提供了一个
=ComparisonChain=来处理这些模板逻辑, 应用=ComparisonChain=之后的代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ComparisonChainPerson</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">ComparisonChainPerson</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">lastName</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">firstName</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zipCode</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">compareTo</span><span class="p">(</span><span class="n">ComparisonChainPerson</span><span class="w"> </span><span class="n">that</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ComparisonChain</span><span class="p">.</span><span class="na">start</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">lastName</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="na">lastName</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">firstName</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="na">firstName</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">zipCode</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="na">zipCode</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">result</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>确实简洁了许多~~</p>
<h2 id="总结"><span class="section-num">5</span> 总结</h2>
<p>到本文为止, Guava提供的基本工具类就已经介绍完了，暂时告一段落了,
接下来就要介绍Guava最常用的工具之一: 各种容器(Collections)</p>
]]></content:encoded>
    </item>
    <item>
      <title>Guava探究系列之二: 优雅校验数据</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%98%E9%9B%85%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 04 Jul 2019 10:16:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%98%E9%9B%85%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE/</guid>
      <description>1 前言 根据防御式编程的要求, 在日常的开发中, 总少不了对函数的各种入参做校验, 以便保证函数能按照预期的流程执行下去. 比如各种费率的值就没可能是</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<p>根据防御式编程的要求, 在日常的开发中, 总少不了对函数的各种入参做校验,
以便保证函数能按照预期的流程执行下去.</p>
<p>比如各种费率的值就没可能是负数, 如果费率出现负数, 所以数据有问题,
我们需要做的事情就是把这些有问题的数据挑出来.
自己手写这些校验函数未免过于繁琐, 所幸的是我们需要的函数已经有现成的:</p>
<p>Guava 提供了一系列的静态方法用于校验函数和类的构造器是否符合预期,
并称其为前置条件(preconditions). 如果前置条件校验失败,
就会抛出一个指定的异常.</p>
<h2 id="前置函数特征"><span class="section-num">2</span> 前置函数特征</h2>
<p>目前的前置校验方法有如下特征: 须需要, 下面例子中的=checkArgument=函数可以替换成任何一个前置条件校验函数</p>
<ol>
<li>这些前置方法一般接受一个布尔表达式作为入参，并判断表达是否为=true=,
格式如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 如果表达式为false, 抛出IllegalArgumentException</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>除了用于判断的布尔表达式之外,
前置方法可以接受一个额外的=Object=作为入参, 在抛出异常的时候,
把=Object.toString()=作为异常信息, 如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">enum</span><span class="w"> </span><span class="n">ErrorDetail</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">SC_NOT_FOUND</span><span class="p">(</span><span class="s">&#34;404&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Resource could not be fount&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 省略部分内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&#34;ErrorDetail{&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;code=&#39;&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">&#39;\&#39;&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;, description=&#39;&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">description</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">&#39;\&#39;&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">&#39;}&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testCheckArgument</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="n">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorDetail</span><span class="p">.</span><span class="na">SC_NOT_FOUND</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 结果如下:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// java.lang.IllegalArgumentException: ErrorDetail{code=&#39;404&#39;, description=&#39;Resource could not be fount&#39;}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Guava的前置表达式还支持类似=printf=函数那样的格式化输出错误信息,
只不过出于兼容性和性能的考虑, 只支持使用=%s=指示符格式化字符串,
不支持其他类型. 如:</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">checkArgument</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Argument was %s but expected nonnegative&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 结果如下:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// java.lang.IllegalArgumentException: Argument was -1 but expected nonnegative</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="前置条件函数介绍"><span class="section-num">3</span> 前置条件函数介绍</h2>
<p>须注意的是, 下面介绍的=checkArgument=, <code>checkArgument</code>,
=checkState=函数都有三个对应的重载函数，分别对应前文所述的三种特征,
下文不会三种函数都介绍, 只介绍标准格式的前置条件函数.
以=checkArgument=函数为例, 三个重载函数分别是(忽略函数体):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgument</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgument</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">errorMessage</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgument</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">,</span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">errorMessageTemplate</span><span class="p">,</span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Object</span><span class="p">...</span><span class="w"> </span><span class="n">errorMessageArgs</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkargument"><span class="section-num">3.1</span> checkArgument</h3>
<p>函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgument</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>入参是一个布尔表达式, 函数校验这个表达式是否为=true=, 如果为=false=,
抛出=IllegalArgumentException=. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testCheckArgument</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="n">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checknotnull"><span class="section-num">3.2</span> checkNotNull</h3>
<p>这是个泛型函数, 函数签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">checkNotNull</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">reference</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>入参是个任意类型的对象, 函数校验这个对象是否为=null=, 如果为空,
抛出=NullPointerException=, 否则直接返回该对象,
所以=checkNotNull=的用法就比较有趣, 可以在调用=setter=方法前作前置校验.
例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">PreconditionTest</span><span class="w"> </span><span class="n">caller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PreconditionTest</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">caller</span><span class="p">.</span><span class="na">setErrorDetail</span><span class="p">(</span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkNotNull</span><span class="p">(</span><span class="n">ErrorDetail</span><span class="p">.</span><span class="na">SC_INTERNAL_SERVER_ERROR</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkstate"><span class="section-num">3.3</span> checkState</h3>
<p>函数签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkState</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>看着这个函数, 我个人感觉很奇怪:
这个函数和=checkNotNull=函数功能非常相似, 实现也基本一样,
都是判断表达式是否为=true=, 只是抛出的异常不一样而已,
是否有必要开发这个函数. 两个函数的实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgument</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkState</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalStateException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此外, 因为这两个函数相当类似, 就不展示相应例子了.</p>
<h3 id="checkelementindex"><span class="section-num">3.4</span> checkElementIndex</h3>
<p>函数签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">checkElementIndex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数用于判断指定数组, 列表, 字符串的下标是否越界, <code>index=是下标, =size=是数组, 列表或字符串的长度, 下标的有效范围是</code>[0,数组长度)= 即
<code>0&lt;=index&lt;size</code>. 如果数组下标越界(即=index=&lt;0 或者 <code>index=&gt;==size</code>),
那么抛出=IndexOutOfBoundsException=异常, 否则返回数组的下标,
也就是=index=. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkElementIndex</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 运行结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: index (4) must be less than size (4)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkElementIndex</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 运行结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 通过</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="checkpositionindex"><span class="section-num">4</span> checkPositionIndex</h2>
<p>函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">checkPositionIndex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数和=checkElementIndex=非常类似, 连Guava wiki的说明也基本一致(只有一个单词不同).</p>
<p>除了一点, <code>checkElementIndex=函数的下标有效范围是</code>[0, 数组长度)=, 而=checkPositionIndex=函数的下标有有效范围是=[0, 数组长度]=,
即=0&lt;=index&lt;=size=. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkPositionIndex</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 运行结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Assert</span><span class="p">.</span><span class="na">assertEquals</span><span class="p">(</span><span class="n">4</span><span class="p">,</span><span class="w"> </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkPositionIndex</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;test&#34;</span><span class="p">.</span><span class="na">length</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 运行结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 通过</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="checkpositionindexes"><span class="section-num">4.1</span> checkPositionIndexes</h3>
<p>函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkPositionIndexes</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个函数是用于判断=[start,end]=这个范围是否是个有效范围, 即=[start, end]= 是否在=[0, size]= 范围内(如果=[start, end]=
和=[0, size]=相同, 也认为在范围内), 如果不在, 则抛出=IndexOutOfBoundsException=异常. 例子如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkPositionIndexes</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 运行结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: end index (3) must not be greater than size (2)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkPositionIndexes</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 运行结果:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 校验通过</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="前置条件在实际项目的应用"><span class="section-num">5</span> 前置条件在实际项目的应用</h2>
<p>前置条件在检验条件不成交的时候抛的异常类型虽说是合情合理(比如,
<code>checkArgument=函数抛出=IllegalArgumentException</code>),</p>
<p>但是对于业务系统来说, 你抛出个=IllegalArgumentException=或者=NullPointerException=, 接口调用方对于这个异常摸不着头脑, 虽说只是正常的数据问题,
还是很容易觉得接口提供方服务出了问题, 甚至还会被质疑技术不过硬.</p>
<p>咱们又不是底层组件, 抛个=NPE=, 着实是不成体统. 基于各种有的没的的原因,
我们的业务系统在使用前置条件的时候进行了封装,
将前置条件抛出的异常进行了转换, 换成正常的业务异常, 提供完整的异常信息,
代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 封装代码:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AssertUtils</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检查条件表达式是否为真
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param expression 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param errDetailEnum 错误码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param msgTemplate 错误消息模板
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param vars 占位符对应变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws BkmpException 条件表达式结果为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgument</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">,</span><span class="w"> </span><span class="n">ErrDetailEnum</span><span class="w"> </span><span class="n">errDetailEnum</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">msgTemplate</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                     </span><span class="n">Object</span><span class="p">...</span><span class="w"> </span><span class="n">vars</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IllegalArgumentException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BkmpException</span><span class="p">(</span><span class="n">errDetailEnum</span><span class="p">,</span><span class="w"> </span><span class="n">msgTemplate</span><span class="p">,</span><span class="w"> </span><span class="n">vars</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检查条件表达式是否为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param expression 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param errDetailEnum 错误码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param msgTemplate 错误消息模板
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param vars 占位符对应变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws BkmpException 条件表达式结果为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkArgumentNotTrue</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">expression</span><span class="p">,</span><span class="w"> </span><span class="n">ErrDetailEnum</span><span class="w"> </span><span class="n">errDetailEnum</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">msgTemplate</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                            </span><span class="n">Object</span><span class="p">...</span><span class="w"> </span><span class="n">vars</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="o">!</span><span class="n">expression</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IllegalArgumentException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BkmpException</span><span class="p">(</span><span class="n">errDetailEnum</span><span class="p">,</span><span class="w"> </span><span class="n">msgTemplate</span><span class="p">,</span><span class="w"> </span><span class="n">vars</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 省略其他部分的封装</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 调用例子:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">AssertUtils</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="n">merchantEntity</span><span class="p">.</span><span class="na">exist</span><span class="p">(),</span><span class="w"> </span><span class="n">ErrDetailEnum</span><span class="p">.</span><span class="na">DATA_NOT_EXIT</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;商户不存在&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="guava-precondition-vs-apache-common-validate"><span class="section-num">6</span> Guava Precondition vs Apache Common Validate</h2>
<p>自古文无第一, 武无第二, 文人之间的口水战总是少不了的.</p>
<p>没想到这不是国人的专利, 原来国外也有文人相轻的风气: Guava wiki
在介绍完preconditions之后, 还踩了一波竞品Apache Common Validate,
认为Guava的preconditions 比Apache Common 更加清晰明了, 也更加美观,</p>
<p>我个人对Apache Common Validate 了解不深, 也不好随意置喙. 除了踩竞品之外,
Guava wiki 还提了两点最佳实践(best practice):</p>
<ol>
<li>使用前置条件校验的时候, 推荐每个校验条件单独一行, 这样即更了然,
出问题也更方便调试.</li>
<li>使用前置条件校验的时候, 尽量提供有用的错误信息,
这样可以更快地定位问题.</li>
</ol>
<h2 id="总结"><span class="section-num">7</span> 总结</h2>
<p>代码大全一书有一章是关于防御式编程的, 用于提高程序的健壮性, 主要思想是子程序应该不因传入错误数据而被破坏，要保护程序免遭非法输入数据的破坏.</p>
<p>而Guava的preconditions 就是实现防御式编程的有力工具呢. oh yeah!</p>
<h2 id="参考"><span class="section-num">8</span> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/PreconditionsExplained">PreconditionsExplained</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Guava探究系列之一: 使用和避免使用空指针</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 02 Jul 2019 19:25:00 -0700</pubDate>
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8C%87%E9%92%88/</guid>
      <description>1 前言 To be, or not to be, that is the question: 先来看看奆佬们关于空指针的看法: Null sucks - Doug Lea(JCP,Java并发编程实战作者, Java巨佬) I call it my billion-dollar mistake. - Sir C.</description>
      <content:encoded><![CDATA[<h2 id="前言"><span class="section-num">1</span> 前言</h2>
<blockquote>
<p>To be, or not to be, that is the question:</p>
</blockquote>
<p>先来看看奆佬们关于空指针的看法:</p>
<blockquote>
<p>Null sucks - <a href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a>(JCP,Java并发编程实战作者, Java巨佬)</p>
<p>I call it my billion-dollar mistake. - <a href="https://en.wikipedia.org/wiki/C._A._R._Hoare">Sir C. A. R. Hoare</a>, 空指针的发明者</p>
</blockquote>
<p>按照Guava wiki的说法,
大部分的Google代码都是不支持使用空指针(下文用=null=表示空指针)的,</p>
<p>如接近95%的集合类都不支持使用=null=作为集合元素.
像Google这样的大公司明确不建议使用=null=自然是有其原由的, 不会无的放矢.
那具体原因是什么呢？待下文为你细细道来;</p>
<h2 id="空指针的问题"><span class="section-num">2</span> 空指针的问题</h2>
<h3 id="空指针语意隐晦不明"><span class="section-num">2.1</span> 空指针语意隐晦不明</h3>
<p><code>null=的语意并不了然明确, 即当一个函数返回=null</code>, 我们并不知道=null=的意思是指返回结果理应为空? 还是指函数没有达到预期结果, 返回=null=表示失败?</p>
<p>举个常见的例子, 当调用=Map.get(key)=获取key对应的value的时候, 返回结果为=null=; <code>null=是指找不到这个key对应的value? 还是说这个key对应的value本身就是=null</code>, 原来是通过=Map.put(key,value)=赋值的呢? =null=甚至可以是代表其他东西!</p>
<p>老实说, 当我们获得一个=null=, 我们并不清楚它究竟指的是啥,
除非有对应的javadoc 进行了说明.</p>
<h3 id="空指针-暗藏杀机"><span class="section-num">2.2</span> 空指针”暗藏杀机”</h3>
<p>=null=除了语意不明外, 还非常容易在不经意间挖坑坑人. 例如有下面的代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">testNull</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="na">nextInt</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">useNull</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testNull</span><span class="p">(</span><span class="s">&#34;foo#bar&#34;</span><span class="p">).</span><span class="na">split</span><span class="p">(</span><span class="s">&#34;#&#34;</span><span class="p">)</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testNull</span><span class="p">(</span><span class="s">&#34;foo#bar&#34;</span><span class="p">).</span><span class="na">split</span><span class="p">(</span><span class="s">&#34;#&#34;</span><span class="p">)</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可能你会说，这样的明显有坑的代码, 程序员理所当然会注意,
并对=null=指针进行校验的.</p>
<p>但事实并非如此, 因为=null=是一个特殊类型,
它可以表示一切的类型, 所以上面的代码是肯定可以编译通过的.
没有了编译器的约束, 只要使用=testNull=函数的时候没有查看源码,
或者源码非常复杂, 一下子理不清思路, 防御式编程落实不到,
就会忽略了=null=, 运行时就有可能抛出=NullPointException=, 导致程序crash.
这种情况真的防不胜防.</p>
<h2 id="guava对于空指针的态度"><span class="section-num">3</span> Guava对于空指针的态度</h2>
<p>因为上文提到或者隐藏但没提到的种种问题,
Guava的诸多类库在设计时就不支持=null=.</p>
<p>如果检测到=null=的存在, Guava的类库就会快速失败(fail fast),一般的处理策略是抛出异常.
虽说=null=存在种种的坑, 但=null=依旧是Java的一项关键特性,
因此Guava的类库也不能将=null=彻底拒之门外.</p>
<p>此外, Guava秉承既然不能消灭=null=, 那就把=null=建设得更好用的理念,
除了提供了一些工具可以让开发者避免使用=null=,
还提供了可以让开发者更易于使用=null=的工具.</p>
<h2 id="optional"><span class="section-num">4</span> Optional</h2>
<p>在很多情况下, 程序员使用=null=是为了表示有些值可能存在或者不存在.
我们又可以用熟悉的=Map.get(key)=函数来举例,
如果规定=null=不能作为=value=值使用(但事实并非如此),
那么当这个函数返回=null=时就代表没有找到这个=key=对应的=value=.</p>
<p>为了应对这种使用=null=的情况, Guava团队参考其他语言(例如Scala)应对=null=的实践, 开发了=Optional&lt;T&gt;=类.
<code>Optional=类表示那些可能为空的值, 一个=Optional=类要不包含一个非空的=T=类型的对象引用(这种情况下, 我们称引用对象是存在的-&quot;present&quot;), 要不什么东西都不包含(这种情况被, 我们说引用对象是不存在的-&quot;absent&quot;), 除此之外, =Optional=不存在其他情况, 更没有可能是=null</code>.</p>
<h3 id="java8的optional"><span class="section-num">4.1</span> Java8的Optional</h3>
<p>鉴于我对=Optional=类的兴趣,
我用下面这条命令找了一个Guava库=Optional=开发的最初提交历史:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">find guava/ -name <span class="s2">&#34;Optional.java&#34;</span> -print <span class="p">|</span> xargs -I <span class="s1">&#39;{}&#39;</span> git log --pretty<span class="o">=</span>tformat:%cd-%aN-%s --date<span class="o">=</span>iso <span class="p">|</span>tail -n2
</span></span><span class="line"><span class="cl"><span class="c1"># 结果如下</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2009-09-15 19:50:59 +0000-kevinb@google.com-Initial code dump: version 9.09.15</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2009-06-18 18:11:55 +0000-(no author)-Initial directory structure.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从Guava的commit历史中, 我们可以知道=Optional=最开始是在2009年开始开发的,
而10年前还是Java6的时代, Java7都尚未发布.</p>
<p>在那个”远古年代”, 是Guava的=Optional=一直引领着Java的抗击=null=重任,
为众多的蒙受”空指针之苦”的Java的程序员带来希望之光.</p>
<p>而当时光的脚步终于来到2014年3月18号, 在这一天, Java程序员迎来了Java8,
这是自Java5发布以来最激动人心的发布. 这天之后, 尘埃落定, <code>Optional</code>,
<code>Stream</code>, =Lambda=等诸多令人期待已久的特性终于成为Java的标准库的一部分,
而这也意味, Guava的=Optional=已经完成了自己的使命, 成为历史.</p>
<p>Guava的=Optional=类与JDK的=Optional=功能类似,
既然JDK的=Optional=已成为正统,
那么下面我就不再介绍Guava的=Optional=(Guava的wiki本来是有较大篇幅介绍自家的=Optional=,
个人感觉已经意义不大), 转而介绍JDK的=Optional=(下文通称为=Optional=).</p>
<h3 id="optional构造方式"><span class="section-num">4.2</span> Optional构造方式</h3>
<p>在使用=Optional=之前, 首先需要了解如果构造=Optional=对象,
方式有如下几种:</p>
<h4 id="声明一个空的-optional-对象"><span class="section-num">4.2.1</span> 声明一个空的=Optional=对象</h4>
<p>可以通过静态工厂方法=Optional.empty=, 创建一个空的=Optional=对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="根据一个非空值创建optional"><span class="section-num">4.2.2</span> 根据一个非空值创建Optional</h4>
<p>还可以使用静态工厂方法=Optional.of=,
依据一个非空值创建一个=Optional=对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">objectT</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是, 按照=Optional=的源码声明, 如果传入的=objectT=为=null=,
那么=Optional=就会立刻抛出=NullPointException=(这就是快速失败-fail
fast), 而还是等到访问=optional=属性时才返回一个错误.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Returns an {@code Optional} with the specified present non-null value.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param &lt;T&gt; the class of the value
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param value the value to be present, which must be non-null
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return an {@code Optional} with the value present
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws NullPointerException if value is null
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">of</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Optional</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="可接受null的optional"><span class="section-num">4.2.3</span> 可接受null的Optional</h4>
<p>最后, 使用静态工厂方法=Optional.ofNullable=,
我们可以创建一个允许=null=的=Optional=的对象:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Optional</span><span class="p">.</span><span class="na">ofNullable</span><span class="p">(</span><span class="n">objectT</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果=objectT=为=null=, 那么得到的=Optional=对象就是个空对象.</p>
<h3 id="optional的消费方式"><span class="section-num">4.3</span> Optional的消费方式</h3>
<h4 id="optional与stream的邂逅"><span class="section-num">4.3.1</span> Optional与Stream的邂逅</h4>
<p>既然=Optional=在Oracle的文档中被定性为一个容器(container),</p>
<p>那么对于一个容器,
我们关注的点无非是这个容器如何*存*(对于=Optional=来说是构造)和如何*取*这两件事而已(也就是消费).
在谈=Optional=的消费接口之前,
先来回顾一下Java8引进的=Stream=操作(关于Java8
=Stream=操作的说明已经汗牛充栋了, 既然珠玉在前, 我就不赘言了),
常用的=Stream=操作函数有如下几个:</p>
<ul>
<li>filter</li>
<li>map</li>
<li>flatmap</li>
<li>peek</li>
<li>reduce</li>
<li>更多的函数可以参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Oracle文档</a></li>
</ul>
<p>因为前文已经说过=Optional=是容器类, 那么按理来说,
正常容器类支持的=Stream=操作, =Optional=也支持.</p>
<p>只不过在Java8的时候, <code>Optional=只支持=filter</code>,=map=和=flatmap=这三个=Stream=操作.</p>
<p>可能是因为Java委员会的奆佬们也觉得=Optional=身为一个容器类只支持三个=Stream=操作有点丢人,
所以在Java9,
=Optional=增加了一个=Optional.stream()=这样一个可以返回=Stream=对象的函数,
让=Optional=拥有了容器类操作=Stream=的所有能力,
重振了身为一个容器的荣光. =Optional=与=Stream=结合使用的示例如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">getCarInsuranceName</span><span class="p">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="n">person</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">person</span><span class="p">.</span><span class="na">flatMap</span><span class="p">(</span><span class="n">Person</span><span class="p">::</span><span class="n">getCar</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">.</span><span class="na">getName</span><span class="p">().</span><span class="na">equals</span><span class="p">(</span><span class="s">&#34;Spaceship&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="na">flatMap</span><span class="p">(</span><span class="n">Car</span><span class="p">::</span><span class="n">getInsurance</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">Insurance</span><span class="p">::</span><span class="n">getName</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="na">orElse</span><span class="p">(</span><span class="s">&#34;Unknown&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="默认行为及解引用optional对象"><span class="section-num">4.3.2</span> 默认行为及解引用Optional对象</h4>
<p>除了使用=Stream=来消费=Optional=对象,
还可以使用解引用读取=Optional=实例中的变量值以及定义默认行为,
具体函数说明如下:</p>
<ol>
<li>=get()=是这些方法中最简单但又最不安全的方法. 如果变量存在,
它直接返回封闭的变量值. 否则就抛出一个=NoSuchElementException=异常.
所以, 除非是非常确定=Optional=变量一定包含值,
否则使用这个函数就相当容易踩坑. 此外,
使用这个函数和直接进行=null=检查差别并不大.</li>
<li><code>orElse(T other)</code>
该函数允许在=Optional=对象不存在的时候提供一个默认值(也是我个人最常用的使用方式之一)</li>
<li>=orElseGet(Supplier&lt;? extends T&gt; other)=是=orElse=函数的延迟调用版,
=Supplier=方法只有在=Optional=对象不含值的时候才执行.
如果创建默认值是件耗时操作, 那么可以使用这种方式来提升性能,
又或者某个函数仅在=Optional=为空的时候才调用, 也可以使用这种方式</li>
<li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>
和=get=方法非常类似, 这两个函数都会在=Optional=对象为空时, 抛出异常,
但差别在于=orElseThrow=可以指定抛出的异常类型</li>
<li>=ifPresent(Consumer&lt;? super T&gt;)=和=orElseGet=函数类似,
可以在变量存在的时候执行传入的函数, 否则就不进行任何操作.</li>
</ol>
<h4 id="optional-实战示例"><span class="section-num">4.3.3</span> Optional 实战示例</h4>
<p>在啰啰嗦嗦介绍了一系列=Optional=的概念之后,
是时候来看一下=Option=的实例了. 现存的Java
API几乎都是通过返回一个null的方式表示所需的值的缺失,
或者由于某些原因计算无法得到所需的值.</p>
<p>在上文, 我们已经给=null=盖棺定论了, <code>null=是有坑的, 甚至是有害的, 所以要尽量少用=null</code>. 而现存的海量Java API都已经使用=null=作为返回结果,
我们没可能把这些API都重构成返回一个=Optional=对象的, 但眼看着=Optional=这样一个设计更完善无法在已有的Java API中使用未免令人心有不甘.</p>
<p>现实中, 可能我们无法修改这些API的签名, 但是我们却可以很轻易地用=Optional=对象对这些API的返回值进行封装.
现在还是用熟悉的=Map=举例, 假设有一个=Map&lt;String, Object&gt;=的对象, 在查询=key=对应的=value=时, 如果=value=不存在,
那么调用=Map.get(key)=就会返回一个=null=:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Object</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>现在, 每次使用=value=都需要进行空指针判断, 着实是太繁琐.
为了解决这个问题, 可以使用=Optional.ofNullable=函数进行优化:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;bar&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Optional</span><span class="p">.</span><span class="na">ofNullable</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)).</span><span class="na">map</span><span class="p">(</span><span class="n">Object</span><span class="p">::</span><span class="n">toString</span><span class="p">).</span><span class="na">orElse</span><span class="p">(</span><span class="s">&#34;helloworld&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样, 每次使用=value=都不会再有=NullPointException=的忧虑.</p>
<h2 id="结语"><span class="section-num">5</span> 结语</h2>
<p>本文最开始只是想阐述Guava类库使用空指针和避免使用空指针的设计理念,
只是因为Guava大部分类库都是不支持=null=,
因此使用Guava自家的=Optional=类来代替=null=的大部分应用场景,
而Guava自家的=Optional=无可避免地被JDK的=Optional=取代,</p>
<p>所以本文大部份的内容也变成对JDK的=Optional=的探讨.
相信下篇文章会有所改观, 总不可能Guava所有的工具类, 都有JDK对应的竞品,
如果真是这样的话, JDK应该改名为GDK :)</p>
<h2 id="参考"><span class="section-num">6</span> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained">Using and avoiding</a></li>
<li><a href="https://book.douban.com/subject/25912747/">Java8 in Action</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Oracle java doc about Optional</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
