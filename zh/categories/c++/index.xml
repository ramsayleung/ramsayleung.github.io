<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>c&#43;&#43; on 自由庄园</title>
    <link>https://ramsayleung.github.io/zh/categories/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on 自由庄园</description>
    <image>
      <title>自由庄园</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>See this site&#39;s source code [here](https://github.com/ramsayleung/ramsayleung.github.io), licensed under GPLv3 ·</copyright>
    <lastBuildDate>Fri, 30 Aug 2024 22:23:00 -0700</lastBuildDate><atom:link href="https://ramsayleung.github.io/zh/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust模拟C&#43;&#43;的函数重载</title>
      <link>https://ramsayleung.github.io/zh/post/2024/rust%E6%A8%A1%E6%8B%9Fc&#43;&#43;%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Fri, 30 Aug 2024 22:23:00 -0700</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2024/rust%E6%A8%A1%E6%8B%9Fc&#43;&#43;%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</guid>
      <description>1 函数重载(function overloading) 所谓的函数重载，指的是某些语言支持创建函数名相同，但函数签名不同的多个函数，所谓的函数签名，既指参数类型，也指</description>
      <content:encoded><![CDATA[<h2 id="函数重载--function-overloading"><!-- raw HTML omitted -->1<!-- raw HTML omitted --> 函数重载(function overloading)</h2>
<p>所谓的函数重载，指的是某些语言支持创建函数名相同，但函数签名不同的多个函数，所谓的函数签名，既指参数类型，也指参数的数量。 <!-- raw HTML omitted --></p>
<p>如C++，Java都是支持函数重载的，而Rust是不支持函数重载的, 个人猜测可能是Rust最初的设计者认为函数重载可能会导致增加代码理解难度，尤其是在C++里面，隐式类型转换叠加函数重载，可能看代码都看不出实际调用的是哪个版本的函数。 <!-- raw HTML omitted --></p>
<h2 id="rust版本的函数重载"><!-- raw HTML omitted -->2<!-- raw HTML omitted --> Rust版本的函数重载</h2>
<p>但是我个人觉得函数重载在大部分情况下都是很方便，也不需要为相同的函数想不同的名字，毕竟命名是编程最难的问题之一。 <!-- raw HTML omitted -->
今天重读 Programming Rust, 2nd Edition关于 <code>Into</code> 这个trait 的功能的时候，突然意识到，可以使用 <code>Into</code> 模拟出部分的函数重载功能。 <!-- raw HTML omitted --></p>
<p>为什么说是「部分」呢，因为前文提到，所谓的函数重载是指多个同名但函数签名不一样的函数，而Rust能模拟的就是参数类型不一样，但是参数数量一致的重载函数。 <!-- raw HTML omitted --></p>
<p>假设我们想实现自己的 <code>ping</code> 命名, 入参可以是 <a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html"><code>Ipv4Addr</code></a> 这个 struct, ipv4的地址也可以使用2进制来表示, 又或者可以使用 u32 来表示，毕竟只有32位。 <!-- raw HTML omitted --></p>
<p>如果用 C++, 我们可以写3个重载函数，入参分别是, <code>Ipv4Addr</code>, <code>bitset</code> 和 <code>uint32</code>. 在 Rust, 我们也实现类似的函数： <!-- raw HTML omitted --></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">Ipv4Addr</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">ping</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">address</span>: <span class="nc">A</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Ipv4Addr</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ipv4_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>需要注意的是，上面函数的入参并不是 <code>Ipv4Addr</code>, 而是 <code>Into&lt;Ipv4Addr&gt;=，这就是意味着，所有实现了 =Into&lt;Ipv4Addr&gt;</code> 这个 trait 的类型都可以是 <code>ping</code> 的入参，而恰好 <code>u32</code> 和 <code>[u8; 4]</code> 都实现了 =Into&lt;Ipv4Addr&gt;=，所以下面的调用都是编译通过的： <!-- raw HTML omitted --></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ping</span><span class="p">(</span><span class="n">Ipv4Addr</span>::<span class="n">new</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">68</span><span class="p">,</span><span class="w"> </span><span class="mi">141</span><span class="p">)));</span><span class="w"> </span><span class="c1">// pass an Ipv4Addr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ping</span><span class="p">([</span><span class="mi">66</span><span class="p">,</span><span class="w"> </span><span class="mi">146</span><span class="p">,</span><span class="w"> </span><span class="mi">219</span><span class="p">,</span><span class="w"> </span><span class="mi">98</span><span class="p">]));</span><span class="w">             </span><span class="c1">// pass a [u8; 4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ping</span><span class="p">(</span><span class="mh">0xd076eb94_</span><span class="k">u32</span><span class="p">));</span><span class="w">                 </span><span class="c1">// pass a u32
</span></span></span></code></pre></div><p>当然，如果你实现了 <code>impl From&lt;u32&gt; for Ipv4Addr</code>, Rust 编译器也会贴心地帮你把反向的 <code>Into&lt;Ipv4Addr&gt;</code> 也实现掉。 <!-- raw HTML omitted --></p>
<h2 id="限制"><!-- raw HTML omitted -->3<!-- raw HTML omitted --> 限制</h2>
<p>看完上面的函数实现，有经验的朋友可能就会发现了，Rust版本的函数重载限制比C++的要多。 <!-- raw HTML omitted --></p>
<p>在C++版本的函数重载中： <!-- raw HTML omitted --></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="n">Type1</span> <span class="n">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="n">Type2</span> <span class="n">bar</span><span class="p">);</span>
</span></span></code></pre></div><p>参数类型 <code>Type1</code> 和 <code>Type2</code> 并不需要存在任何关系，但是在 Rust 版本中，需要两个类型之间支持相互转换，所以可以理解成 Rust 的「函数重载」本质就是通过显示类型转换来实现的。 <!-- raw HTML omitted --></p>
<p>毕竟 Rust 设计初衷之一就是支持强类型，就函数重载而言，终归聊胜于无啦。 <!-- raw HTML omitted --></p>
<h2 id="参考"><!-- raw HTML omitted -->4<!-- raw HTML omitted --> 参考</h2>
<ul>
<li><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Programming Rust, 2nd Edition</a> <!-- raw HTML omitted --></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
