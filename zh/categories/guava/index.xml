<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>guava on 自留地</title>
    <link>https://ramsayleung.github.io/zh/categories/guava/</link>
    <description>Recent content in guava on 自留地</description>
    <image>
      <title>自留地</title>
      <url>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ramsayleung.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>See this site&#39;s source code [here](https://github.com/ramsayleung/ramsayleung.github.io), licensed under GPLv3 ·</copyright>
    <lastBuildDate>Thu, 04 Jul 2019 10:16:00 +0800</lastBuildDate><atom:link href="https://ramsayleung.github.io/zh/categories/guava/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Guava探究系列之二: 优雅校验数据</title>
      <link>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%98%E9%9B%85%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 04 Jul 2019 10:16:00 +0800</pubDate>
      
      <guid>https://ramsayleung.github.io/zh/post/2019/guava%E6%8E%A2%E7%A9%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BC%98%E9%9B%85%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE/</guid>
      <description>1 前言 根据防御式编程的要求, 在日常的开发中, 总少不了对函数的各种入参做校验, 以便保证函数能按照预期的流程执行下去. 比如各种费率的值就没可能是</description>
      <content:encoded><![CDATA[<h2 id="前言"><!-- raw HTML omitted -->1<!-- raw HTML omitted --> 前言</h2>
<p>根据防御式编程的要求, 在日常的开发中, 总少不了对函数的各种入参做校验,
以便保证函数能按照预期的流程执行下去.</p>
<p>比如各种费率的值就没可能是负数, 如果费率出现负数, 所以数据有问题,
我们需要做的事情就是把这些有问题的数据挑出来.
自己手写这些校验函数未免过于繁琐, 所幸的是我们需要的函数已经有现成的:</p>
<p>Guava 提供了一系列的静态方法用于校验函数和类的构造器是否符合预期,
并称其为前置条件(preconditions). 如果前置条件校验失败,
就会抛出一个指定的异常.</p>
<h2 id="前置函数特征"><!-- raw HTML omitted -->2<!-- raw HTML omitted --> 前置函数特征</h2>
<p>目前的前置校验方法有如下特征: 须需要, 下面例子中的<code>checkArgument</code>函数可以替换成任何一个前置条件校验函数</p>
<ol>
<li>这些前置方法一般接受一个布尔表达式作为入参，并判断表达是否为<code>true</code>,
格式如:</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果表达式为false, 抛出IllegalArgumentException
</span></span></span></code></pre></div><ol start="2">
<li>除了用于判断的布尔表达式之外,
前置方法可以接受一个额外的<code>Object</code>作为入参, 在抛出异常的时候,
把<code>Object.toString()</code>作为异常信息, 如:</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">enum</span> <span class="n">ErrorDetail</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SC_NOT_FOUND</span><span class="o">(</span><span class="s">&#34;404&#34;</span><span class="o">,</span> <span class="s">&#34;Resource could not be fount&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略部分内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="s">&#34;ErrorDetail{&#34;</span> <span class="o">+</span> <span class="s">&#34;code=&#39;&#34;</span> <span class="o">+</span> <span class="n">code</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span> <span class="s">&#34;, description=&#39;&#34;</span> <span class="o">+</span> <span class="n">description</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span> <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCheckArgument</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">ErrorDetail</span><span class="o">.</span><span class="na">SC_NOT_FOUND</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 结果如下:
</span></span></span><span class="line"><span class="cl"><span class="c1">// java.lang.IllegalArgumentException: ErrorDetail{code=&#39;404&#39;, description=&#39;Resource could not be fount&#39;}
</span></span></span></code></pre></div><ol start="3">
<li>Guava的前置表达式还支持类似<code>printf</code>函数那样的格式化输出错误信息,
只不过出于兼容性和性能的考虑, 只支持使用<code>%s</code>指示符格式化字符串,
不支持其他类型. 如:</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="n">checkArgument</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&#34;Argument was %s but expected nonnegative&#34;</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 结果如下:
</span></span></span><span class="line"><span class="cl"><span class="c1">// java.lang.IllegalArgumentException: Argument was -1 but expected nonnegative
</span></span></span></code></pre></div><h2 id="前置条件函数介绍"><!-- raw HTML omitted -->3<!-- raw HTML omitted --> 前置条件函数介绍</h2>
<p>须注意的是, 下面介绍的<code>checkArgument</code>, <code>checkArgument</code>,
<code>checkState</code>函数都有三个对应的重载函数，分别对应前文所述的三种特征,
下文不会三种函数都介绍, 只介绍标准格式的前置条件函数.
以<code>checkArgument</code>函数为例, 三个重载函数分别是(忽略函数体):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">Object</span> <span class="n">errorMessage</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span><span class="nd">@Nullable</span> <span class="n">String</span> <span class="n">errorMessageTemplate</span><span class="o">,</span><span class="nd">@Nullable</span> <span class="n">Object</span><span class="o">...</span> <span class="n">errorMessageArgs</span><span class="o">)</span>
</span></span></code></pre></div><h3 id="checkargument"><!-- raw HTML omitted -->3.1<!-- raw HTML omitted --> checkArgument</h3>
<p>函数的签名如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">);</span>
</span></span></code></pre></div><p>入参是一个布尔表达式, 函数校验这个表达式是否为<code>true</code>, 如果为<code>false</code>,
抛出<code>IllegalArgumentException</code>. 例子如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCheckArgument</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="checknotnull"><!-- raw HTML omitted -->3.2<!-- raw HTML omitted --> checkNotNull</h3>
<p>这是个泛型函数, 函数签名如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">checkNotNull</span><span class="o">(</span><span class="n">T</span> <span class="n">reference</span><span class="o">);</span>
</span></span></code></pre></div><p>入参是个任意类型的对象, 函数校验这个对象是否为<code>null</code>, 如果为空,
抛出<code>NullPointerException</code>, 否则直接返回该对象,
所以<code>checkNotNull</code>的用法就比较有趣, 可以在调用<code>setter</code>方法前作前置校验.
例子如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">PreconditionTest</span> <span class="n">caller</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PreconditionTest</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="n">caller</span><span class="o">.</span><span class="na">setErrorDetail</span><span class="o">(</span><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">ErrorDetail</span><span class="o">.</span><span class="na">SC_INTERNAL_SERVER_ERROR</span><span class="o">));</span>
</span></span></code></pre></div><h3 id="checkstate"><!-- raw HTML omitted -->3.3<!-- raw HTML omitted --> checkState</h3>
<p>函数签名如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkState</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">);</span>
</span></span></code></pre></div><p>看着这个函数, 我个人感觉很奇怪:
这个函数和<code>checkNotNull</code>函数功能非常相似, 实现也基本一样,
都是判断表达式是否为<code>true</code>, 只是抛出的异常不一样而已,
是否有必要开发这个函数. 两个函数的实现如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(!</span><span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkState</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(!</span><span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>此外, 因为这两个函数相当类似, 就不展示相应例子了.</p>
<h3 id="checkelementindex"><!-- raw HTML omitted -->3.4<!-- raw HTML omitted --> checkElementIndex</h3>
<p>函数签名如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">checkElementIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span></code></pre></div><p>这个函数用于判断指定数组, 列表, 字符串的下标是否越界, <code>index</code>是下标,
<code>size</code>是数组, 列表或字符串的长度, 下标的有效范围是<code>[0,数组长度)</code> 即
<code>0&lt;=index&lt;size</code>. 如果数组下标越界(即<code>index=&lt;0 或者 =index=&gt;==size</code>),
那么抛出<code>IndexOutOfBoundsException</code>异常, 否则返回数组的下标,
也就是<code>index</code>. 例子如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkElementIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: index (4) must be less than size (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkElementIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 通过
</span></span></span></code></pre></div><h2 id="checkpositionindex"><!-- raw HTML omitted -->4<!-- raw HTML omitted --> checkPositionIndex</h2>
<p>函数的签名如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">checkPositionIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span></code></pre></div><p>这个函数和<code>checkElementIndex</code>非常类似, 连Guava wiki的说明也基本一致(只有一个单词不同).</p>
<p>除了一点, <code>checkElementIndex</code>函数的下标有效范围是<code>[0, 数组长度)</code>, 而<code>checkPositionIndex</code>函数的下标有有效范围是<code>[0, 数组长度]</code>,
即<code>0&lt;=index&lt;=size</code>. 例子如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndex</span><span class="o">(</span><span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="s">&#34;test&#34;</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 通过
</span></span></span></code></pre></div><h3 id="checkpositionindexes"><!-- raw HTML omitted -->4.1<!-- raw HTML omitted --> checkPositionIndexes</h3>
<p>函数的签名如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkPositionIndexes</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</span></span></code></pre></div><p>这个函数是用于判断<code>[start,end]</code>这个范围是否是个有效范围, 即<code>[start, end]</code> 是否在<code>[0, size]</code> 范围内(如果<code>[start, end]</code>
和<code>[0, size]</code>相同, 也认为在范围内), 如果不在, 则抛出<code>IndexOutOfBoundsException</code>异常. 例子如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndexes</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 抛出异常: java.lang.IndexOutOfBoundsException: end index (3) must not be greater than size (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Preconditions</span><span class="o">.</span><span class="na">checkPositionIndexes</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 运行结果:
</span></span></span><span class="line"><span class="cl"><span class="c1">// 校验通过
</span></span></span></code></pre></div><h2 id="前置条件在实际项目的应用"><!-- raw HTML omitted -->5<!-- raw HTML omitted --> 前置条件在实际项目的应用</h2>
<p>前置条件在检验条件不成交的时候抛的异常类型虽说是合情合理(比如,
<code>checkArgument</code>函数抛出<code>IllegalArgumentException</code>),</p>
<p>但是对于业务系统来说, 你抛出个<code>IllegalArgumentException</code>或者<code>NullPointerException</code>, 接口调用方对于这个异常摸不着头脑, 虽说只是正常的数据问题,
还是很容易觉得接口提供方服务出了问题, 甚至还会被质疑技术不过硬.</p>
<p>咱们又不是底层组件, 抛个<code>NPE</code>, 着实是不成体统. 基于各种有的没的的原因,
我们的业务系统在使用前置条件的时候进行了封装,
将前置条件抛出的异常进行了转换, 换成正常的业务异常, 提供完整的异常信息,
代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 封装代码:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">AssertUtils</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检查条件表达式是否为真
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param expression 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param errDetailEnum 错误码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param msgTemplate 错误消息模板
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param vars 占位符对应变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws BkmpException 条件表达式结果为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgument</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span> <span class="n">ErrDetailEnum</span> <span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">String</span> <span class="n">msgTemplate</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">				     <span class="n">Object</span><span class="o">...</span> <span class="n">vars</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="n">expression</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">throw</span> <span class="k">new</span> <span class="n">BkmpException</span><span class="o">(</span><span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">msgTemplate</span><span class="o">,</span> <span class="n">vars</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 检查条件表达式是否为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param expression 条件表达式
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param errDetailEnum 错误码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param msgTemplate 错误消息模板
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param vars 占位符对应变量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws BkmpException 条件表达式结果为假
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkArgumentNotTrue</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">expression</span><span class="o">,</span> <span class="n">ErrDetailEnum</span> <span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">String</span> <span class="n">msgTemplate</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">					    <span class="n">Object</span><span class="o">...</span> <span class="n">vars</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(!</span><span class="n">expression</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">throw</span> <span class="k">new</span> <span class="n">BkmpException</span><span class="o">(</span><span class="n">errDetailEnum</span><span class="o">,</span> <span class="n">msgTemplate</span><span class="o">,</span> <span class="n">vars</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 省略其他部分的封装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 调用例子:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">AssertUtils</span><span class="o">.</span><span class="na">checkArgument</span><span class="o">(</span><span class="n">merchantEntity</span><span class="o">.</span><span class="na">exist</span><span class="o">(),</span> <span class="n">ErrDetailEnum</span><span class="o">.</span><span class="na">DATA_NOT_EXIT</span><span class="o">,</span> <span class="s">&#34;商户不存在&#34;</span><span class="o">);</span>
</span></span></code></pre></div><h2 id="guava-precondition-vs-apache-common-validate"><!-- raw HTML omitted -->6<!-- raw HTML omitted --> Guava Precondition vs Apache Common Validate</h2>
<p>自古文无第一, 武无第二, 文人之间的口水战总是少不了的.</p>
<p>没想到这不是国人的专利, 原来国外也有文人相轻的风气: Guava wiki
在介绍完preconditions之后, 还踩了一波竞品Apache Common Validate,
认为Guava的preconditions 比Apache Common 更加清晰明了, 也更加美观,</p>
<p>我个人对Apache Common Validate 了解不深, 也不好随意置喙. 除了踩竞品之外,
Guava wiki 还提了两点最佳实践(best practice):</p>
<ol>
<li>使用前置条件校验的时候, 推荐每个校验条件单独一行, 这样即更了然,
出问题也更方便调试.</li>
<li>使用前置条件校验的时候, 尽量提供有用的错误信息,
这样可以更快地定位问题.</li>
</ol>
<h2 id="总结"><!-- raw HTML omitted -->7<!-- raw HTML omitted --> 总结</h2>
<p>代码大全一书有一章是关于防御式编程的, 用于提高程序的健壮性, 主要思想是子程序应该不因传入错误数据而被破坏，要保护程序免遭非法输入数据的破坏.</p>
<p>而Guava的preconditions 就是实现防御式编程的有力工具呢. oh yeah!</p>
<h2 id="参考"><!-- raw HTML omitted -->8<!-- raw HTML omitted --> 参考</h2>
<ul>
<li><a href="https://github.com/google/guava/wiki/PreconditionsExplained">PreconditionsExplained</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
